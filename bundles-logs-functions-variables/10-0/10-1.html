<h3>10.1 <code>measurements</code> promises in <samp><span>monitor</span></samp></h3>

<p><br>

   <p><i>These features are available only in Enterprise versions of CFEngine.</i>

   <p>By default,CFEngine's monitoring component <code>cf-monitord</code> records performance data about the system. These include process counts, service traffic, load average and CPU utilization and temperature when available.

   <p>CFEngine Nova extends this in two ways. First it adds a three year trend summary based any `shift'-averages. Second, it adds customizable promises to monitor or log very specific user data through a generic interface. The end result is to either generate a periodic time series, like the above mentioned values, or to log the results to custom-defined reports.

   <p>CFEngine Nova adds a new promise type in bundles for the monitoring agent. These are written just like all other promises within a bundle destined for the agent concerned (however, you do not need to add them to the <code>bundlesequence</code>  they are executed by <code>cf-monitord</code> because they are bundles of type <code>monitor</code>). In this case:

<pre>bundle monitor watch

{
measurements:

  # promises ...

}

</pre>

   <p>It is important to specify a promise <code>handle</code> for measurement promises, as the names defined in the handle are used to determine the name of the log file or variable to which data will be reported. Log files are created under <samp><span>WORKDIR/state</span></samp>. Data that have no history type are stored in a special variable context called <samp><span>mon</span></samp>, analogous to the system variables in <samp><span>sys</span></samp>. Thus the values may be used in other promises in the form <code>$(mon.handle)</code>.

   <p><br>

<pre>
  # Follow a special process over time
  # using CFEngine's process cache to avoid resampling

   "/var/cfengine/state/cf_rootprocs"

      handle => "monitor_self_watch",
      stream_type => "file",
      data_type => "int",
      history_type => "weekly",
      units => "kB",
      match_value => proc_value(".*cf-monitord.*",
         "root\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+([0-9]+).*");


  # Discover disk device information

  "/bin/df"

      handle => "free_diskspace_watch",
      stream_type => "pipe",
      data_type => "slist",
      history_type => "static",
      units => "device",
      match_value => file_systems;
      # Update this as often as possible

}

##########################################################

body match_value proc_value(x,y)
{
select_line_matching => "$(x)";
extraction_regex => "$(y)";
}

body match_value file_systems
{
select_line_matching => "/.*";
extraction_regex => "(.*)";
}


</pre>

   <p><br>

<p><b>Notes:</b>

   <p>The general pattern of these promises is to decide whether the source of the information is either a file or pipe, determine the data type (integer, string etc.), specify a pattern to match the result in the file stream and then specify what to do with the result afterwards.

<p><b>Standard measurements:</b>

   <p>The <code>cf-monitord</code> service monitors a number of variables as standard on Unix and Windows systems. Windows is fundamentally different from Unix and currently has less support for out-of-the-box probes.

     <ol>
<li>users:
Users logged in
<li>rootprocs:
Privileged system processes
<li>otherprocs:
Non-privileged process
<li>diskfree:
Free disk on / partition
<li>loadavg:
% kernel load utilization
<li>netbiosns_in:
netbios name lookups (in)
<li>netbiosns_out:
netbios name lookups (out)
<li>netbiosdgm_in:
netbios name datagrams (in)
<li>netbiosdgm_out:
netbios name datagrams (out)
<li>netbiosssn_in:
netbios name sessions (in)
<li>netbiosssn_out:
netbios name sessions (out)
<li>irc_in:
IRC connections (in)
<li>irc_out:
IRC connections (out)
<li>cfengine_in:
CFEngine connections (in)
<li>cfengine_out:
CFEngine connections (out)
<li>nfsd_in:
nfs connections (in)
<li>nfsd_out:
nfs connections (out)
<li>smtp_in:
smtp connections (in)
<li>smtp_out:
smtp connections (out)
<li>www_in:
www connections (in)
<li>www_out:
www connections (out)
<li>ftp_in:
ftp connections (in)
<li>ftp_out:
ftp connections (out)
<li>ssh_in:
ssh connections (in)
<li>ssh_out:
ssh connections (out)
<li>wwws_in:
wwws connections (in)
<li>wwws_out:
wwws connections (out)
<li>icmp_in:
ICMP packets (in)
<li>icmp_out:
ICMP packets (out)
<li>udp_in:
UDP dgrams (in)
<li>udp_out:
UDP dgrams (out)
<li>dns_in:
DNS requests (in)
<li>dns_out:
DNS requests (out)
<li>tcpsyn_in:
TCP sessions (in)
<li>tcpsyn_out:
TCP sessions (out)
<li>tcpack_in:
TCP acks (in)
<li>tcpack_out:
TCP acks (out)
<li>tcpfin_in:
TCP finish (in)
<li>tcpfin_out:
TCP finish (out)
<li>tcpmisc_in:
TCP misc (in)
<li>tcpmisc_out:
TCP misc (out)
<li>webaccess:
Webserver hits
<li>weberrors:
Webserver errors
<li>syslog:
New log entries (Syslog)
<li>messages:
New log entries (messages)
<li>temp0:
CPU Temperature core 0
<li>temp1:
CPU Temperature core 1
<li>temp2:
CPU Temperature core 2
<li>temp3:
CPU Temperature core 3
<li>cpu:
%CPU utilization (all)
<li>cpu0:
%CPU utilization core 0
<li>cpu1:
%CPU utilization core 1
<li>cpu2:
%CPU utilization core 2
<li>cpu3:
%CPU utilization core 3
        </ol>

   <p>Slots with a higher number are used for custom measurement promises in CFEngine Nova.

   <p>These values collected and analysed by <code>cf-monitord</code> are transformed into agent variables in the <code>$(mon.</code><var>name</var><code>)</code> context.

<p><b>Measurement promise syntax:</b>

<ul>
<li><a>stream_type in measurements</a>
<li><a>data_type in measurements</a>
<li><a>history_type in measurements</a>
<li><a>units in measurements</a>
<li><a>match_value in measurements</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>10.1.1 <code>stream_type</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>pipe</code>
               <code>file</code>
</pre>
   <p><b>Synopsis</b>: The datatype being collected.

<p><b>Example</b>:<br>
<br>

<pre>
stream_type => "pipe";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>CFEngine treats all input using a stream abstraction. The preferred interface is files, since they can be read without incurring the cost of a process. However pipes from executed commands may also be invoked.

<div>
<a></a>
<a></a>

</div>

<h4>10.1.2 <code>data_type</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>counter</code>
               <code>int</code>
               <code>real</code>
               <code>string</code>
               <code>slist</code>
</pre>
   <p><b>Synopsis</b>: The datatype being collected.

<p><b>Example</b>:<br>
<br>

<pre>
  "/bin/df"

      handle => "free_disk_watch",
      stream_type => "pipe",

      data_type => "slist",

      history_type => "static",
      units => "device",
      match_value => file_systems,
      action => sample_min(10,15);


</pre>

<p><b>Notes</b>:<br>
<br>

   <p>When CFEngine (Nova) observes data, such as the attached partitions in the example above, the datatype determines how that data will be handled. Integer and real values, counters etc., are recorded as time-series if the history type is `weekly', or as single values otherwise. If multiple items are matched by an observation (e.g. several lines in a file match the given regular expression), then these can be made into a list by choosing <code>slist</code>, else the first matching item will be selected.

<div>
<a></a>
<a></a>

</div>

<h4>10.1.3 <code>history_type</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>weekly</code>
               <code>scalar</code>
               <code>static</code>
               <code>log</code>
</pre>
   <p><b>Synopsis</b>: Whether the data can be seen as a time-series or just an isolated value

<p><b>Example</b>:<br>
<br>

<pre>
 "/proc/meminfo"

      handle => "free_memory_watch",
      stream_type => "file",
      data_type => "int",
      history_type => "weekly",
      units => "kB",
      match_value => free_memory;

</pre>

<p><b>Notes</b>:<br>
<br>

     <dl>
<dt><samp><span>scalar</span></samp><dd>A single value, with compressed statistics is retained. The value of the data is not expected to change much for the lifetime of the daemon (and so will be sampled less often by <samp><span>cf-monitord</span></samp>).

     <br><dt><samp><span>static</span></samp><dd>A synonym for `scalar'.

     <br><dt><samp><span>log</span></samp><dd>The measured value is logged as an infinite time-series in <samp><span>$(sys.workdir)/state</span></samp>.

     <br><dt><samp><span>weekly</span></samp><dd>A standard CFEngine two-dimensional time average (over a weekly period) is retained. 
</dl>

<div>
<a></a>

</div>

<h4>10.1.4 <code>units</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: The engineering dimensions of this value or a note about its intent used in plots

<p><b>Example</b>:<br>
<br>

<pre>
   "/var/cfengine/state/cf_rootprocs"

      handle => "monitor_self_watch",
      stream_type => "file",
      data_type => "int",
      history_type => "weekly",
      units => "kB",
      match_value => proc_value(".*cf-monitord.*",
        
         "root\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+([0-9]+).*");

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This is an arbitary string used in documentation only.

<div>
<a></a>
<a></a>

</div>

<h4>10.1.5 <code>match_value</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>select_line_matching</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Regular expression for matching line location

     <p><b>Example</b>:<br>
<br>

     <pre>     
     # Editing
     
     body location example
     {
     select_line_matching => "Expression match.* whole line";
     }
     
     # Measurement promises
     
     body match_value example
     {
     select_line_matching => "Expression match.* whole line";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The expression is anchored, meaning it must match a whole line, and not a fragment within a line (see <a>Anchored vs. unanchored regular expressions</a>).

     <p>This attribute is mutually exclusive of <code>select_line_number</code>.

     <br><dt><samp><code>select_line_number</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Read from the n-th line of the output (fixed format)

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body match_value find_line
     {
     select_line_number => "2";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is mutually exclusive of <code>select_line_matching</code>.

     <br><dt><samp><code>extraction_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression that should contain a single backreference for extracting a value

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body match_value free_memory
     {
     select_line_matching => "MemFree:.*";
     extraction_regex => "MemFree:\s+([0-9]+).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A single parenthesized backreference should be given to lift the value to be measured out of the text stream. The regular expression is unanchored, meaning it may match a partial string (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>track_growing_file</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: If true, CFEngine remembers the position to which is last read when opening the file, and resets to the start if the file has since been truncated

     <p><b>Example</b>:<br>
<br>

     <pre>     bundle monitor watch
     {
     measurements:
     
        "/home/mark/tmp/file"
     
              handle => "line_counter",
         stream_type => "file",
           data_type => "counter",
         match_value => scan_log("MYLINE.*"),
        history_type => "log",
              action => sample_rate("0");
     
     }
     
     #
     
     body match_value scan_log(x)
     {
     select_line_matching => "^$(x)$";
     track_growing_file => "true";
     }
     
     #
     
     body action sample_rate(x)
     {
     ifelapsed => "$(x)";
     expireafter => "10";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This option applies only to file based input streams. If this is <samp><span>true</span></samp>, CFEngine treats the file as if it were a log file, growing continuously. Thus the monitor reads all new entries since the last sampling time on each invocation. In this way, the monitor does not count lines in the log file redundantly.

     <p>This makes a log pattern promise equivalent to something like <samp><span>tail -f logfile | grep pattern</span></samp> in Unix parlance.

     <br><dt><samp><code>select_multiline_policy</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>average</code>
                    <code>sum</code>
                    <code>first</code>
                    <code>last</code>
</pre>
     <p><b>Synopsis</b>: Regular expression for matching line location

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body match_value myvalue(xxx)
     {
      select_line_matching => ".*$(xxx).*";
      extraction_regex => "root\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\S+).*";
      select_multiline_policy => "sum";
     } 
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p><i>History</i>: Was introduced in 3.4.0 (2012)

     <p>This option governs how CFEngine handels multiple matching lines in the input stream. We can average or sum values if they are integer or real, or use first or last representative samples. If non-numerical data types are used on the the first match is used.

   </dl>
   


<div>
<a></a>

</div>


