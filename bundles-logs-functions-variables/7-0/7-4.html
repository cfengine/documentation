<h3>7.4 <code>files</code> promises in <samp><span>agent</span></samp></h3>

<p><br>

   <p>Files promises are an umbrella for attributes of files. Operations fall basically into three categories: create, delete and edit.

   <p><table><tr><td>
<pre>     
      files:
     
        "<var>/path/file_object</var>"
     
            perms = <var>perms_body</var>,
            ... ;
     
</pre>
   </td></tr></table>

   <p>Prior to version 3, file promises were scattered into many different types, including <code>files</code>, <code>tidy</code>, <code>copy</code>, and <code>links</code>. File handling in CFEngine 3 uses regular expressions everywhere for pattern matching. The old `wildcard/globbing' expressions <samp><span>*</span></samp> and
<samp><span>?</span></samp>  are deprecated, and everything is based consistently on Perl Compatible Regular Expressions.

   <p>There is a natural ordering in file processing that obviates the need for the actionsequence. For example, the trick of using multiple actionsequence items with different classes.

<pre> actionsequence = ( ... files.one  ..  files.two )
</pre>

   <p>can now be handled more elegantly using bundles. The natural ordering uses that fact that some operations are mutually exclusive and that some operations do not make sense in reverse order. For example, editing a file and then copying onto it would be nonsense. Similarly, you cannot both remove a file and rename it.

<p><b>File copying</b>

   <p>One of the first things users of CFEngine 2 will notice is that copying is now `backwards'. Instead of the default object being source and the option being the destination,
in CFEngine 3 the destination is paramount and the source is an option. This is because the model of voluntary cooperation tells us that it is the object that is changed, which is the agent making the promise. One cannot force change onto a destination with CFEngine, one can only invite change from a source.

<p><b>Normal ordering of promise attributes</b>

   <p>CFEngine 3 no longer has an `action sequence'. Ordering of operations has, in most cases, a natural ordering that is assumed by the agent. For example, `delete then create' (normal ordering) makes sense, but `create then delete' does not. This sort of principle can be extended to deal with all aspects of file promises.

   <p>The diagram below shows the ordering. Notice that the same ordering applies regardless of file type (plain-file or directory).  Note also that file editing is done "atomically".
   <p>See: `File editing in CFEngine 3'

   <div><img></div> 

   <p>The pseudo-code for this logic is shown in the diagram and below:

<pre> for each file promise-object
    {
    if (depth_search) 
      do 
        DepthSearch (HandleLeaf)
      else 
        (HandleLeaf)
      done
    }

 HandleLeaf()
   {
   Does leaf-file exist?

     NO:  create
     YES: rename,delete,touch, 

     do
      for all servers in {localhost, @(servers)}
         {
         if (server-will-provide)
            do
              if (depth_search)
                 embedded source-depth-search (use file source)
                 break
              else
                 (use file source)
                 break
              done
            done
         }
     done
      
   Do all links (always local)

   Check Permissions

   Do edits
   }

</pre>

<p><b>Depth searches (formerly known as 'recursion') during searches</b>

   <p>In CFEngine 2 there was the concept of recursion during file searches. Recursion is now called "depth-search". In addition, it was possible to specify wildcards in the base-path for this search. CFEngine 3 replaces the `globbing' symbols with standard regular expressions:

<pre>
      CFEngine 2               CFEngine 3

/one/*/two/thr*/four    /one/.*/two/thr.*/four

</pre>

   <p>Note: When searching for hidden files (files with names starting with a `.') or files with specific extensions, you should take care to
escape the dot (e.g., <code>\.cshrc</code> or <code>.*\.txt</code>) when you wish it to mean a literal character and not the any character interpretation provided
by regular expression interpretation. 

   <p>Note: When doing a recursive search, the files <samp><span>'.'</span></samp> and <samp><span>'..'</span></samp> are never included in the matched files, even if the regular expression in the <samp><span>leaf_name</span></samp> specifically allows them.

   <p>Note: The filename <samp><span>/dir/ect/ory/.</span></samp> is a special case used with the <samp><span>create</span></samp> attribute to indicate the directory named <samp><span>/dir/ect/ory</span></samp> and not any of the files under it.  If you really want to specify a regular expression that matches any single-character filename, use <samp><span>/dir/ect/ory/[\w\W]</span></samp> as your promise regular expression (you can't use <samp><span>/dir/ect/ory[^/]</span></samp>, see below for an explanation. 

   <p>Depth search refers to a search for file objects that starts from the one or more matched base-paths as shown in the example above.

<p><b>Filenames and regular expressions</b>

   <p>CFEngine allows regular expressions within filenames, but only after first doing some sanity checking to prevent some readily avoidable problems.  The biggest rule you need to know about filenames and regular expressions is that <i>all</i> regular expressions in filenames are bounded by directory separators, and that each component expression is anchored between the directory separators. In other words, CFEngine splits up any file paths into its component parts, and then it evaluates any regular expressions at a component-level.

   <p>See: <a>Anchored vs. unanchored regular expressions</a>. 

   <p>What this means is that the path <samp><span>/tmp/gar.*</span></samp> will only match filenames like <samp><span>/tmp/gar</span></samp>, <samp><span>/tmp/garbage</span></samp> and <samp><span>/tmp/garden</span></samp>.  It will <i>not</i> match filename like <samp><span>/tmp/gar/baz</span></samp>; because even though the <samp><span>.*</span></samp> in a regular expression means "zero or more of any character", CFEngine restricts that to mean "zero or more of any character <i>in a path component</i>".  

   <p>Correspondingly, CFEngine also restricts where you can use the <samp><span>/</span></samp> character. For example, you cannot use it in a character class like <samp><span>[^/]</span></samp> or in a parenthesized or repeated regular expression component.

   <p>This means that regular expressions that include "optional directory components" will not work.  You cannot have a files promise to tidy the directory <samp><span>(/usr)?/tmp</span></samp>.  Instead, you need to be more verbose and specify <samp><span>/usr/tmp|/tmp</span></samp>. Potentially more efficient would be a declarative approach. First, create an <i>slist</i> that contains both the strings <samp><span>/tmp</span></samp> and <samp><span>/usr/tmp</span></samp>; and then allow CFEngine to iterate over the list.

   <p>This also means that the path <samp><span>/tmp/.*/something</span></samp> will match files such as <samp><span>/tmp/abc/something</span></samp> or <samp><span>/tmp/xyzzy/something</span></samp>. However, even though the pattern <samp><span>.*</span></samp> means "zero or more of any character (except <samp><span>/</span></samp>)", CFEngine matches files bounded by directory separators.  So even though the pathname <samp><span>/tmp//something</span></samp> is technically the same as the pathname <samp><span>/tmp/something</span></samp>, the regular expression <samp><span>/tmp/.*/something</span></samp> will <i>not</i> match on the case of <samp><span>/tmp//something</span></samp> (or <samp><span>/tmp/something</span></samp>).

<p><b>Promises involving regular expressions</b>

   <p>CFEngine can only keep (or repair, or fail to keep) a promise on files which actually exist.  If you make a promise based on a wildcard match, then the promise is only ever attempted if the match succeeds. However, if you make a promise containing a recursive search that includes a wildcard match, then the promise can be kept or repaired, provided that the directory specified in the promise exists. Consider the following two examples, which assumethat there first exist files named <samp><span>/tmp/gar</span></samp>, <samp><span>/tmp/garbage</span></samp> and <samp><span>/tmp/garden</span></samp>. Initially, the two promises look like they should do the same thing; but there is a subtle difference:

<pre>bundle agent foobaz		    bundle agent foobaz
{				    {
files:				    files:
 "/tmp/gar.*"			     "/tmp"
    delete => tidy,		    	delete => tidy,
    classes => if_ok("done");	    	depth_search => recurse("0"),
				    	file_select => gars,
				    	classes => if_ok("done");
				    }

				    body file_select gars
				    {
					leaf_name => { "gar.*" };
					file_result => "leaf_name";
				    }

body classes if_ok(x)		    body classes if_ok(x)
{				    {
promise_repaired => { "$(x)" };	    promise_repaired => { "$(x)" };
promise_kept => { "$(x)" };	    promise_kept => { "$(x)" };
}				    }
</pre>

   <p>In the first example, when the configuration containing this promise is first executed, any file starting with "gar" that exists in the <samp><span>/tmp</span></samp> directory will be removed, and the <samp><span>done</span></samp> class will be set.  However, when the configuration is executed a second time, the pattern <samp><span>/tmp/gar.*</span></samp> will not match any files, and that promise will not even be <i>attempted</i> (and, consequently the <samp><span>done</span></samp> class will <i>not</i> be set).

   <p>In the second example, when the configuration containing this promise is first executed, any file starting with "gar" that exists in the <samp><span>/tmp</span></samp> directory will also be removed, and the <samp><span>done</span></samp> class will also be set. The second time the configuration is executed, however, the promise on the <samp><span>/tmp</span></samp> directory will still be executed (because <samp><span>/tmp</span></samp> of course still exists), and the <samp><span>done</span></samp> class <i>will</i> be set, because all files matching the <samp><span>file_select</span></samp> attribute have been deleted from that directory.

<p><b>Local and remote searches</b>

   <p>There are two distinct kinds of depth
search:

     <ul>
<li>A local search over promiser agents. 
<li>A remote search over provider agents. 
</ul>

   <p>When we are <i>copying</i> or <i>linking</i> to a file source, it is the search over the <i>remote</i> source that drives the content of a promise (the promise is a promise to use what the remote source provides). In general, the sources are on a different device to the images that make the promises.  For all other promises, we search over existing local
objects.

   <p>If we specify depth search together with copy of a directory, then the implied remote source search is assumed, and it is made after the search over local base-path objects has been made. If you mix complex promise body operations in a single promise, this could lead to confusion about the resulting behaviour, and a warning is issued. In general it is not recommended to mix searches without a full understanding of the consequences, but this might occasionally be useful.

   <p>Depth search is not allowed with <code>edit_line</code> promises.

<p><b>File editing in CFEngine 3</b>

   <p>CFEngine 2 assumed that all files were line-edited, because it was based on Unix traditions. Since then many new file formats have emerged, including XML. CFEngine 3 opens up the possibility for multiple models of file editing. Line based editing still exists, but is now more powerful and has been simplified compared with previous versions.

   <p>File editing is not just a single kind of promise but a whole range of `promises within files'. It is therefore not merely a body to a single kind of promise, but a bundle of sub-promises. After all, inside each file are new objects that can make promises, quite separate from files' external attributes.

   <p>A typical file editing stanza has the elements in the following example:

<pre>######################################################################
#
# File editing
#
######################################################################

body common control

{
version => "1.2.3";
bundlesequence  => { "outerbundle"  };
}

########################################################

bundle agent outerbundle

{
files:

  "/home/mark/tmp/cf3_test"

       create    => "true",     # Like autocreate in cf2
       edit_line => inner_bundle;
}

########################################################

bundle edit_line inner_bundle
  {
  vars:

   "who" string => "SysAdmin John";	# private variable in bundle

  insert_lines:
    "/* This file is maintained by CFEngine (see $(who) for details) */",
	location => first_line;
  
  replace_patterns:

   # replace shell comments with C comments

   "#(.*)"

      replace_with => C_comment,
     select_region => MySection("New section");

  reports:

    someclass::

      "This is file $(edit.filename)";
  }

########################################
# Bodies for the library ...
########################################

body replace_with C_comment

{
replace_value => "/* $(match.1) */"; # backreference
occurrences => "all";          # first, last all
}

########################################################

body select_region MySection(x)

{
select_start => "\[$(x)\]";
select_end => "\[.*\]";
}

########################################################

body location first_line

{
before_after => "before";
first_last => "first";
select_line_matching => ".*";
}


</pre>

<p>There are several things to notice:

     <ul>
<li>The line-editing promises are all convergent promises about patterns within the file. They have bodies, just like other attributes do and these allow us to make simple templates about file editing while extending the power of the basic primitives.

     <li>All file edits specified in a single <code>edit_line</code> bundle are handled "atomically". CFEngine edits files like this:
          <ul>
<li>CFEngine makes a copy of the file you you want to edit.
<li>CFEngine makes all the edits in the <b>copy</b> of the file.  The filename is the same as your original file with the extension <samp><span>.cf-after-edit</span></samp> appended. 
<li>After all edits are complete (the <code>delete_lines</code>, <code>field_edits</code>, <code>insert_lines</code>, and finally <code>replace_patterns</code> promises), CFEngine checks to see if the new file is the same as the original one.  If there are no differences, the promises have converged, so it deletes the copy, and the original is left completely unmodified. 
<li>If there are any differences, CFEngine makes a copy of your original file with the extension <samp><span>.cf-before-edit</span></samp> (so you always have the most recent backup available), and then renames the edited version to your original filename. 
</ul>
     Because file rename is an atomic operation (guaranteed by the operating system), any application program will either see the old version of the file or the new one. There is no "window of opportunity" where a partially edited file can be seen (unless an application intentionally looks for the <samp><span>.cf-after-edit</span></samp> file).  Problems during editing (such as disk-full or permission errors) are likewise detected, and CFEngine will not rename a partial file over your original.

     <li>All pattern matching is through Perl Compatible Regular Expressions
<li>Editing takes place within a marked region (which defaults to the whole file if not otherwise specified). 
<li>Search/replace functions now allow back-references. 
<li>The line edit model now contains a field or column model for dealing with tabular files such as Unix <samp><span>passwd</span></samp> and <samp><span>group</span></samp> files. We can now apply powerful convergent editing operations to single fields inside a table, to append, order and delete items from lists inside fields.

     <li>The special variable <code>$(edit.filename)</code> contains the name of the file being edited within an edit bundle. 
</ul>

<p>In the example above, back references are used to allow conversion of comments from shell-style to C-style.

   <p>Another example of files promises is to look for changes in files.  The following example reports on all recent changes to files in a directory by maintaining the most recent version of the <code>md5</code> hash of the file contents.  Similar checks can be used to examine metadata or both the contents and metadata, as well as using different difference checks.  The Community Edition only reports that changes were found, but Enterprise versions of CFEngine can also report on what exactly the significant changes were.

<pre>
bundle agent example
{
files:

  "/home/mark/tmp" -> "Security team"

       changes      => lay_a_tripwire,
       depth_search => recurse("inf"),
       action       => background;
}

#########################################################

body changes lay_a_tripwire

{
hash           => "md5";
report_changes => "content";
update         => "yes";
}

</pre>

   <p><br>

<ul>
<li><a>acl in files</a>
<li><a>changes in files</a>
<li><a>copy_from in files</a>
<li><a>create in files</a>
<li><a>delete in files</a>
<li><a>depth_search in files</a>
<li><a>edit_defaults in files</a>
<li><a>edit_line in files</a>
<li><a>edit_template in files</a>
<li><a>edit_xml in files</a>
<li><a>file_select in files</a>
<li><a>link_from in files</a>
<li><a>move_obstructions in files</a>
<li><a>pathtype in files</a>
<li><a>perms in files</a>
<li><a>rename in files</a>
<li><a>repository in files</a>
<li><a>touch in files</a>
<li><a>transformer in files</a>
</ul>

<div>
<a></a>

</div>

<h4>7.4.1 <code>acl</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>aces</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>((user|group):[^:]+:[-=+,rwx()dtTabBpcoD]*(:(allow|deny))?)|((all|mask):[-=+,rwx()]*(:(allow|deny))?)</code>

     <p><b>Synopsis</b>: Native settings for access control entry

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body acl template
     
     {
     acl_method => "overwrite";
     acl_type => "posix";
     acl_directory_inherit => "parent";
     
     aces => { 
             "user:*:r(wwx),-r:allow", 
             "group:*:+rw:allow", 
             "mask:x:allow", 
             "all:r"
             };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>POSIX ACL are available in CFEngine Community starting with 3.4.0. NTFS ACL are available with CFEngine Nova or above.  Form of the permissions is:

     <p><table><tr><td>
     <pre>                aces = {
                        "<var>user:uid:mode[:perm_type]</var>", ...,
                        "<var>group:gid:mode[:perm_type]</var>", ...,
                        "<var>all:mode[:perm_type]</var>"
                        };
</pre>
     </td></tr></table>

          <ul>
<li><code>user</code> indicates that the line applies to a user specified  by the user identifier <code>uid</code>. <code>mode</code> is the permission mode string.

          <li><code>group</code> indicates that the line applies to a group specified by the group identitfier <code>gid</code>. <code>mode</code> is the permission mode string.

          <li><code>all</code> indicates that the line applies to every user. <code>mode</code> is the permission mode string.

          <li><code>uid</code> is a valid user identifier for the system and cannot be empty. However, <code>uid</code> can be set to * as a synonym for the entity that owns the file system object (e.g. user:*:r).

          <li><code>gid</code> is a valid group identifier for the system and cannot be empty. However, in some ACL types, <code>gid</code> can be set to * to indicate a special group (e.g. in POSIX this refers to the file group).

          <li><code>mode</code> is one or more strings <code>op</code>|<code>perms</code>|(<code>nperms</code>); a concatenation of <code>op</code>, <code>perms</code> and optionally (<code>nperms</code>) separated with commas (e.g. +rx,-w(s) ). <code>mode</code> is parsed from left to right. 



          <li><code>op</code> specifies the operation on any existing permissions, if the defined ACE already exists. <code>op</code> can be =, empty, + or -. = or empty sets the permissions to the ACE as stated. + adds and - removes the permissions from any existing ACE. 
  

          <li><code>nperms</code> (optional) specifies file system specific (native) permissions. Only valid if <code>acl_type</code> is defined. <code>nperms</code> will only be enforced if the file object is stored on a file system supporting the ACL type set in <code>acl_type</code>. For example, <code>nperms</code> will be ignored if <code>acl_type:</code><code>ntfs</code> and the object is stored on a file system not supporting NTFS ACLs. Valid values for <code>nperms</code> varies with different ACL types, and is defined in subsequent sections.

          <li><code>perm_type</code> (optional) can be set to either <code>allow</code> or <code>deny</code>, and defaults to <code>allow</code>. <code>deny</code> is only valid
  if <code>acl_type</code> is set to an ACL type that support deny permissions. A <code>deny</code> ACE will only be enforced if the file object is stored on a file system supporting the acl type set in <code>acl_type</code>. 
</ul>

     <p><code>gperms</code> (generic permissions) is a concatenation of zero or more of the characters shown in the table below. If left empty, none of the permissions are set. 


     <p><table><tr><th>Flag </th><th>Description </th><th>Semantics on file </th><th>Semantics on directory

     <p><br></th></tr><tr><td><code>r</code> </td><td>Read </td><td>Read data, permissions, attributes </td><td>Read
directory contents, permissions, attributes
<br></td></tr><tr><td><code>w</code> </td><td>Write </td><td>Write data </td><td>Create, delete, rename subobjects
<br></td></tr><tr><td><code>x</code> </td><td>Execute </td><td>Execute file </td><td>Access subobjects
     <br></td></tr></table>

     <p>Note that the <code>r</code> permission is not necessary to read an object's permissions and attributes in all file systems. For example, in POSIX, having <code>x</code> on its containing directory is sufficient.

     <br><dt><samp><code>acl_directory_inherit</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>nochange</code>
                    <code>parent</code>
                    <code>specify</code>
                    <code>clear</code>
</pre>
     <p><b>Synopsis</b>: Access control list type for the affected file system

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body acl template
     
     {
     acl_method => "overwrite";
     acl_type => "posix";
     acl_directory_inherit => "parent";
     
     aces => {
             "user:*:rwx:allow",
             "group:*:+rw:allow",
             "mask:rx:allow",
             "all:r"
             };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Directories have ACLs associated with them, but they also have the ability to inherit an ACL to sub-objects created within them. POSIX calls the former ACL type "access ACL" and the latter "default ACL", and we will use the same terminology.

     <p>The constraint <code>acl_directory_inherit</code> gives control over the default ACL of directories. The default ACL can be left unchanged (<code>nochange</code>), empty (<code>clear</code>), or be explicitly specified (<code>specify</code>). In addition, the default ACL can be set equal to the directory's access ACL (<code>parent</code>). This has the effect that child objects of the directory gets the same access ACL as the directory.

     <br><dt><samp><code>acl_method</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>append</code>
                    <code>overwrite</code>
</pre>
     <p><b>Synopsis</b>: Editing method for access control list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body acl template
     
     {
     acl_method => "overwrite";
     acl_type => "posix";
     aces => { "user:*:rw:allow", "group:*:+r:allow", "all:"};
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>When defining an ACL, we can either use an existing ACL as the starting point, or state all entries of the ACL. If we just care about one entry, say that the superuser has full access, the <code>method</code> constraint can be set to <code>append</code>, which is the default. This has the effect that all the existing ACL entries that are not mentioned
will be left unchanged. On the other hand, if <code>method</code> is set to <code>overwrite</code>, the resulting ACL will only contain the mentioned entries. When doing this, it is important to check that all the required ACL entries are set. For example, owning user, group and all in POSIX ACLs.

     <br><dt><samp><code>acl_type</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>generic</code>
                    <code>posix</code>
                    <code>ntfs</code>
</pre>
     <p><b>Synopsis</b>: Access control list type for the affected file system

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body acl template
     
     {
     acl_type => "ntfs";
     aces => { "user:Administrator:rwx(po)", "user:Auditor:r(o)"};
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>ACLs are supported on multiple platforms, which may have different sets of available permission flags. By using the constraint <code>acl_type</code>, we can specify which platform, or ACL API, we are targeting with the ACL. The default, <code>generic</code>, is designed to work on all supported platforms. However, if very specific permission
flags are required, like Take Ownership on the NTFS platform, we must set <code>acl_type</code> to indicate the target platform. Currently, the supported values are <code>posix</code> and <code>ntfs</code>.

     <br><dt><samp><code>specify_inherit_aces</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>((user|group):[^:]+:[-=+,rwx()dtTabBpcoD]*(:(allow|deny))?)|((all|mask):[-=+,rwx()]*(:(allow|deny))?)</code>

     <p><b>Synopsis</b>: Native settings for access control entry

     <p><b>Example</b>:<br>
<br>

     <pre>     body acl template
     {
     specify_inherit_aces => {  "all:r" };
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p><code>specify_inherit_aces</code> (optional) is a list of access control entries that are set on child objects. It is also parsed from left to right and allows multiple entries with same entity-type and id. Only valid if <code>acl_directory_inherit</code> is set to <code>specify</code>.

     <p>This is an ACL which makes explicit setting for the acl inherited by new objects within a directory. It is included for those implementations that do not have a clear inheritance policy.

   </dl>

<div>
<a></a>

</div>

<h4>7.4.2 <code>changes</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>hash</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>md5</code>
                    <code>sha1</code>
                    <code>sha224</code>
                    <code>sha256</code>
                    <code>sha384</code>
                    <code>sha512</code>
                    <code>best</code>
</pre>
     <p><b>Synopsis</b>: Hash files for change detection

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body changes example
     {
     hash => "md5";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The <code>best</code> option cross correlates the best two available algorithms known in the OpenSSL library.

     <br><dt><samp><code>report_changes</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>all</code>
                    <code>stats</code>
                    <code>content</code>
                    <code>none</code>
</pre>
     <p><b>Synopsis</b>: Specify criteria for change warnings

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body changes example
     {
     report_changes => "content";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Files can change in permissions and contents, i.e. external or internal attributes. If <samp><span>all</span></samp> is chosen all attributes are checked.

     <br><dt><samp><code>update_hashes</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: Update hash values immediately after change warning

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body changes example
     {
     update_hashes => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If this is positive, file hashes should be updated as soon as a change is registered so that multiple warnings are not given about a single change. This applies to addition and removal too.

     <br><dt><samp><code>report_diffs</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: Generate reports summarizing the major differences between individual text files

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body changes example
     {
     report_diffs => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p><i>This feature is available only in enterprise levels Nova and above.</i>

     <p>If true, CFEngine will log a `diff' summary of major changes to the files.  It is not permitted to combine this promise with a depth search, since this would consume a dangerous amount of resources and would lead to unreadable reports.

     <p>The feature is intended as a informational summary, not as a version control function suitable for transaction control. If you want to do versioning on system files, you should keep a single repository for them and use CFEngine to synchronize changes from the repository source. Repositories should not be used to attempt to capture random
changes of the system.

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.4.3 <code>copy_from</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>source</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Reference source file from which to copy

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     source => "/path/to/source";
     }
     
     # or
     
     body link_from example
     {
     source => "/path/to/source";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>For remote copies this refers to the file name on the remote server.

     <br><dt><samp><code>servers</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[A-Za-z0-9_.:-]+</code>

     <p><b>Synopsis</b>: List of servers in order of preference from which to copy

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     servers => { "primary.example.org", "secondary.example.org", 
                      "tertiary.other.domain" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The servers are tried in order until one of them succeeds.

     <br><dt><samp><code>collapse_destination_dir</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: Place files in subdirectories into the root destination directory during copy

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from mycopy(from,server)
     
     {
     source      => "$(from)";
     servers     => { "$(server)" };
     collapse_destination_dir => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Under normal operations, recursive copies cause CFEngine to track subdirectories of files. So, for instance, if we copy recursively from <samp><span>src</span></samp> to <samp><span>dest</span></samp>, then <samp><span>src/subdir/file</span></samp> will map to <samp><span>dest/subdir/file</span></samp>.

     <p>By setting this option to <samp><span>true</span></samp>, the promiser destination directory promises to aggregate files searched from all subdirectories into itself; in other words, a single destination directory.

     <br><dt><samp><code>compare</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>atime</code>
                    <code>mtime</code>
                    <code>ctime</code>
                    <code>digest</code>
                    <code>hash</code>
                    <code>exists</code>
                    <code>binary</code>
</pre>
     <p><b>Synopsis</b>: Menu option policy for comparing source and image file attributes

     <p><b>Default value:</b> mtime or ctime differs

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     
     {
     compare => "digest";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The default copy method is <samp><span>mtime</span></samp> (modification time), meaning that the source file is copied to the destination (promiser) file, if the source file has been modified more recently than the destination.

     <p>The different options are:
          <ul>
<li><code>mtime</code> CFEngine copies the file if the modification time of the source file is more recent than that of the promised file

          <li><code>ctime</code> CFEngine copies the file if the creation time of the source file is more recent than that of the promised file

          <li><code>atime</code> CFEngine copies the file if the modification time or creation time of the source file is more recent than that of the promised file.  If the times are equal, a byte-for-bye comparison is done on the files to determine if it needs to be copied.

          <li><code>exists</code> CFEngine copies the file if the promised file does not already
exist.

          <li><code>binary</code> CFEngine copies the file if they are both plain files and a byte-for-byte comparison determines that they are different.  If both are not plain files, CFEngine reverts to comparing the <code>mtime</code> and <code>ctime</code> of the files. If the source file is on a different machine (e.g. network copy), then <code>hash</code> is used instead to reduce network bandwidth.

          <li><code>hash</code> CFEngine copies the file if they are both plain files and a message digest comparison indicates that the files are different. In Enterprise versions of CFEngine version 3.1.0 and later, SHA256 is used as a message digest hash to conform with FIPS; in older Enterprise versions of CFEngine and all Community versions, MD5 is used.

          <li><code>digest</code> a synonym for <code>hash</code>

     </ul>

     <br><dt><samp><code>copy_backup</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>timestamp</code>
</pre>
     <p><b>Synopsis</b>: Menu option policy for file backup/version control

     <p><b>Default value:</b> true

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     copy_backup => "timestamp";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Determines whether a backup of the previous version is kept on the system. This should be viewed in connection with the system repository, since a defined repository affects the location at which the backup is stored.  
     <p>See: <a>default_repository</a> and <a>repository</a> for further details.

     <br><dt><samp><code>encrypt</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false use encrypted data stream to connect to remote host

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     servers  => { "remote-host.example.org" };
     encrypt => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Client connections are encrypted with using a Blowfish randomly generated session key. The initial connection is encrypted using the public/private keys for the client and server hosts.

     <br><dt><samp><code>check_root</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false check permissions on the root directory when depth_search

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     check_root => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>When copying files recursively (by depth search), this flag determines whether the permissions of the root directory should be set from the root of the source. The default is to check only copied file objects and subdirectories within this root (false).

     <br><dt><samp><code>copylink_patterns</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of patterns matching files that should be copied instead of linked

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     copylink_patterns => { "special_node1", "other_node.*" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The matches are performed on the last node of the filename; in other words, the file without its path. As Windows does not support symbolic links, this feature is not available there.

     <br><dt><samp><code>copy_size</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,inf</code>

     <p><b>Synopsis</b>: Integer range of file sizes that may be copied

     <p><b>Default value:</b> any size range

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     copy_size => irange("0","50000");
     } 
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The use of the irange function is optional. Ranges may also be specified as a comma separated numbers.

     <br><dt><samp><code>findertype</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>MacOSX</code>
</pre>
     <p><b>Synopsis</b>: Menu option for default finder type on MacOSX

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     findertype => "MacOSX";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This applies only to the Mac OS X variants.

     <br><dt><samp><code>linkcopy_patterns</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of patterns matching files that should be replaced with symbolic links

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from mycopy(from)
     
     {
     source            => "$(from)";
     linkcopy_patterns => { ".*" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The pattern matches the last node filename; in other words, without the absolute path. Windows only supports hard links.
     <p>See: <code>link_type</code>.

     <br><dt><samp><code>link_type</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>symlink</code>
                    <code>hardlink</code>
                    <code>relative</code>
                    <code>absolute</code>
</pre>
     <p><b>Synopsis</b>: Menu option for type of links to use when copying

     <p><b>Default value:</b> symlink

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body link_from example
     {
     link_type => "symlink";
     source => "/tmp/source";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Users are advised to be wary of `hard links' (see Unix manual pages for the <samp><span>ln</span></samp> command). The behaviour of non-symbolic links is often precarious and unpredictable. However, hard links are the only supported type by Windows.

     <p>Note that <samp><span>symlink</span></samp> is synonymous with <samp><span>absolute</span></samp> links, which are different from <samp><span>relative</span></samp> links. Although all of these are symbolic links, the nomenclature here is defined such that <samp><span>symlink</span></samp> and <samp><span>absolute</span></samp> are equivalent . When verifying a link, choosing `relative' means that the link <i>must</i> be relative to the source, so relative and absolute links are mutually exclusive.

     <br><dt><samp><code>force_update</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false force copy update always

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     force_update => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Warning: this is a non-convergent operation. Although the end point might stabilize in content, the operation will never quiesce. Use of this feature is not recommended except in exceptional circumstances since it creates a busy-dependency. If the copy is a network copy, the system will be disturbed by network disruptions.

     <br><dt><samp><code>force_ipv4</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false force use of ipv4 on ipv6 enabled network

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     force_ipv4 => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>IPv6 should be harmless to most users unless you have a partially or mis-configured setup.

     <br><dt><samp><code>portnumber</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>1024,99999</code>

     <p><b>Synopsis</b>: Port number to connect to on server host

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     portnumber => "5308";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The standard or registered port number is tcp/5308. CFEngine does not presently use its registered udp port with the same number, but this could change in the future.

     <br><dt><samp><code>preserve</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false whether to preserve file permissions on copied file

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     preserve => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Ensures the destination file (promiser) gets the same Unix mode as the source. This also applies to remote copies.

     <p><i>History</i>: Was introduced in version 3.1.0b3,Nova 2.0.0b1 (2010)

     <br><dt><samp><code>purge</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false purge files on client that do not match files on server when a depth_search is used

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     purge => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Purging files is a potentially dangerous matter during a file copy it implies that any promiser (destination) file which is not matched by a source will be deleted. Since there is no source, this means the file will be irretrievable. Great care should be exercised when using this feature.

     <p>Note that purging will also delete backup files generated during the file copying if <code>copy_backup</code> is set to true.

     <br><dt><samp><code>stealth</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false whether to preserve time stamps on copied file

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     stealth => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Preserves file access and modification times on the promiser files.

     <br><dt><samp><code>timeout</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>1,3600</code>

     <p><b>Synopsis</b>: Connection timeout, seconds

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body runagent control
     {
     timeout => "10";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Timeout in seconds.

     <br><dt><samp><code>trustkey</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false trust public keys from remote server if previously unknown

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     trustkey => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If the server's public key has not already been trusted, trustkey provides automated key-exchange.

     <p>Note that, as a simple security precaution, trustkey should normally be set to <samp><span>false</span></samp>. Even though the risks to the client low, it is a good security practice to avoid key exchange with a server one is not one hundred percent sure about. On the server-side however, trust is often granted to many clients or to a whole network in which possibly unauthorized parties might be able to obtain an IP address. Thus the trust issue is most important on the server side.

     <p>As soon as a public key has been exchanged, the trust option has no effect. A machine that has been trusted remains trusted until its key is manually revoked by a system administrator. Keys are stored in <samp><span>WORKDIR/ppkeys</span></samp>.

     <br><dt><samp><code>type_check</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false compare file types before copying and require match

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     type_check => "false";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>File types at source and destination should normally match in order for updates to overwrite them. This option allows this checking to be switched off.

     <br><dt><samp><code>verify</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false verify transferred file by hashing after copy (resource penalty)

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     verify => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is a highly resource intensive option, not recommended for large file transfers.

   </dl>

<div>
<a></a>

</div>

<h4>7.4.4 <code>create</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>true</code>
               <code>false</code>
               <code>yes</code>
               <code>no</code>
               <code>on</code>
               <code>off</code>
</pre>
   <p><b>Default value:</b> false

<p><b>Synopsis</b>: true/false whether to create non-existing file

<p><b>Example</b>:<br>
<br>

<pre>
files:

  "/path/plain_file"

     create =>   "true";

  "/path/dir/."
  
     create =>   "true";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Directories are created by using the <samp><span>/.</span></samp> to signify a directory type.  Note that, if no permissions are specified, mode 600 is chosen for a file, and mode 755 is chosen for a directory. If you cannot accept these defaults, you <i>should</i> specify permissions.

   <p>Note that technically, <samp><span>/.</span></samp> is a regular expression.  However, it is used as a special case meaning "directory".  See <b>filenames and regular expressions</b> near the beginning of the section on <a>files promises</a> for a more complete discussion.

   <p><b>Note:</b> In general, you should not use <code>create</code> with <a>copy_from</a> or <a>link_from</a> in files promises. These latter attributes automatically create the promised file, and using <code>create</code> may actually prevent the copy or link promise from being kept (since <code>create</code> acts first, which may affect file comparison or linking operations).

<div>
<a></a>

</div>

<h4>7.4.5 <code>delete</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>dirlinks</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>delete</code>
                    <code>tidy</code>
                    <code>keep</code>
</pre>
     <p><b>Synopsis</b>: Menu option policy for dealing with symbolic links to directories during deletion

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete example
     {
     dirlinks => "keep";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Links to directories are normally removed just like any other link or file objects. By keeping directory links, you preserve the logical directory structure of the file system, so that a link to a directory is not removed but is treated as a directory to be descended into.

     <p>The value <code>keep</code> instructs CFEngine not to remove directory links. The values <code>delete</code> and <code>tidy</code> are synonymous, and instruct CFEngine to remove directory links.

     <p><b>Default value</b> (only if body is present):<br>
<br>

     <p>The default value only has significance if there is a <code>delete</code> body present. If there is no <code>delete</code> body then files (and directory links) are <b>not</b> deleted.

     <p><code>dirlinks = delete</code>

     <br><dt><samp><code>rmdirs</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false whether to delete empty directories during recursive deletion

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete example
     {
     rmdirs => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Note the parent directory of a search is not deleted in recursive deletions. In CFEngine 2 there was an option to delete the parent of the search. In CFEngine 3 you must code a separate promise to delete the single parent object.

     <pre>     
     bundle agent cleanup
     {
     files:
     
       # This will not delete the parent
     
       "/home/mark/tmp/testcopy" 
     
         delete => tidyfiles,
         file_select => changed_within_1_year,
         depth_search => recurse("inf");
     
       # Now delete the parent.
     
       "/home/mark/tmp/testcopy" 
         delete => tidyfiles;
     }
     
     body delete tidyfiles
     {
     dirlinks => "delete";
     rmdirs   => "true";
     }
     
     body file_select changed_within_1_year
     {
     mtime     => irange(ago(1,0,0,0,0,0),now);
     file_result => "mtime";
     }
     
</pre>

     <p><b>Default value</b> (only if body is present):<br>
<br>

     <p>The default value only has significance if there is a <code>delete</code> body present. If there is no <code>delete</code> body then files (and directories) are <b>not</b> deleted.

     <p><code>rmdirs = true</code>

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.4.6 <code>depth_search</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>depth</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Maximum depth level for search

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body depth_search example
     {
     depth => "inf";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This was previously called `recurse' in earlier versions of CFEngine. Note that the value <samp><span>inf</span></samp> may be used for an unlimited value.

     <p>When searching recursively from a directory, the parent directory is only the anchor point and is not part of the search. To alter the parent, a separate non-recursive promise should be made.

     <br><dt><samp><code>exclude_dirs</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: List of regexes of directory names NOT to include in depth search

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body depth_search
     {
     # no dot directories
     exclude_dirs => { "\..*" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Directory names are treated specially when searching recursively through a file system.

     <br><dt><samp><code>include_basedir</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false include the start/root dir of the search results

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body depth_search example
     {
     include_basedir => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>When checking files recursively (with <code>depth_search</code>) the promiser is a directory. This parameter determines whether that initial directory should be considered part of the promise or simply a boundary that marks the edge of the search. If true, the promiser directory will also promise the same attributes as the files inside it.

     <br><dt><samp><code>include_dirs</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: List of regexes of directory names to include in depth search

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body depth_search example
     {
     include_dirs => { "subdir1", "subdir2", "pattern.*" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is the complement of <code>exclude_dirs</code>.

     <br><dt><samp><code>rmdeadlinks</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false remove links that point to nowhere

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body depth_search example
     {
     rmdeadlinks => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A value of true determines that links pointing to files that do not exist should be deleted; or kept if set to false.

     <br><dt><samp><code>traverse_links</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false traverse symbolic links to directories

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body depth_search example
     {
     traverse_links => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If this is true, <code>cf-agent</code> will treat symbolic links to directories as if they were directories. Normally this is considered a potentially dangerous assumption and links are not traversed.

     <br><dt><samp><code>xdev</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false exclude directories that are on different devices

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body depth_search example
     {
     xdev => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.4.7 <code>edit_defaults</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>edit_backup</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>timestamp</code>
                    <code>rotate</code>
</pre>
     <p><b>Synopsis</b>: Menu option for backup policy on edit changes

     <p><b>Default value:</b> true

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_defaults example
     {
     edit_backup => "timestamp";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>empty_file_before_editing</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: Baseline memory model of file to zero/empty before commencing promised edits

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_defaults example
     {
     empty_file_before_editing => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Emptying a file before reconstructing its contents according to a fixed recipe allows an ordered procedure to be convergent.

     <br><dt><samp><code>inherit</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: If true this causes the sub-bundle to inherit the private classes of its parent

     <p><b>Example</b>:<br>
<br>

     <pre>     bundle agent name
     {
     methods:
     
       "group name" usebundle => my_method,
                      inherit => "true";
     }
     
     
     body edit_defaults example
     {
     inherit => "true";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p><i>History</i>: Was introduced in 3.4.0, Enterprise 3.0.0 (2012)

     <p><b>Default value</b>: false

     <p>The <code>inherit</code> constraint can be added to the CFEngine code in two places: for <code>edit_defaults</code> and in <code>methods</code> promises. If set to true, it causes the child-bundle named in the promise to inherit only the classes of the parent bundle. Inheriting the variables is unnecessary as the child can always access the parent's variables by a qualified reference using its bundle name. For example, <samp><span>$(bundle.variable)</span></samp>.

     <br><dt><samp><code>max_file_size</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Do not edit files bigger than this number of bytes

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_defaults example
     {
     max_file_size => "50K";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>max_file_size is a local, per-file sanity check to make sure the file editing is sensible. If this is set to zero, the check is disabled and any size may be edited. The default value of <code>max_file_size</code> is determined by the global control body setting whose default value is <code>100k</code>.
     
     <p>See: <a>editfilesize in agent</a>

     <br><dt><samp><code>recognize_join</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: Join together lines that end with a backslash, up to 4kB limit

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     files:
     
       "/tmp/test_insert"
                 create => "true",
              edit_line => Insert("$(insert.v)"),
          edit_defaults => join;
     }
     
     #
     
     body edit_defaults join
     {
     recognize_join => "true";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If set to true, this option allows CFEngine to process line based files with backslash continuation. The default is to not process continuation backslashes.

     <p>Back slash lines will only be concatenated if the file requires editing, and will not be restored. Restoration of the backslashes is not possible in a meaningful and convergent fashion.

     <br><dt><samp><code>rotate</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99</code>

     <p><b>Synopsis</b>: How many backups to store if 'rotate' edit_backup strategy is selected. Defaults to 1

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body rename example
     {
     rotate => "4";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Used for log rotation. If the file is named <samp><span>foo</span></samp> and the <samp><span>rotate</span></samp> attribute is set to <samp><span>4</span></samp>, as above, then initially <samp><span>foo</span></samp> is copied to <samp><span>foo.1</span></samp> and the old file <samp><span>foo</span></samp> is zeroed out. In other words, the inode of the original logfile does not change, but the original logfile will be empty after the rotation is complete.

     <p>The next time the promise is executed, <samp><span>foo.1</span></samp> will be renamed <samp><span>foo.2</span></samp>, <samp><span>foo</span></samp> is again copied to <samp><span>foo.1</span></samp> and the old file <samp><span>foo</span></samp> is again zeroed out.

     <p> A promise may typically be executed as guarded by time-based or file-size-based classes. Each time the promise is executed the files are copied/zeroed or rotated (as above) until there are <samp><span>rotate</span></samp> numbered files, plus the one "main" file. In the example above, the file <samp><span>foo.3</span></samp> will be renamed <samp><span>foo.4</span></samp>, but the old version of the file <samp><span>foo.4</span></samp> will be deleted (that is, it "falls off the end" of the rotation).

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.4.8 <code>edit_line</code></h4>

<p><b>Type</b>: (ext bundle) (Separate Bundle)

<div>
<a></a>
<a></a>

</div>

<h4>7.4.9 <code>edit_template</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: <code>"?(/.*)</code>

<p><b>Synopsis</b>: The name of a special CFEngine template file to expand

<p><b>Example</b>:<br>
<br>

<pre>#This is a template file /templates/input.tmpl

These lines apply to anyone

[%CFEngine solaris.Monday:: %]
Everything after here applies only to solaris on Mondays
until overridden...

[%CFEngine linux:: %]
Everything after here now applies now to linux only.

[%CFEngine BEGIN %]
This is a block of text
That contains list variables: $(some.list)
With text before and after.
[%CFEngine END %]

nameserver $(some.list)
</pre>

   <p>For example:

<pre>[%CFEngine any:: %]
VirtualHost $(sys.ipv4[eth0]):80>
        ServerAdmin             $(stage_file.params[apache_mail_address][1])
        DocumentRoot            /var/www/htdocs
        ServerName              $(stage_file.params[apache_server_name][1])
        AddHandler              cgi-script cgi
        ErrorLog                /var/log/httpd/error.log
        AddType                 application/x-x509-ca-cert .crt
        AddType                 application/x-pkcs7-crl    .crl
        SSLEngine               off
        CustomLog               /var/log/httpd/access.log
/VirtualHost>

[%CFEngine webservers_prod:: %]
[%CFEngine BEGIN %]
VirtualHost $(sys.ipv4[$(bundle.interfaces)]):443>                                               
        ServerAdmin             $(stage_file.params[apache_mail_address][1]) 
        DocumentRoot            /var/www/htdocs                                  
        ServerName              $(stage_file.params[apache_server_name][1])            
        AddHandler              cgi-script cgi                                 
        ErrorLog                /var/log/httpd/error.log                  
        AddType                 application/x-x509-ca-cert .crt                
        AddType                 application/x-pkcs7-crl    .crl                
        SSLEngine               on                                             
        SSLCertificateFile      $(stage_file.params[apache_ssl_crt][1])
        SSLCertificateKeyFile   $(stage_file.params[apache_ssl_key][1])
        CustomLog               /var/log/httpd/access.log                      
/VirtualHost>
[%CFEngine END %]
</pre>

<p><b>Notes</b>:<br>
<br>

   <p><i>History</i>: Was introduced in 3.3.0, Nova 2.2.0 (2012)

   <p>The template format uses inline tags to mark regions and classes. Each line represents an <code>insert_lines</code> promise, unless the promises are grouped into a block using:

<pre>[%CFEngine BEGIN %]
...
[%CFEngine END %]
</pre>

<p>Variables, scalars and list variables are expanded within each promise. If lines are grouped into a block, the whole block is repeated when lists are expanded (see the Special Topics Guide on editing).

   <p>If a class-context modified is used:

<pre>[%CFEngine class-expression:: %]
</pre>
then the lines that follow are only inserted if the context matches the agent's current context. This allows conditional insertion.

<div>
<a></a>
<a></a>

</div>

<h4>7.4.10 <code>edit_xml</code></h4>

<p><b>Type</b>: (ext bundle) (Separate Bundle)

<div>
<a></a>
<a></a>

</div>

<h4>7.4.11 <code>file_select</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>leaf_name</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of regexes that match an acceptable name

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     leaf_name => { "S[0-9]+[a-zA-Z]+", "K[0-9]+[a-zA-Z]+" };
     file_result => "leaf_name";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This pattern matches only the node name of the file, not its path.

     <br><dt><samp><code>path_name</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>"?(/.*)</code>

     <p><b>Synopsis</b>: List of pathnames to match acceptable target

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     leaf_name => { "prog.pid", "prog.log" };
     path_name => { "/etc/.*", "/var/run/.*" };
     
     file_result => "leaf_name.path_name"
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Path name and leaf name can be conveniently tested for separately by use of appropriate regular expressions. 

     <br><dt><samp><code>search_mode</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[0-7augorwxst,+-]+</code>

     <p><b>Synopsis</b>: A list of mode masks for acceptable file permissions

     <p><b>Example</b>:<br>
<br>

     <pre>     
     #######################################################
     #
     # Searching for permissions
     #
     #######################################################
     
     body common control
        {
        any::
     
           bundlesequence  => { 
                              "testbundle"
                              };
     
        version => "1.2.3";
        }
     
     ############################################
     
     bundle agent testbundle
     
     {
     files:
     
       "/home/mark/tmp/testcopy" 
     
         file_select => by_modes,
         transformer => "/bin/echo DETECTED $(this.promiser)",
         depth_search => recurse("inf");
     
     }
     
     ############################################
     
     body file_select by_modes
     
     {
     search_mode => { "711" , "666" };
     file_result => "mode";
     }
     
     ############################################
     
     body depth_search recurse(d)
     
     {
     depth => "$(d)";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The mode may be specified in symbolic or numerical form with <samp><span>+</span></samp> and <samp><span>-</span></samp> constraints. Concatenation <code>ug+s</code> implies <code>u</code> OR <code>g</code>,  and <code>u+g,u+s</code> implies <code>u</code> AND <code>g</code>.

     <br><dt><samp><code>search_size</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,inf</code>

     <p><b>Synopsis</b>: Integer range of file sizes

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     search_size => irange("0","20k");
     file_result => "size";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>search_owners</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of acceptable user names or ids for the file, or regexes to match

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     search_owners => { "mark", "jeang", "student_.*" };
     file_result => "owner";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A list of regular expressions any of which must match the entire userid (see <a>Anchored vs. unanchored regular expressions</a>). Windows does not have user ids, only names.

     <br><dt><samp><code>search_groups</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of acceptable group names or ids for the file, or regexes to match

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     search_groups => { "users", "special_.*" };
     file_result => "group";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A list of regular expressions, any of which must match the entire group (see <a>Anchored vs. unanchored regular expressions</a>). On Windows, files do not have group associations.

     <br><dt><samp><code>search_bsdflags</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[+-]*[(arch|archived|nodump|opaque|sappnd|sappend|schg|schange|simmutable|sunlnk|sunlink|uappnd|uappend|uchg|uchange|uimmutable|uunlnk|uunlink)]+</code>

     <p><b>Synopsis</b>: String of flags for bsd file system flags expected set

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select xyz
     {
     search_bsdflags => "archived|dump";
     file_result => "bsdflags";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Extra BSD file system flags (these have no effect on non-BSD versions of CFEngine).  See the manual page for <code>chflags</code> for more details.

     <br><dt><samp><code>ctime</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,2147483647</code>

     <p><b>Synopsis</b>: Range of change times (ctime) for acceptable files

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body files_select example
     {
     ctime => irange(ago(1,0,0,0,0,0),now);
     file_result => "ctime";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The file's change time refers to both modification of content and attributes, such as permissions. On Windows, <code>ctime</code> refers to creation time.

     <br><dt><samp><code>mtime</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,2147483647</code>

     <p><b>Synopsis</b>: Range of modification times (mtime) for acceptable files

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body files_select example
     
     {
     # Files modified more than one year ago (i.e., not in mtime range)
     mtime => irange(ago(1,0,0,0,0,0),now);
     file_result => "!mtime";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The file's modification time refers to both modification of content but not other attributes, such as permissions.

     <br><dt><samp><code>atime</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,2147483647</code>

     <p><b>Synopsis</b>: Range of access times (atime) for acceptable files

     <p><b>Example</b>:<br>
<br>

     <pre>     body file_select used_recently
     {
     
     # files accessed within the last hour
     atime     => irange(ago(0,0,0,1,0,0),now);
     file_result => "atime";
     }
     
     
     body file_select not_used_much
     
     {
     # files not accessed since 00:00 1st Jan 2000 (in the local timezime)
     atime     => irange(on(2000,1,1,0,0,0),now);
     file_result => "!atime";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A range of times during which a file was accessed can be specified in a <code>file_select</code> body. This is similar to file filters in CFEngine 2.

     <br><dt><samp><code>exec_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Matches file if this regular expression matches any full line returned by the command

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     exec_regex => "SPECIAL_LINE: .*";
     exec_program => "/path/test_program $(this.promiser)";
     file_result => "exec_program.exec_regex";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The regular expression must be used in conjunction with the <code>exec_program</code> test. In this way the program must both return exit status 0 and its output must match the regular expression.  The entire output must be matched (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>exec_program</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>"?(/.*)</code>

     <p><b>Synopsis</b>: Execute this command on each file and match if the exit status is zero

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     exec_program => "/path/test_program $(this.promiser)";
     file_result => "exec_program";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is part of the customizable file search criteria. If the user-defined program returns exit status 0, the file is considered matched.

     <br><dt><samp><code>file_types</code></samp><dd><b>Type</b>: (option list)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>plain</code>
                    <code>reg</code>
                    <code>symlink</code>
                    <code>dir</code>
                    <code>socket</code>
                    <code>fifo</code>
                    <code>door</code>
                    <code>char</code>
                    <code>block</code>
</pre>
     <p><b>Synopsis</b>: List of acceptable file types from menu choices

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select filter
     {
     file_types => { "plain","symlink" };
     
     file_result => "file_types";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>File types vary in details between operating systems. The main POSIX types are provided here as menu options, with <samp><span>reg</span></samp> being a synonym for <samp><span>plain</span></samp>. In both cases this means not one of the "special" file types.

     <br><dt><samp><code>issymlinkto</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of regular expressions to match file objects

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select example
     {
     issymlinkto => { "/etc/[^/]*", "/etc/init\.d/[a-z0-9]*" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A list of regular expressions. If the file is a symbolic link that points to files matched by one of these expressions, the file will be selected. Windows does not support symbolic links, so this attribute is not applicable on that platform.

     <br><dt><samp><code>file_result</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>[!*(leaf_name|path_name|file_types|mode|size|owner|group|atime|ctime|mtime|issymlinkto|exec_regex|exec_program|bsdflags)[|.]*]*</code>

     <p><b>Synopsis</b>: Logical expression combining classes defined by file search criteria

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body file_select year_or_less
     
     {
     mtime       => irange(ago(1,0,0,0,0,0),now);  
     file_result => "mtime"; 
     }
     
     body file_select my_pdf_files_morethan1dayold
     
     {
     mtime         => irange(ago(0,0,1,0,0,0),now);  
     leaf_name     => { ".*\.pdf" , ".*\.fdf" };
     search_owners => { "mark" };
     
     file_result => "owner.leaf_name.!mtime";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Sets the criteria for file selection outcome during file searches. The syntax is the same as for a class expression, since the file selection is a classification of the file-search in the same way that system classes are a classification of the abstract host-search. That is, you may specify a boolean expression involving any of the file-matching components. In this way, you may specify arbitrarily complex file-matching parameters, such as what is shown above, "is owned by mark, has the extension '.pdf' or '.fdf', and whose modification time is not between 1 day ago and now"; that is, it is older than 1 day.

     <p>Items in the boolean expression in <code>file_result</code> must be from the following list:

          <ul>
<li>leaf_name
<li>path_name
<li>file_types
<li>mode
<li>size
<li>owner
<li>group
<li>atime
<li>ctime
<li>mtime
<li>issymlinkto
<li>exec_regex
<li>exec_program
<li>bsdflags
</ul>

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.4.12 <code>link_from</code> (body template)</h4>

<p><b>Type</b>: (ext body)

<dl>
<dt><samp><code>copy_patterns</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: A set of patterns that should be copied and synchronized instead of linked

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body link_from example
     {
     copy_patterns =>  { "special_node1", "/path/special_node2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>During the linking of files, it is sometimes useful to buffer changes with an actual copy, especially if the link is to an ephemeral file system. This list of patterns matches files that arise during a linking policy. A positive match means that the file should be copied and updated by modification time.

     <br><dt><samp><code>link_children</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false whether to link all directory's children to source originals

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body link_from example
     {
     link_children => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If the promiser is a directory, instead of copying the children, link them to the source.

     <br><dt><samp><code>link_type</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>symlink</code>
                    <code>hardlink</code>
                    <code>relative</code>
                    <code>absolute</code>
</pre>
     <p><b>Synopsis</b>: The type of link used to alias the file

     <p><b>Default value:</b> symlink

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body link_from example
     {
     link_type => "symlink";
     source => "/tmp/source";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This determines what kind of link should be used to link files. Users are advised to be wary of `hard links' (see Unix manual pages for the <samp><span>ln</span></samp> command). The behaviour of non-symbolic links is often precarious and unpredictable. However, hard links are the only supported type by Windows.

     <p>Note that <samp><span>symlink</span></samp> is synonymous with <samp><span>absolute</span></samp> links, which are different from <samp><span>relative</span></samp> links. Although all of these are symbolic links, the nomenclature here is defined such that <samp><span>symlink</span></samp> and <samp><span>absolute</span></samp> are equivalent . When verifying a link, choosing `relative' means that the link <i>must</i> be relative to the source, so relative and absolute links are mutually exclusive.

     <br><dt><samp><code>source</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: The source file to which the link should point

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body copy_from example
     {
     source => "/path/to/source";
     }
     
     # or
     
     body link_from example
     {
     source => "/path/to/source";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>For remote copies this refers to the file name on the remote server.

     <br><dt><samp><code>when_linking_children</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>override_file</code>
                    <code>if_no_such_file</code>
</pre>
     <p><b>Synopsis</b>: Policy for overriding existing files when linking directories of children

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body link_from example
     {
     when_linking_children => "if_no_such_file";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The options refer to what happens if the directory already exists, and is already partially populated with files. If the directory being copied from contains a file with the same name as that of a link to be created, it must be decided whether to override the existing destination object with a link, or simply omit the automatic linkage for files that already exist. The latter case can be used to make a copy of one directory with certain fields overridden.

     <br><dt><samp><code>when_no_source</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>force</code>
                    <code>delete</code>
                    <code>nop</code>
</pre>
     <p><b>Synopsis</b>: Behaviour when the source file to link to does not exist

     <p><b>Default value:</b> nop

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body link_from example
     {
     when_no_source => "force";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This describes how CFEngine should respond to an attempt to create a link to a file that does not exist. The options are to force the creation to a file that does not (yet) exist, delete any existing link, or do nothing.

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.4.13 <code>move_obstructions</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>true</code>
               <code>false</code>
               <code>yes</code>
               <code>no</code>
               <code>on</code>
               <code>off</code>
</pre>
   <p><b>Default value:</b> false

<p><b>Synopsis</b>: true/false whether to move obstructions to file-object creation

<p><b>Example</b>:<br>
<br>

<pre>
files:

  "/tmp/testcopy" 

    copy_from    => mycopy("/tmp/source"),
    move_obstructions => "true",
    depth_search => recurse("inf");

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>If we have promised to make file <samp><span>X</span></samp> a link, but it already exists as a file, or vice-versa, or if a file is blocking the creation of a directory, then normally CFEngine will report an error. If this is set, existing objects will be moved aside to allow the system to heal without intervention. Files and directories are saved/renamed, but symbolic links are deleted.

   <p>Note that symbolic links for directories are treated as directories, not links. This behaviour can be discussed, but the aim is to err on the side of caution.  

   <p>Some operating systems (Solaris) use symbolic links in path names. Copying to a directory could then result in renaming of the important link, if the behaviour is different.

<div>
<a></a>

</div>

<h4>7.4.14 <code>pathtype</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>literal</code>
               <code>regex</code>
               <code>guess</code>
</pre>
   <p><b>Synopsis</b>: Menu option for interpreting promiser file object

<p><b>Example</b>:<br>
<br>

<pre>
files:

   "/var/lib\d"
      pathtype => "guess", 	# best guess (default)
         perms => system;

   "/var/lib\d"
      pathtype => "regex",	# force regex interpretation
         perms => system;

   "/var/.*/lib"

      pathtype => "literal", 	# force literal interpretation
         perms => system;

</pre>

<p><b>Notes</b>:<br>
<br>
By default, CFEngine makes an educated guess as to whether the promise pathname involves a regular expression or not.  This guesswork is needed due to cross-platform differences in filename interpretation.

   <p>If CFEngine guesses (or is told) that the pathname uses a regular expression pattern, it will undertake a file search to find possible matches. This can consume significant resources, and so the <samp><span>guess</span></samp> option will always try to optimize this. Guesswork is, however, imperfect, so you have the option to declare your intention.

   <p>If the keyword <code>literal</code> is invoked, a path will be treated as a literal string regardless of what characters it contains. If it is declared <samp><span>regex</span></samp>, it will be treated as a pattern to match.

   <p>Note that CFEngine splits the promiser up into path links before matching, so that each link in the path chain is matched separately. Thus it it meaningless to have a <samp><span>/</span></samp> in a regular expression, as the comparison will never see this character.

   <p>In the examples above, at least one case implies an iteration over all files/directories matching the regular expression, while the last case means a single literal object with a name composed of dots and stars.

   <p>On Windows paths using <code>regex</code> must use the forward slash (<code>/</code>) as path separator, since the backward slash has a special meaning in a regular expression. Literal paths may also use backslash (<code>\</code>) as a path separator. 
   
   <p>See <a>Regular expressions in paths</a>, for more information.

<div>
<a></a>

</div>

<h4>7.4.15 <code>perms</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>bsdflags</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[+-]*[(arch|archived|nodump|opaque|sappnd|sappend|schg|schange|simmutable|sunlnk|sunlink|uappnd|uappend|uchg|uchange|uimmutable|uunlnk|uunlink)]+</code>

     <p><b>Synopsis</b>: List of menu options for BSD file system flags to set

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body perms example
     
     {
     bsdflags => { "uappnd","uchg","uunlnk","nodump",
                   "opaque","sappnd","schg","sunlnk" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The BSD Unices (FreeBSD, OpenBSD, NetBSD) and MacOSX have additional file system flags which can be set. Refer to the BSD <code>chflags</code> documentation for this.

     <br><dt><samp><code>groups</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$.-]+</code>

     <p><b>Synopsis</b>: List of acceptable groups of group ids, first is change target

     <p><b>Example</b>:<br>
<br>

     <pre>     body perms example
     {
     groups => { "users", "administrators" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The first named group in the list is the default that will be configured if the file does not match an element of the list. The reserved word <samp><span>none</span></samp> may be used to match files that are not owned by a registered group. On Windows, files do not have file groups associated with them, and thus this attribute is ignored.

     <p>ACLs may be used in place for this.

     <br><dt><samp><code>mode</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>[0-7augorwxst,+-]+</code>

     <p><b>Synopsis</b>: File permissions (like posix chmod)

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body perms example
     {
     mode => "a+rx,o+w";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The mode string may be symbolic or numerical, like <code>chmod</code>. This is ignored on Windows, as the permission model uses ACLs. ACLs are
supported by CFEngine Nova.

     <br><dt><samp><code>owners</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$.-]+</code>

     <p><b>Synopsis</b>: List of acceptable owners or user ids, first is change target

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body perms example
     {
     owners => { "mark", "wwwrun", "jeang" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The first user is the reference value that CFEngine will set the file to if none of the list items matches the true state of the file. The reserved word <samp><span>none</span></samp> may be used to match files that are not owned by a registered user.

     <p>On Windows, users can only take ownership of files, never give it. Thus, the first user in the list should be the user running the CFEngine process (usually Administrator). Additionally, some groups may be owners on Windows (such as the Administrators group).

     <br><dt><samp><code>rxdirs</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false add execute flag for directories if read flag is set

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body perms rxdirs
     {
     rxdirs => "false";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Default behaviour is to set the <samp><span>x</span></samp> flag on directories automatically if the <samp><span>r</span></samp> flag is specified when specifying multiple files in a single promise. This is ignored on Windows, as the permission model uses ACLs.

   </dl>

<div>
<a></a>

</div>

<h4>7.4.16 <code>rename</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>disable</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false automatically rename and remove permissions

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body rename example
     {
     disable => "true"; 
     disable_suffix => ".nuked";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Disabling a file means making it unusable. For executables this means preventing execution, for an information file it means making the file unreadable.

     <br><dt><samp><code>disable_mode</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>[0-7augorwxst,+-]+</code>

     <p><b>Synopsis</b>: The permissions to set when a file is disabled

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body rename example
     {
     disable_mode => "0600"; 
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>To disable an executable it is not enough to rename it, you should also remove the executable flag.

     <br><dt><samp><code>disable_suffix</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: The suffix to add to files when disabling (.cfdisabled)

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body rename example
     {
     disable => "true"; 
     disable_suffix => ".nuked";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>To disable files in a particular manner, use this string suffix. The default value is <samp><span>.cf-disabled</span></samp>.

     <br><dt><samp><code>newname</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: The desired name for the current file

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body rename example(s)
     {
     newname => "$(s)";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>rotate</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99</code>

     <p><b>Synopsis</b>: Maximum number of file rotations to keep

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body rename example
     {
     rotate => "4";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Used for log rotation. If the file is named <samp><span>foo</span></samp> and the <samp><span>rotate</span></samp> attribute is set to <samp><span>4</span></samp>, as above, then initially <samp><span>foo</span></samp> is copied to <samp><span>foo.1</span></samp> and the old file <samp><span>foo</span></samp> is zeroed out (that is, the inode of the original logfile does not change, but the original log file will be empty after the rotation is complete).

     <p>The next time the promise is executed, <samp><span>foo.1</span></samp> will be renamed <samp><span>foo.2</span></samp>, <samp><span>foo</span></samp> is again copied to <samp><span>foo.1</span></samp> and the old file <samp><span>foo</span></samp> is again zeroed out.

     <p>Each time the promise is executed (and typically, the promise would be executed as guarded by time-based or file-size-based classes), the files are copied/zeroed or rotated as above until there are <samp><span>rotate</span></samp> numbered files plus the one "main" file.  In the example above, the file <samp><span>foo.3</span></samp> will be renamed <samp><span>foo.4</span></samp>, but the old version of the file <samp><span>foo.4</span></samp> will be deleted (that is, it "falls off the end" of the rotation).

   </dl>

<div>
<a></a>

</div>

<h4>7.4.17 <code>repository</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: <code>"?(/.*)</code>

<p><b>Synopsis</b>: Name of a repository for versioning

<p><b>Example</b>:<br>
<br>

<pre>
files:

 "/path/file"

   copy_from => source,
   repository => "/var/cfengine/repository";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>A local repository for this object, overrides the default.
   <p>See <a>default_repository</a>

   <p>Note that when a repository is specified, the files are stored using the canonified directory name of the original file, concatenated with the name of the file.  So, for example, <samp><span>/usr/local/etc/postfix.conf</span></samp> would ordinarily be stored in an alternative repository as <samp><span>_usr_local_etc_postfix.conf.cfsaved</span></samp>.

<div>
<a></a>

</div>

<h4>7.4.18 <code>touch</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>true</code>
               <code>false</code>
               <code>yes</code>
               <code>no</code>
               <code>on</code>
               <code>off</code>
</pre>
   <p><b>Synopsis</b>: true/false whether to touch time stamps on file

<p><b>Example</b>:<br>
<br>

<pre>
files:

 "/path/file"

   touch => "true";

</pre>

<p><b>Notes</b>:<br>
<br>

<div>
<a></a>

</div>

<h4>7.4.19 <code>transformer</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: <code>"?(/.*)</code>

<p><b>Synopsis</b>: Command (with full path) used to transform current file (no shell wrapper used)

<p><b>Example</b>:<br>
<br>

<pre>
files:
  "/home/mark/tmp/testcopy"

    file_select => pdf_files,
    transformer => "/usr/bin/gzip $(this.promiser)",
    depth_search => recurse("inf");

</pre>

<pre>
 classes:
    "do_update" expression => isnewerthan("/etc/postfix/alias",
                                          "/etc/postfix/alias.cdb");

 files:
    "/etc/postfix/alias.cdb"
       create => "true",		# Must have this!
       transformer => "/usr/sbin/postalias /etc/postfix/alias",
       ifvarclass => "do_update";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>A command to execute, usually for the promised file to transform it to something else (but possibly to create the promised file based on a different origin file). The examples above show both types of promises.

   <p>The promiser file must exist in order to effect the transformer.

   <p>In the first example, the promise is made on the file that we wish to transform. If the promised file exists, the transformer will change the
file to a compressed version (and the next time CFEngine runs, the promised file will no longer exist, because it now has the <samp><span>.gz</span></samp> extension).

   <p>In the second example, the promise is made on the file <i>resulting from</i> the transformation (and the promise is conditional on the original file being newer than the result file). In this case, we <i>must</i> specify <samp><span>create = true</span></samp>. If we do not, then if the promised file is removed the transformer will not be executed.

   <p>Note also that if you use the <code>$(this.promiser)</code> variable or other variable in this command, and the file object contains spaces, then you should quote the variable. For example:

<pre>    transformer => "/usr/bin/gzip \"$(this.promiser)\"",
</pre>

   <p>Note also that the transformer does not actually need to change the file. You can, for example, simply report on the existence of files with:

<pre>    transformer => "/bin/echo I found a file named $(this.promiser)",
</pre>

   <p>The file streams <code>stdout</code> and <code>stderr</code> are redirected by CFEngine, and will not appear in any output unless you run <code>cf-agent</code> with the <samp><span>-v</span></samp> switch (or enable <code>verbose</code> in an <code>outputs</code> promise).

   <p>It is possible to set classes based on the return code of a transformer-command in a very flexible way. See the <code>kept_returncodes</code>, <code>repaired_returncodes</code> and <code>failed_returncodes</code> attributes.

   <p>Finally, you should note that the command is not run in a shell. This means that you cannot perform file redirection or create pipelines.

<div>
<a></a>
<a></a>

</div>


