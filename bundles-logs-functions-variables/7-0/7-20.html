<h3>7.20 <code>methods</code> promises in <samp><span>agent</span></samp></h3>

<p><br>

   <p>Methods are compound promises that refer to whole bundles of promises. Methods may be parameterized. Methods promises are written in a form that is ready for future development. The promiser object is an abstract identifier that refers to a collection (or pattern) of lower level objects that are affected by the promise-bundle. Since the use of these identifiers is for the future, you can simply use any string here for the time being.

   <p><table><tr><td>
<pre>     
      methods:
     
        "any"
     
           usebundle = <var>method_id</var>("parameter",...);
     
</pre>
   </td></tr></table>

   <p>Methods are useful for encapsulating repeatedly used configuration issues and iterating over parameters.

   <p>In CFEngine 2 methods referred to separate sub-programs executed as separate processes. Methods are now implemented as bundles that are run inline.

   <p><br>

<pre>

bundle agent example
{
vars:

 "userlist" slist => { "mark", "jeang", "jonhenrik", "thomas", "eben" };

methods:

 "any" usebundle => subtest("$(userlist)");

}

###########################################

bundle agent subtest(user)

{
commands:

 "/bin/echo Fix $(user)";

reports:

 linux::

  "Finished doing stuff for $(user)";
}


</pre>

   <p><br>

   <p>Methods offer powerful ways to encapsulate multiple issues pertaining to a set of parameters.

   <p>Because a method is just an encapsulation, there is a subtlety about how to interpret a successful method invocation. Before version 3.1.0, a method was considered repaired if executed (similar to <code>commands</code>). However, this led to unnecessary logging of executions, even if not actual encapsulated promise was kept.  In version 3.1.0 this has been changed so that a method promise is considered kept if the method is expanded. A method promise is thus never considered repaired.

   <p>Starting from version 3.1.0, methods may be specified using variables. Care should be exercised when using this approach. In order to make the function call uniquely classified, CFEngine requires the promiser to contain the variable name of the method if the variable is a list.

<pre>bundle agent default
{
vars:
    "m" slist  => { "x", "y" };
    "p" string => "myfunction";

methods:
    "set of $(m)" usebundle => $(m) ("one");
    "any"         usebundle => $(p)("two");
    
}
</pre>

<ul>
<li><a>inherit in methods</a>
<li><a>usebundle in methods</a>
<li><a>useresult in methods</a>
</ul>

<div>
<a></a>

</div>

<h4>7.20.1 <code>inherit</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>true</code>
               <code>false</code>
               <code>yes</code>
               <code>no</code>
               <code>on</code>
               <code>off</code>
</pre>
   <p><b>Synopsis</b>: If true this causes the sub-bundle to inherit the private classes of its parent
   
   <p><b>Default value</b>: false

<p><b>Example</b>:<br>
<br>

<pre>bundle agent name
{
methods:

  "group name" usebundle => my_method,
                 inherit => "true";
}


body edit_defaults example
{
inherit => "true";
}
</pre>

<p><b>Notes</b>:<br>
<br>

   <p><i>History</i>: Was introduced in 3.4.0, Enterprise 3.0.0 (2012)

   <p>The <code>inherit</code> constraint can be added to the CFEngine code in two places; for <code>edit_defaults</code> and in <code>methods</code> promises. If set to true, it causes the child-bundle named in the promise to inherit only the classes of the parent bundle. Inheriting the variables is unnecessary as the child can always access the parent's variables by a qualified reference using its bundle name. For example: <samp><span>$(bundle.variable)</span></samp>.

<div>
<a></a>

</div>

<h4>7.20.2 <code>usebundle</code></h4>

<p><b>Type</b>: (ext bundle) (Separate Bundle)

<div>
<a></a>

</div>

<h4>7.20.3 <code>useresult</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

<p><b>Synopsis</b>: Specify the name of a local variable to contain any result/return value from the child

<p><b>Example</b>:<br>
<br>

<pre>
body common control
{
bundlesequence => { "test" };
}


bundle agent test
{
methods:

   "any" usebundle => child,
    useresult => "my_return_var";


reports:

  cfengine_3::

    "My return was: \"$(my_return_var[1])\" and \"$(my_return_var[2])\""; 
    
}

bundle agent child
{
reports:

 cfengine_3::

   # Map these indices into the useresult namespace

   "this is a return value"  
      bundle_return_value_index => "1";

   "this is another return value"  
      bundle_return_value_index => "2";

}
</pre>

<p><b>Notes</b>:<br>
<br>

   <p><i>History</i>: Was introduced in 3.4.0 (2012)

   <p>Return values are limited to scalars.

<div>
<a></a>

</div>


