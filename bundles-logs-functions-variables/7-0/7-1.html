<h3>7.1 <code>commands</code> promises in <samp><span>agent</span></samp></h3>

<p><br>

   <p><table><tr><td>
<pre>     
     commands:
     
       <var>"/path/to/command args"</var>
     
                  args = "<var>more args</var>",
                  contain = <var>contain_body</var>,
                  module = <var>true/false</var>;
     
</pre>
   </td></tr></table>

   <p>Command <i>containment</i> allows you to make a `sandbox' around a command, to run it as a non-privileged user inside an isolated directory tree. CFEngine <code>modules</code> are commands that support a simple protocol (see below) in order to set additional variables and classes on execution from user defined code. Modules are intended for use as system probes rather than additional configuration promises.

   <p>In CFEngine 3 commands and processes have been separated cleanly. Restarting of processes must be coded as a separate command. This stricter type separation will allow more careful conflict analysis to be carried out.

   <p>Output from commands executed here is quoted inline, but prefixed with the letter <samp><span>Q</span></samp> to distinguish it from other output; for example, from <code>reports</code>, which is prefixed with the letter <samp><span>R</span></samp>.

   <p>It is possible to set classes based on the return code of a commands-promise in a very flexible way. See the <code>kept_returncodes</code>, <code>repaired_returncodes</code> and <code>failed_returncodes</code> attributes.

   <p><br>

<pre>
bundle agent example

{
commands:

  "/bin/sleep 10"
     action  => background;

  "/bin/sleep"
     args => "20",
     action  => background;

}

</pre>

   <p><br>

   <p>When referring to executables whose paths contain spaces, you should quote the entire program string separately so that CFEngine knows the name of the executable file. For example:

<pre>     
      commands:
     
       windows::
     
        "\"c:\Program Files\my name with space\" arg1 arg2";
     
       linux::
     
        "\"/usr/bin/funny command name\" -a -b -c";
     
</pre>
   <ul>
<li><a>args in commands</a>
<li><a>contain in commands</a>
<li><a>module in commands</a>
</ul>

<div>
<a></a>

</div>

<h4>7.1.1 <code>args</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: Alternative string of arguments for the command (concatenated with promiser string)

<p><b>Example</b>:<br>
<br>

<pre>
commands:

  "/bin/echo one"

   args => "two three";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Sometimes it is convenient to separate the arguments to a command from the command itself. The final arguments are the concatenation with one space. So in the example above the command would be:

<pre>
 /bin/echo one two three

</pre>

<div>
<a></a>

</div>

<h4>7.1.2 <code>contain</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>useshell</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false embed the command in a shell environment

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     {
     useshell => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The default is to <i>not</i> use a shell when executing commands.  Use of a shell has both resource and security consequences. A shell consumes an extra process and inherits environment variables, reads commands from files and performs other actions beyond the control of CFEngine. If one does not need shell functionality such as piping through multiple commands then it is best to manage without it. In the Windows version of CFEngine Nova, the command is run in the the Command Prompt if useshell is true.

     <br><dt><samp><code>umask</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>0</code>
                    <code>77</code>
                    <code>22</code>
                    <code>27</code>
                    <code>72</code>
                    <code>077</code>
                    <code>022</code>
                    <code>027</code>
                    <code>072</code>
</pre>
     <p><b>Synopsis</b>: The umask value for the child process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     {
     umask => "077";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Sets the internal umask for the process. Default value for the mask is <samp><span>077</span></samp>. On Windows, umask is not supported and is thus ignored by Windows versions of CFEngine.

     <br><dt><samp><code>exec_owner</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: The user name or id under which to run the process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     {
     exec_owner => "mysql_user";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is part of the restriction of privilege for child processes when running <code>cf-agent</code> as the root user, or a user with privileges.

     <p>Windows requires the clear text password for the user account to run under. Keeping this in CFEngine policies could be a security hazard. Therefore, this option is not yet implemented on Windows versions of CFEngine.

     <br><dt><samp><code>exec_group</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: The group name or id under which to run the process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     {
     exec_group => "nogroup";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is part of the restriction of privilege for child processes when running <code>cf-agent</code> as the root group, or a group with privileges. It is ignored on Windows, as processes do not have any groups associated with them.

     <br><dt><samp><code>exec_timeout</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>1,3600</code>

     <p><b>Synopsis</b>: Timeout in seconds for command completion

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     {
     exec_timeout => "30";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Attempt to time-out after this number of seconds. This cannot be guaranteed as not all commands are willing to be interrupted in case of failure.

     <br><dt><samp><code>chdir</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>"?(/.*)</code>

     <p><b>Synopsis</b>: Directory for setting current/base directory for the process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     
     {
     chdir => "/containment/directory";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This command has the effect of placing the running command into a current working directory equal to the parameter given; in other words, it works like the <samp><span>cd</span></samp> shell command.

     <br><dt><samp><code>chroot</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>"?(/.*)</code>

     <p><b>Synopsis</b>: Directory of root sandbox for process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     
     {
     chroot => "/private/path";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Sets the path of the directory that will be experienced as the top-most root directory for the process. In security parlance, this creates a `sandbox' for the process. Windows does not support this feature.

     <br><dt><samp><code>preview</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false preview command when running in dry-run mode (with -n)

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     {
     preview => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Previewing shell scripts during a dry-run is a potentially misleading activity. It should only be used on scripts that make no changes to the system. It is CFEngine best practice to never write change-functionality into user-written scripts except as a last resort. CFEngine can apply its safety checks to user defined scripts.

     <br><dt><samp><code>no_output</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false discard all output from the command

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body contain example
     {
     no_output => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is equivalent to piping standard output and error to <samp><span>/dev/null</span></samp>.

   </dl>

<div>
<a></a>

</div>

<h4>7.1.3 <code>module</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>true</code>
               <code>false</code>
               <code>yes</code>
               <code>no</code>
               <code>on</code>
               <code>off</code>
</pre>
   <p><b>Default value:</b> false

<p><b>Synopsis</b>: true/false whether to expect the cfengine module protocol

<p><b>Example</b>:<br>
<br>

<pre>
commands:

   "/masterfiles/user_script"

     module => "true";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>If true, the module protocol is supported for this script. In other words, it is treated as a user module. A plug-in module may be written in any
language, it can return any output you like, but lines which begin with a <samp><span>+</span></samp> sign are treated as classes to be defined (like <samp><span>-D</span></samp>), while lines which begin with a <samp><span>-</span></samp> sign are treated as classes to be undefined (like <samp><span>-N</span></samp>). 

   <p>Lines starting with <samp><span>=</span></samp> are scalar variables to be defined, and lines beginning with <samp><span>@</span></samp> are lists.  Any other lines of output are cited by <code>cf-agent</code> as being erroneous, so you should normally make your module completely silent. Here is an example written in shell:

<pre>     #!/bin/sh
     /bin/echo "@mylist= { \"one\", \"two\", \"three\" }"
     /bin/echo "=myscalar= scalar val"
     /bin/echo "+module_class"
</pre>
   <p>And here is an example using it:
<pre>body common control
   {
   any::

      bundlesequence  => { 
                         def,
                         modtest
                         };
   }

###################################################################

bundle agent def

{
commands:

  "$(sys.workdir)/modules/module_name" module => "true";

reports:

  #
  # Each module forms a private context with its name as id
  #

 module_class::

  "Module set variable $(module_name.myscalar)";

}

###################################################################

bundle agent modtest

{
vars:

 "mylist" slist => { @(module_name.mylist) };

reports:

 module_class::

  "Module set variable $(mylist)";

}

</pre>

   <p>Here is an example module written in Perl:

<pre>     #!/usr/bin/perl
     #
     # module:myplugin
     #
     
       # lots of computation....
     
     if (<var>special-condition</var>)
        {
        print "+specialclass";
        }
     
</pre>
   <p>If your module is simple and is best expressed as a shell command, then we suggest that you <i>expose</i> the class being defined in the command being executed (making it easier to see what classes are used when reading the promises file). For example, the promises could read as follows (the two <code>echo</code> commands are to ensure that the shell always exits with a successful execution of a command):

<pre>bundle agent sendmail
{
commands:
    # This next module checks a specific failure mode of dcc, namely
    # more than 3 error states since the last time we ran cf-agent
    is_mailhost::
        "/bin/test `/usr/bin/tail -100 /var/log/maillog | /usr/bin/grep 'Milter (dcc): to error state' | /usr/bin/wc -l` -gt 3  echo '+start_dccm' || echo
''"
            contain => shell_command,
            module => "true";

    start_dccm::
        "/var/dcc/libexec/start-dccm"
            contain => not_paranoid;
}

body contain shell_command
{
    useshell    => "yes";
}

body contain not_paranoid
{
    useshell    => "no";
    exec_owner  => "root";
    umask       => "22";
}

</pre>

   <p>Modules inherit the environment variables from cfagent and accept arguments, just as a regular command does.

<pre>     #!/bin/sh
     #
     # module:myplugin
     #
     
     /bin/echo $*
     
</pre>
   <p>Modules define variables in <code>cf-agent</code> by outputting strings of the form

<pre>     
     =<var>variablename</var>=<var>value</var>
     
</pre>
   <p>These variables end up in a context that has the same name as the module. When the <code>$(allclasses)</code> variable becomes too large to manipulate conveniently, you can access the complete list of currently defined classes in the file <samp><span>/var/cfengine/state/allclasses</span></samp>.

<div>
<a></a>

</div>


