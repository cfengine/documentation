<h3>7.22 <code>packages</code> promises in <samp><span>agent</span></samp></h3>

<p><br>

   <p><table><tr><td>
<pre>
 vars:

  "match_package" slist => { 
                           "apache2", 
                           "apache2-mod_php5",
                           "apache2-prefork",
                           "php5" 
                           };
 packages:

    "$(match_package)"

         package_policy => "add",
         package_method => yum;

</pre>
</td></tr></table>

   <p>CFEngine supports a generic approach to integration with native operating support for packaging. Package promises allow CFEngine to make promises regarding the state of software packages <i>conditionally</i>, given the assumption that a native package manager will perform the actual manipulations. Since no agent can make unconditional promises about another, this is the best that can be achieved.

   <p>Packages are treated as black-boxes with three labels:

     <ul>
<li>A package name 
<li>A version string 
<li>An architecture name
</ul>

   <p>Package managers are treated as black boxes that may support some or all of the following promise types:

     <ul>
<li>List installed packages
<li>Add packages
<li>Delete packages
<li>Reinstall (repair) packages
<li>Update packages
<li>Patch packages
<li>Verify packages
</ul>

   <p>If these services are promised by a package manager, <code>cf-agent</code> promises to use the service and encapsulate it within the overall CFEngine framework. It is possible to set classes based on the return code of a package-manager command in a very flexible way. See the <code>kept_returncodes</code>, <code>repaired_returncodes</code> and <code>failed_returncodes</code> attributes.

   <p><b>Domain knowledge</b>

   <p>CFEngine does not maintain operating system specific expert knowledge internally, rather it uses a generic model for dealing with promises about packages (which depend on the behaviour of an external package manager). The approach is to define package system details in body-constraints that can be written once and for all, for each package system.

   <p>Package promises are like <code>commands</code> promises in the sense that CFEngine promises nothing about the outcome of executing a command. All it can promise is to interface with it, starting it and using the results in good faith. Packages are basically `outsourced', to invoke IT parlance.


   <p><b>Behaviour</b>

   <p>A package promise consists of a name, a version and an architecture, <i>(n,v,a)</i>, and behaviour to be promised about packages that match criteria based on these. The components <i>(n,v,a)</i> can be determined in one of two different ways:

     <ul>
<li>They may be specified independently, e.g.

     <pre>     packages:
     
       "mypackage"
     
          package_policy => "add",
          package_method => rpm,
          package_select => ">=",
          package_architectures => { "x86_64", "i586" },
          package_version => "1.2.3";
     
</pre>

     <li>They may be extracted from a package identifier (promiser) or filename, using pattern matching. For example, a promiser 7-Zip-4.50-x86_64.msi and a package_method containing the following:

     <pre>      package_name_regex => "^(\S+)-(\d+\.?)+";
      package_version_regex => "^\S+-((\d+\.?)+)";
      package_arch_regex => "^\S+-[\d\.]+-(.*).msi";
</pre>

   </ul>

   <p>When scanning a list of installed packages different managers present the information <i>(n,v,a)</i> in quite different forms and pattern extraction is necessary. When making a promise about a specific package, the CFEngine user may choose one or the other model.

   <p><b>Smart and dumb package systems</b>

   <p>Package managers vary enormously in their capabilities and in the kinds of promises they make. There are broadly two types:

     <ul>
<li>Smart package systems that resolve dependencies and require only a symbolic package name. 
<li>Dumb package managers that do not resolve dependencies and need filename input. 
</ul>

   <p>Normal ordering for packages is the following:

     <ul>
<li>Delete
<li>Add
<li>Update
<li>Patch
</ul>

   <p><b>Promise repair logic</b>

   <p>We can discuss package promise repair in the following table:

   <p>Identified package matches version constraints
   <p><table><tr><td>  add
  </td><td>
  never
<br></td></tr><tr><td>  delete
  </td><td>
  =,=,=
<br></td></tr><tr><td>  reinstall
  </td><td>
  =,=,=
<br></td></tr><tr><td>  upgrade
  </td><td>
  =,=,=
<br></td></tr><tr><td>  patch
  </td><td>
  =,=,=
   <br></td></tr></table>

   <p>Identified package matched by name, but not version
   <p><table><tr><th>  Command
  </th><th>
  Dumb manager
  </th><th>
  Smart manager
<br></th></tr><tr><td>  add
  </td><td>
  unable
  </td><td>
  Never
<br></td></tr><tr><td>  delete
  </td><td>
  unable
  </td><td>
  Attempt deletion
<br></td></tr><tr><td>  reinstall
  </td><td>
  unable
  </td><td>
  Attempt delete/add
<br></td></tr><tr><td>  upgrade
  </td><td>
  unable
  </td><td>
  Upgrade if capable
<br></td></tr><tr><td>  patch
  </td><td>
  unable
  </td><td>
  Patch if capable
   <br></td></tr></table>

   <p>Package not installed
   <p><table><tr><th>  Command
  </th><th>
  Dumb manager
  </th><th>
  Smart manager
<br></th></tr><tr><td>  add
  </td><td>
  Attempt to install named
  </td><td>
  Install any version
<br></td></tr><tr><td>  delete
  </td><td>
  unable
  </td><td>
  unable
<br></td></tr><tr><td>  reinstall
  </td><td>
  Attempt to install named
  </td><td>
  unable
<br></td></tr><tr><td>  upgrade
  </td><td>
  unable
  </td><td>
  unable
<br></td></tr><tr><td>  patch
  </td><td>
  unable
  </td><td>
  unable
   <br></td></tr></table>

   <p><br>

<pre>
bundle agent packages
{
vars:

 # Test the simplest case -- leave everything to the yum smart manager

 "match_package" slist => { 
                          "apache2", 
                          "apache2-mod_php5",
                          "apache2-prefork",
                          "php5" 
                          };
packages:

  "$(match_package)"

     package_policy => "add",
     package_method => yum;

}

</pre>

   <p><br>

   <p>Packages promises can be very simple if the package manager is of the smart variety that handles details for you. If you need to specify architecture and version numbers of packages, this adds some complexity, but the options are flexible and designed for maximal adaptability.

<p><b>Patching</b>

   <p>Some package systems also support the idea of `patches'. These might be formally different objects to packages. A patch might contain material for several packages and be numbered differently. When you select patching-policy the package name (promiser) can be a regular expression that will match possible patch names, otherwise identifying specific patches can be cumbersome.

   <p>Note that patching is a subtle business. There is no simple way using the patch settings to install `all new system patches'. 

   <p>If we specify the name of a patch, then CFEngine will try to see if it exists and/or is installed. If it exists in the pending list, it will be installed.  If it exists in the installed list it will not be installed. Now consider the pattern <samp><span>.*</span></samp>. This will match any installed package, so CFEngine will assume the relevant patch has been installed already. On the other hand, the pattern <samp><span>no match</span></samp> will not match an installed patch, but it will not match a named patch either.

   <p>Some systems provide a command to do this, which can be specified without specific patch arguments. If so, that command can be called periodically under <code>commands</code>. The main purposes of patching body items are:

     <ul>
<li>To install specific named patches in a controlled manner. 
<li>To generate reports of available and installed patches during
system reporting. 
</ul>

<p><b>Installers without package/patch arguments</b>

   <p>CFEngine supports the syntax <samp><span>$</span></samp> at the end of a command to mean that no package name arguments should be used or appended after the dollar sign. This is because some commands require a list of packages, while others require an empty list. The default behaviour is to try to append the name of one or more packages to the command, depending on whether the policy is for individual or bulk installation.

<p><b>Default package method</b>

   <p>As of core 3.3.0, if no <code>package_method</code> is defined, CFEngine will look for a method called <samp><span>generic</span></samp>. Such a method is defined in the standard library for supported operating systems.

<ul>
<li><a>package_architectures in packages</a>
<li><a>package_method in packages</a>
<li><a>package_policy in packages</a>
<li><a>package_select in packages</a>
<li><a>package_version in packages</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.22.1 <code>package_architectures</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: Select the architecture for package selection

<p><b>Example</b>:<br>
<br>

<pre>packages:

  "$(exact_package)"

     package_policy => "add",
     package_method => rpm,
     package_architectures => { "x86_64" };

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>It is possible to specify a list of packages of different architectures if it is desirable to install multiple architectures on the host. If no value is specified, CFEngine makes no promise about the result; the package manager's behaviour prevails.

<div>
<a></a>
<a></a>

</div>

<h4>7.22.2 <code>package_method</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>package_add_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to install a package to the system

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     {
     package_add_command => "/bin/rpm -i ";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This command should install a package when appended with the package reference id, formed using the <code>package_name_convention</code>, using
the model of (name,version,architecture). If <code>package_file_repositories</code> is specified, the package reference id will include the full path to a repository containing the package.

     <p>Package managers generally expect the name of a package to be passed as a parameter. However, in some cases we do not need to pass the name of a particular package to the command. Ending the command string with <samp><span>$</span></samp> prevents CFEngine from appending the package name to the string.

     <br><dt><samp><code>package_arch_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract package architecture string 

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     
     {
     package_list_arch_regex    => "[^.]+\.([^.]+)";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is for use when extracting architecture from the name of the promiser, when the architecture is not specified using the <code>package_architectures</code> list. It is a regular expression that contains exactly one parenthesized back reference which marks the location in the <i>promiser</i> at which the architecture is specified. The regex may match a portion of the string (see <a>Anchored vs. unanchored regular expressions</a>). If no architecture is specified for the given package manager, then do not define this.

     <br><dt><samp><code>package_changes</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>individual</code>
                    <code>bulk</code>
</pre>
     <p><b>Synopsis</b>: Menu option - whether to group packages into a single aggregate command

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     
     {
     package_changes => "bulk";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>
This indicates whether the package manager is capable of handling package operations with multiple arguments. If this is set to <samp><span>bulk</span></samp> then multiple arguments will be passed to the package commands. If set to <samp><span>individual</span></samp> packages will be handled one by one. This might add a significant overhead to the operations, and also affect the ability of the operating system's package manager to handle dependencies.

     <br><dt><samp><code>package_delete_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to remove a package from the system

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     
     {
     package_delete_command => "/bin/rpm -e --nodeps";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The command that deletes a package from the system when appended with the package reference identifier specified by <code>package_name_convention</code>.

     <p>Package managers generally expect the name of a package to be passed as a parameter. However, in some cases we do not need to pass the name of a particular package to the command. Ending the command string with <samp><span>$</span></samp> prevents CFEngine from appending the package name to the string.

     <br><dt><samp><code>package_delete_convention</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: This is how the package manager expects the package to be referred to in the deletion part of a package update, e.g. $(name)

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method freebsd
     
     {
     package_file_repositories => { "/path/to/packages" };
     package_name_convention => "$(name)-$(version).tbz";
     package_delete_convention => "$(name)-$(version)";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This attribute is used when <code>package_policy</code> is <samp><span>delete</span></samp>, or <code>package_policy</code> is <samp><span>update</span></samp> and <code>package_file_repositories</code> is set and <code>package_update_command</code> is not set. It is then used to set the pattern for naming the package in the way expected by the package manager during the deletion of existing packages.

     <p>Three special variables are defined from the extracted data, in a private context for use: <samp><span>$(name)</span></samp>, <samp><span>$(version)</span></samp> and <samp><span>$(arch)</span></samp>. <samp><span>version</span></samp> and <samp><span>arch</span></samp> is the version and arch (if <code>package_list_arch_regex</code> is given) of the already installed package. Additionally, if <code>package_file_repositories</code> is defined, <samp><span>$(firstrepo)</span></samp> can be prepended to expand the first repository containing the package. For example: <samp><span>$(firstrepo)$(name)-$(version)-$(arch).msi</span></samp>.

     <p>If this is not defined, it defaults to the value of <code>package_name_convention</code>.

     <br><dt><samp><code>package_file_repositories</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: A list of machine-local directories to search for packages

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method filebased
     {
     package_file_repositories => { "/package/repos1", "/packages/repos2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If specified, CFEngine will assume that the package installation occurs by filename and will search the named paths for a package matching the pattern <code>package_name_convention</code>.  If found the name will be prefixed to the package name in the package commands.

     <br><dt><samp><code>package_installed_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression which matches packages that are already installed

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method yum
     {
     package_installed_regex => ".*installed.*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This regular expression must match complete lines in the output of the list command that are actually installed packages (see <a>Anchored vs. unanchored regular expressions</a>). If all the lines match then the regex can be set of <samp><span>.*</span></samp>, however most package systems output prefix lines and a variety of human padding that needs to be ignored.

     <br><dt><samp><code>package_default_arch_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>"?(/.*)</code>

     <p><b>Synopsis</b>: Command to detect the default packages' architecture

     <p><b>Example</b>:<br>
<br>
<pre>     body package_method dpkg
     {
       package_default_arch_command => "/usr/bin/dpkg --print-architecture";
     
       # ...
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p><i>History</i>: Was introduced in 3.4.0, Enterprise 3.0.0 (2012)

     <p>This command allows CFEngine to detect default architecture of packages managed by package manager. As an example, multiarch-enabled dpkg only lists architectures explicitly for multiarch-enabled packages.

     <p>In case this command is not provided, CFEngine treats all packages without explicit architecture set as belonging to implicit default architecture.

     <br><dt><samp><code>package_list_arch_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract package architecture string

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     {
     package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A regular expression that contains exactly one parenthesized back reference that marks the location in the listed package at which the architecture is specified. The regular expression may match a portion of the string (see <a>Anchored vs. unanchored regular expressions</a>). If no architecture is specified for the given package manager, then do not define this regex.

     <br><dt><samp><code>package_list_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to obtain a list of available packages

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     
     {
     package_list_command => "/bin/rpm -qa --queryformat \"%{name} %{version}-%{release}\n\"";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This command should provide a complete list of the packages installed on the system. It might also list packages that are not installed. Those should be filtered out using the <code>package_installed_regex</code>.

     <p>Package managers generally expect the name of a package to be passed as a parameter. However, in some cases we do not need to pass the name of a particular package to the command. Ending the command string with <samp><span>$</span></samp> prevents CFEngine from appending the package name to the string.

     <br><dt><samp><code>package_list_name_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract package name string

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     
     {
     package_list_name_regex    => "([^\s]+).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A regular expression that contains exactly one parenthesized back reference which marks the name of the package from the package listing. The regular expression may match a portion of the string (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>package_list_update_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Command to update the list of available packages (if any)

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method xyz
     {
     debian|ubuntu::
     
     package_list_update_command => "/usr/bin/apt-get update";
     package_list_update_ifelapsed => "240";		# 4 hours
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Not all package managers update their list information from source automatically. This command allows a separate update command to be executed at intervals determined by <code>package_list_update_ifelapsed</code>.

     <br><dt><samp><code>package_list_update_ifelapsed</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>-99999999999,9999999999</code>

     <p><b>Synopsis</b>: The ifelapsed locking time in between updates of the package list

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method xyz
     {
     debian|ubuntu::
     
     package_list_update_command => "/usr/bin/apt-get update";
     package_list_update_ifelapsed => "240";		# 4 hours
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Not all package managers update their list information from source automatically. This command allows a separate update command to be executed at intervals determined by <code>package_list_update_ifelapsed</code>.

     <br><dt><samp><code>package_list_version_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract package version string

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method rpm
     
     {
     package_list_version_regex => "[^\s]+ ([^.]+).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This regular expression should containe exactly one parenthesized back-reference that marks the version string of packages listed as installed.  The regular expression may match a portion of the string (see <a>Anchored vs. unanchored regular expressions</a>)

     <br><dt><samp><code>package_name_convention</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: This is how the package manager expects the package to be referred to, e.g. $(name).$(arch)

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method rpm
     
     {
     package_name_convention => "$(name).$(arch).rpm";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This sets the pattern for naming the package in the way expected by the package manager. Three special variables are defined from the extracted data, in a private context for use: <samp><span>$(name)</span></samp>, <samp><span>$(version)</span></samp> and <samp><span>$(arch)</span></samp>. Additionally, if <code>package_file_repositories</code> is defined, <samp><span>$(firstrepo)</span></samp> can be prepended to expand the first repository containing the package. For example: <samp><span>$(firstrepo)$(name)-$(version)-$(arch).msi</span></samp>.

     <p>When <code>package_policy</code> is <samp><span>update</span></samp>, and <code>package_file_repositories</code> is specified, <code>package_delete_convention</code> may be used to specify a different convention for the delete command.

     <p>If this is not defined, it defaults to the value  <samp><span>$(name)</span></samp>.

     <br><dt><samp><code>package_name_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract package name string

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     {
     package_name_regex => "([^\s]).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This regular expression is only used when the <i>promiser</i> contains not only the name of the package, but its version and architecture also. In that case, this expression should contain a single parenthesized back-reference to extract the name of the package from the string. The regex may match a portion of the string (see <a>Anchored vs. unanchored regular expressions</a>)

     <br><dt><samp><code>package_noverify_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression to match verification failure output

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method xyz
     
     {
     package_noverify_regex => "Package .* is not installed.*";
     package_verify_command => "/usr/bin/dpkg -s";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A regular expression to match output from a package verification command. If the output string matches this expression, the package is deemed broken.  The regex must match the entire line (see <a>Anchored vs. unanchored regular expressions</a>)

     <br><dt><samp><code>package_noverify_returncode</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>-99999999999,9999999999</code>

     <p><b>Synopsis</b>: Integer return code indicating package verification failure

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method xyz
     {
     package_noverify_returncode => "-1";
     package_verify_command => "/bin/rpm -V";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>For use if a package verification command uses the return code as the signal for a failed package verification.

     <br><dt><samp><code>package_patch_arch_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract update architecture string

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method zypper
     {
     package_patch_arch_regex => "";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A few package managers keep a separate notion of patches, as opposed to package updates. OpenSuSE, for example, is one of these. This provides an analogous command struct to the packages for patch updates.  The regular expression must match the entire line (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>package_patch_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to update to the latest patch release of an installed package

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method zypper
     
     {
     package_patch_command => "/usr/bin/zypper -non-interactive patch";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>
If the package manager supports patching, this command should patch a named package. If only patching of all packages is supported then consider running that as a batch operation in <code>commands</code>. Alternatively one can end the command string with a <samp><span>$</span></samp> symbol, which CFEngine will interpret as an instruction to not append package names.

     <p>Package managers generally expect the name of a package to be passed as a parameter. However, in some cases we do not need to pass the name of a particular package to the command. Ending the command string with <samp><span>$</span></samp> prevents CFEngine from appending the package name to the string.

     <br><dt><samp><code>package_patch_installed_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression which matches packages that are already installed

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method zypper
     {
     package_patch_installed_regex => ".*(Installed|Not Applicable).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A few package managers keep a separate notion of patches, as opposed to package updates. OpenSuSE, for example, is one of these. This provide an analogous command struct to the packages for patch updates. The regular expression must match the entire string (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>package_patch_list_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to obtain a list of available patches or updates

     <p><b>Example</b>:<br>
<br>

     <pre>     
      package_patch_list_command => "/usr/bin/zypper patches";
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This command, if it exists at all, is presumed to generate a list of patches that are available on the system, in a format analogous to (but not necessarily the same as) the package-list command. Patches might formally be available in the package manager's view, but if they have already been installed, CFEngine will ignore them.

     <p>Package managers generally expect the name of a package to be passed as a parameter. However, in some cases we do not need to pass the name of a particular package to the command. Ending the command string with <samp><span>$</span></samp> prevents CFEngine from appending the package name to the string.

     <br><dt><samp><code>package_patch_name_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract update name string

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method zypper
     {
     package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A few package managers keep a separate notion of patches, as opposed to package updates. OpenSuSE, for example, is one of these. This provides an analogous command struct to the packages for patch updates. The regular expression may match a partial string (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>package_patch_version_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract update version string

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method zypper
     {
     package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A few package managers keep a separate notion of patches, as opposed to package updates. OpenSuSE, for example, is one of these. This provides an analogous command struct to the packages for patch updates. The regular expression is unanchored, meaning it may match a partial string (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>package_update_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to update to the latest version a currently installed package

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method zypper
     {
     package_update_command => "/usr/bin/zypper -non-interactive update";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If supported this should be a command that updates the version of a single currently installed package. If only bulk updates are supported, consider running this as a single command under <code>commands</code>. The package reference id is appended, with the pattern of <code>package_name_convention</code>.

     <p>When <code>package_file_repositories</code> is specified, the package reference id will include the full path to a repository containing the package. If <code>package_policy</code> is <samp><span>update</span></samp>, and this command is not specified, the <code>package_delete_command</code> and <code>package_add_command</code> will be executed to carry out the update.

     <br><dt><samp><code>package_verify_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to verify the correctness of an installed package

     <p><b>Example</b>:<br>
<br>

     <pre>     body package_method rpm
     
     {
     package_verify_command => "/bin/rpm -V";
     package_noverify_returncode => "-1";
     }
     
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If available, this is a command to verify an already installed package. It is required only when <code>package_policy</code> is <samp><span>verify</span></samp>.

     <p>The outcome of the command is compared with <code>package_noverify_returncode</code> or <code>package_noverify_regex</code>, one of which has to be set when using this command. If the package is not installed, the command will not be run  the promise gets flagged as not kept before the verify command executes.

     <p>In order for the promise to be considered kept, the package must be installed, and the verify command must be successful according to <code>package_noverify_returncode</code> xor <code>package_noverify_regex</code>.

     <p>Package managers generally expect the name of a package to be passed as a parameter. However, in some cases we do not need to pass the name of a particular package to the command. Ending the command string with <samp><span>$</span></samp> prevents CFEngine from appending the package name to the string.

     <br><dt><samp><code>package_version_regex</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression with one backreference to extract package version string

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method rpm
     {
     package_version_regex => "[^\s]+ ([^.]+).*";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If the version of a package is not specified separately using <code>package_version</code>, then this should be a regular expression that contains exactly one parenthesized back-reference that matches the version string in the promiser. The regular expression is unanchored, meaning it may match a partial string (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>package_multiline_start</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression which matches the start of a new package in multiline output

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body package_method solaris (pkgname, spoolfile, adminfile)
     {
     package_changes => "individual";
     package_list_command => "/usr/bin/pkginfo -l";
     package_multiline_start    =>  "\s*PKGINST:\s+[^\s]+";
     ...
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This pattern is used in determining when a new package record begins. It is used when package managers (like the Solaris package manager) use multi-line output formats. This pattern matches the first line of a new record.

     <br><dt><samp><code>package_commands_useshell</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: Whether to use shell for commands in this body

     <p><b>Default value:</b> true

     <p><b>Example</b>:<br>
<br>

     <pre>     
     Fill me in (./bodyparts/package_commands_useshell_example.texinfo)
     ""
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p><i>History</i>: Was introduced in 3.4.0b1.70bd7ea, Nova 2.3.0.a1.3167b00 (2012)

     <pre>     
     Fill me in (./bodyparts/package_commands_useshell_notes.texinfo)
     ""
</pre>

     <br><dt><samp><code>package_version_less_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to check whether first supplied package version is less than second one

     <p><b>Example</b>:<br>
<br>
<pre>     body package_method deb
     {
     ...
     package_version_less_command => "dpkg --compare-versions ${v1} lt ${v2}";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>
<i>History</i>: Was introduced in 3.4.0 (2012)

     <p>This attribute allows overriding of the built-in CFEngine algorithm for version comparison, by calling an external command to check whether the first passed version is less than another.

     <p>The built-in algorithm does a good approximation of version comparison, but different packaging systems differ in corner cases (e.g Debian treats symbol ~ less than any other symbol and even less than empty string), so some sort of override is necessary.

     <p>Variables <code>v1</code> and <code>v2</code> are substituted with the first and second version to be compared. Command should return code 0 if v1 is less than v2 and non-zero otherwise.

     <p>Note that if package_version_equal_command is not specified, but package_version_less_command is, then equality will be tested by issuing less comparison twice (v1 equals to v2 if v1 is not less than v2, and v2 is not less than v1).

     <br><dt><samp><code>package_version_equal_command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.+</code>

     <p><b>Synopsis</b>: Command to check whether first supplied package version is equal to second one

     <p><b>Example</b>:<br>
<br>
<pre>     body package_method deb
     {
     ...
     package_version_equal_command => "dpkg --compare-versions ${v1} eq ${v2}";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>
<i>History</i>: Was introduced in 3.4.0 (2012)

     <p>This attribute allows overriding of the built-in CFEngine algorithm for version comparison by calling an external command to check whether the passed versions are the same. Some package managers consider textually different versions to be the same (e.g. optional epoch component, so 0:1.0-1 and 1.0-1 versions are the same), and rules for comparing vary from package manager to package manager, so override is necessary.

     <p>Variables <code>v1</code> and <code>v2</code> are substituted with the versions to be compared. Command should return code 0 if versions are equal and non-zero otherwise.

     <p>Note that if package_version_equal_command is not specified, but package_version_less_command is, then equality will be tested by issuing less comparison twice (v1 equals to v2 if v1 is not less than v2, and v2 is not less than v1).

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.22.3 <code>package_policy</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>add</code>
               <code>delete</code>
               <code>reinstall</code>
               <code>update</code>
               <code>addupdate</code>
               <code>patch</code>
               <code>verify</code>
</pre>
   <p><b>Default value:</b> verify

<p><b>Synopsis</b>: Criteria for package installation/upgrade on the current system

<p><b>Example</b>:<br>
<br>

<pre>packages:

  "$(match_package)"

     package_policy => "add",
     package_method => xyz;

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This decides what fate is intended for the named package.

     <dl>
<dt>add<dd>Ensure that a package is present (this is the default setting from 3.3.0). 
<br><dt>delete<dd>Ensure that a package is not present. 
<br><dt>reinstall<dd>Delete then add package (warning, non-convergent). 
<br><dt>update<dd>Update the package if an update is available (manager dependent). 
<br><dt>addupdate<dd>Equivalent to <samp><span>add</span></samp> if the package is not installed, and
<samp><span>update</span></samp> if it is installed. 
<br><dt>patch<dd>Install one or more patches if available (manager dependent). 
<br><dt>verify<dd>Verify the correctness of the package (manager dependent). The promise
is kept if the package is installed correctly, not kept
otherwise. Requires setting <code>package_verify_command</code>. 
</dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.22.4 <code>package_select</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code></code>
               <code></code>
               <code>==</code>
               <code>!=</code>
               <code>=</code>
               <code>=</code>
</pre>
   <p><b>Synopsis</b>: A criterion for first acceptable match relative to "package_version"

<p><b>Example</b>:<br>
<br>

<pre>packages:

  "$(exact_package)"

     package_policy => "add",
     package_method => xyz,
     package_select => ">=",
     package_architectures => { "x86_64" },
     package_version => "1.2.3-456";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This selects the operator that compares the promiser to the state of the system packages currently installed. If the criterion matches, the policy action is scheduled for promise-keeping.

<div>
<a></a>
<a></a>

</div>

<h4>7.22.5 <code>package_version</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: Version reference point for determining promised version

<p><b>Example</b>:<br>
<br>

<pre>packages:

  "mypackage"

     package_policy => "add",
     package_method => rpm,
     package_select => "==",
     package_version => "1.2.3";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Used for specifying the targeted package version when the version is written separately from the name of the command.

<div>
<a></a>

</div>


