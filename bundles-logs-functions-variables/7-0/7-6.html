<h3>7.6 <code>delete_lines</code> promises in <samp><span>edit_line</span></samp></h3>

<p><br>

   <p>This promise assures that certain lines exactly matching regular expression patterns will not be present in a text file. If the lines are found, the default promise is to remove them (this behavior may be modified with further pattern matching in <code>delete_select</code> and/or changed with <code>not_matching</code>).

   <p><br>

<pre>
bundle edit_line example
  {
  delete_lines:

    "olduser:.*";

  }

</pre>

   <p>Note that typically, only a single line is specified in each <code>delete_lines</code> promise. However, you may of course have multiple promises that each delete a line.

   <p>It is also possible to specify multi-line <code>delete_lines</code> promises. However, these promises will only delete those lines if <i>all</i> the lines are present in the file <i>in exactly the same order</i> as specified in the promise (with no intervening lines). That is, all the lines must match as a unit for the <code>delete_lines</code> promise to be kept.

   <p><br>

   <p>If the promiser contains multiple lines, then CFEngine assumes that all of the lines must exist as a contiguous block in order to be deletes. This gives <samp><span>preserve_block</span></samp> semantics to any multiline <code>delete_lines</code> promise.

<ul>
<li><a>delete_select in delete_lines</a>
<li><a>not_matching in delete_lines</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.6.1 <code>delete_select</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>delete_if_startwith_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Delete line if it starts with a string in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete_select example(s)
     {
     delete_if_startwith_from_list => { @(s) };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Delete lines from a file if they begin with the sub-strings listed. Note that this determination is made only on promised lines (that is, this
attribute modifies the selection criteria, it does not make the initial selection). Therefore, if the file contains the following lines:

     <pre>     start alpha igniter
     start beta igniter
     init alpha burner
     init beta burner
     stop beta igniter
     stop alpha igniter
     stop alpha burner
</pre>

     <p>Then the following promise initially selects the four lines containing <samp><span>alpha</span></samp>, but is moderated by the <code>delete_select</code> attribute. Thus, the promise will delete only the first and third lines of the file:

     <pre>     bundle edit_line alpha
     {
     delete_lines:
         ".*alpha.*"
     	delete_select => starters;
     }
     
     body delete_select starters
     {
         delete_if_startwith_from_list => { "begin", "start", "init" };
     }
</pre>

     <br><dt><samp><code>delete_if_not_startwith_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Delete line if it DOES NOT start with a string in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete_select example(s)
     {
     delete_if_not_startwith_from_list => { @(s) };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Delete lines from a file unless they start with the sub-strings in the list given. Note that this determination is made only on promised lines. In other words, this attribute modifies the selection criteria, it does not make the initial selection.

     <br><dt><samp><code>delete_if_match_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Delete line if it fully matches a regex in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete_select example(s)
     {
     delete_if_match_from_list => { @(s) };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Delete lines from a file if the lines <i>completely</i> match any of the regular expressions listed. In other words, the regular expression is anchored (see <a>Anchored vs. unanchored regular expressions</a>).

     <p>Note that this attribute modifies the selection criteria, it does not make the initial selection, and the match determination is made only on promised lines.

     <br><dt><samp><code>delete_if_not_match_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Delete line if it DOES NOT fully match a regex in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete_select example(s)
     {
     delete_if_not_match_from_list => { @(s) };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Delete lines from a file unless the lines <i>completely</i> match any of the regular expressions listed. In other words, the regular expressions
are anchored (see <a>Anchored vs. unanchored regular expressions</a>).

     <p>Note that this attribute modifies the selection criteria, it does not make the initial selection, and the match determination is made only on promised lines.

     <br><dt><samp><code>delete_if_contains_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Delete line if a regex in the list match a line fragment

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete_select example(s)
     {
     delete_if_contains_from_list => { @(s) };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Delete lines from a file if they contain the sub-strings listed. 
     
     <p>Note that this attribute modifies the selection criteria, it does not make the initial selection, and the match determination is made only on promised lines.

     <br><dt><samp><code>delete_if_not_contains_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Delete line if a regex in the list DOES NOT match a line fragment

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body delete_select discard(s)
     {
     delete_if_not_contains_from_list => { "substring1", "substring2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Delete lines from the file which do not contain the sub-strings listed.
      
     <p>Note that this attribute modifies the selection criteria, it does not make the initial selection, and the match determination is made only on promised lines.

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.6.2 <code>not_matching</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>true</code>
               <code>false</code>
               <code>yes</code>
               <code>no</code>
               <code>on</code>
               <code>off</code>
</pre>
   <p><b>Default value:</b> false

<p><b>Synopsis</b>: true/false negate match criterion

<p><b>Example</b>:<br>
<br>

<pre>delete_lines:

  # edit /etc/passwd - account names that are not "mark" or "root"

  "(mark|root):.*" not_matching => "true";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>When this option is true, it negates the pattern match of the promised lines.  
   
   <p><b>NOTE</b> that this does not negate any condition expressed in <code>delete_select</code>. It only negates the match of the initially promised lines.

   <p>Note, this makes no sense for multi-line deletions, and is therefore disallowed. Either a multi-line promiser matches and it should be removed (i.e. <code>not_matching</code> is false), or it does not match the whole thing and the ordered lines have no meaning anymore as an entity. In this case, the lines can be separately stated.

<div>
<a></a>
<a></a>

</div>


