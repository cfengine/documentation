<h3>7.2 <code>databases</code> promises in <samp><span>agent</span></samp></h3>

<p><br>

   <p>CFEngine Nova can interact with commonly used database servers to keep promises about the structure and content of data within them.

   <p>There are two main cases of database management to address: small embedded databases and large centralized databases.

   <p>Databases are often centralized entities that have a single point of management. While large monolithic database can be more easily managed with other tools, CFEngine can still monitor changes and discrepancies. In addition, CFEngine can also manage smaller embedded databases that are distributed in nature, whether they are SQL, registry or future types.

   <p>For example, creating 100 new databases for test purposes is a task for CFEngine; but adding a new item to an important production database is not a recomended task for CFEngine.

   <p>There are three kinds of database supported by Nova:

     <dl>
<dt><em>LDAP - The Lightweight Directory Access Protocol</em><dd>A hierarchical network database primarily for reading simple schema.

     <br><dt><em>SQL - Structured Query Language</em><dd>A number of relational databases (currently supported: MySQL, Postgres)
for reading and writing complex data.

     <br><dt><em>Registry - Microsoft Registry</em><dd>An embedded database for interfacing with system values in Microsoft Windows (Only CFEngine Nova)

   </dl>
   In addition, CFEngine uses a  variety of embedded databases for its own internals.

   <p>Embedded databases are directly part of the system and promises can be made directly. However, databases running through a server process (either on the same host or on a different host) are independent agents and CFEngine cannot make promises on their behalf, unless they promise (grant) permission for CFEngine to make the changes. Thus the pre-requisite for making SQL database promises is to grant a point of access on the server.

   <p><table><tr><td>
<pre>     
      databases:
     
       "<var>database</var>/<var>subkey or table</var>"
     
         database_operation = "<var>create/delete/drop</var>",
         database_type = "<var>sql/ms_registry</var>",
         database_columns = {
                             "<var>name</var>,<var>type</var>,<var>size</var>",
                             "<var>name</var>,<var>type</var>",
                             },
     
         database_server = <var>body</var>;
     
     
      body database_server <var>name</var>
       {
       db_server_owner = "<var>account name</var>";
       db_server_password = "<var>password</var>";
       db_server_host = "<var>hostname or omit for localhost</var>";
       db_server_type = "<var>mysql/posgres</var>";
       db_server_connection_db = "<var>database we can connect to</var>";
       }
     
</pre>
   </td></tr></table>

   <p><br>

<pre>
body common control
{
bundlesequence => { "databases" };
}

bundle agent databases

{
#commands:

#  "/usr/bin/createdb cf_topic_maps",

#        contain => as_user("mysql");

databases:

  "cf_topic_maps/topics"

    database_operation => "create",
    database_type => "sql",
    database_columns => { 
                        "topic_name,varchar,256",
                        "topic_comment,varchar,1024",
                        "topic_id,varchar,256",
                        "topic_type,varchar,256",
                        "topic_extra,varchar,26" 
                        },

    database_server => myserver;



}

################################################

body database_server myserver
{
any::
 db_server_owner => "postgres";
 db_server_password => "";
 db_server_host => "localhost";
 db_server_type => "postgres";
 db_server_connection_db => "postgres";
none::
 db_server_owner => "root";
 db_server_password => "";
 db_server_host => "localhost";
 db_server_type => "mysql";
 db_server_connection_db => "mysql";
}

body contain as_user(x)
{
exec_owner => "$(x)";
}
</pre>

   <p><br>

   <p>The promiser in database promises is a concatenation of the database name and underlying tables. This presents a simple hierarchical model that looks like a file-system. This is the normal structure within the Windows registry for instance. Entity-relation databases do not normally present tables in this way, but no harm is done in representing them as a hierarchy of depth 1.

<ul>
<li><a>database_server in databases</a>
<li><a>database_type in databases</a>
<li><a>database_operation in databases</a>
<li><a>database_columns in databases</a>
<li><a>database_rows in databases</a>
<li><a>registry_exclude in databases</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.2.1 <code>database_server</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>db_server_owner</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: User name for database connection

     <p><b>Example</b>:<br>
<br>

     <pre>     
     db_server_owner => "mark";
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>db_server_password</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Clear text password for database connection

     <p><b>Example</b>:<br>
<br>

     <pre>     
     db_server_password => "xyz.1234";
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>db_server_host</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Hostname or address for connection to database (blank means localhost)

     <p><b>Example</b>:<br>
<br>

     <pre>     
     db_server_host => "sqlserv.example.org";
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Hostname or IP address of the server.

     <br><dt><samp><code>db_server_type</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>postgres</code>
                    <code>mysql</code>
</pre>
     <p><b>Synopsis</b>: The dialect of the database server

     <p><b>Default value:</b> none

     <p><b>Example</b>:<br>
<br>

     <pre>     
     db_server_type => "postgres";
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>db_server_connection_db</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: The name of an existing database to connect to in order to create/manage other databases

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body database_server myserver(x)
     {
     db_server_owner => "$(x)";
     db_server_password => "";
     db_server_host => "localhost";
     db_server_type => "$(mysql)";
     db_server_connection_db => "$(x)";
     }
     
</pre>

     <p>where <samp><span>x</span></samp> is currently <code>mysql</code> or <code>postgres</code>.

     <p><b>Notes</b>:<br>
<br>

     <p>In order to create a database on a database server (all of which practice voluntary cooperation), one has to be able to connect to the server, however, without an existing database this is not allowed.  Thus, database servers provide a default database that can be connected to in order to thereafter create new databases. These are called <code>postgres</code> and <code>mysql</code> for their respective database servers.

     <p>For the knowledge agent, this setting is made in the control body, for database verification promises, it is made in the <code>database_server</code> body.

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.2.2 <code>database_type</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>sql</code>
               <code>ms_registry</code>
</pre>
   <p><b>Default value:</b> none

<p><b>Synopsis</b>: The type of database that is to be manipulated

<p><b>Example</b>:<br>
<br>

<pre>
database_type => "ms_registry";

</pre>

<p><b>Notes</b>:<br>
<br>

<div>
<a></a>
<a></a>

</div>

<h4>7.2.3 <code>database_operation</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>create</code>
               <code>delete</code>
               <code>drop</code>
               <code>cache</code>
               <code>verify</code>
               <code>restore</code>
</pre>
   <p><b>Synopsis</b>: The nature of the promise - to be or not to be

<p><b>Example</b>:<br>
<br>

<pre>
database_operation => "create";

</pre>

<p><b>Notes</b>:<br>
<br>

<div>
<a></a>
<a></a>

</div>

<h4>7.2.4 <code>database_columns</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: <code>.*</code>

<p><b>Synopsis</b>: A list of column definitions to be promised by SQL databases

<p><b>Example</b>:<br>
<br>

<pre>
  "cf_topic_maps/topics"

    database_operation => "create",
    database_type => "sql",
    database_columns => { 
                        "topic_name,varchar,256",
                        "topic_comment,varchar,1024",
                        "topic_id,varchar,256",
                        "topic_type,varchar,256",
                        "topic_extra,varchar,26" 
                        },

    database_server => myserver;

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Columns are a list of tuplets (<var>Name,type,size</var>). Array items are triplets, and fixed size data elements are doublets.

<div>
<a></a>
<a></a>


</div>

<h4>7.2.5 <code>database_rows</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: <code>.*,.*</code>

<p><b>Synopsis</b>: An ordered list of row values to be promised by SQL databases

<p><b>Example</b>:<br>
<br>

<pre>
bundle agent databases

{
databases:

 windows::

  # Regsitry has (value,data) pairs in "keys" which are directories

  "HKEY_LOCAL_MACHINE\SOFTWARE\CFEngine AS\CFEngine"

    database_operation => "create",
    database_rows => { "value1,REG_SZ,new value 1", "value2,REG_DWORD,12345"} ,
    database_type     => "ms_registry";
}

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This constraint is used only in adding data to database columns. Rows are considered to be instances of individual columns.

   <p>In the case of the system registry on Windows, the rows represent data on data-value pairs. The currently supported types (the middle field) for the Windows registry are <code>REG_SZ</code> (string), <code>REG_EXPAND_SZ</code> (expandable string) and <code>REG_DWORD</code> (double word).

<div>
<a></a>
<a></a>

</div>

<h4>7.2.6 <code>registry_exclude</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: A list of regular expressions to ignore in key/value verification

<p><b>Example</b>:<br>
<br>

<pre>
databases:

 "HKEY_LOCAL_MACHINE\SOFTWARE"

    database_operation => "cache",

    registry_exclude => { ".*Windows.*CurrentVersion.*", 
                          ".*Touchpad.*",
                          ".*Capabilities.FileAssociations.*", 
                          ".*Rfc1766.*" , 
                          ".*Synaptics.SynTP.*", 
                          ".*SupportedDevices.*8086", 
                          ".*Microsoft.*ErrorThresholds" 
                        },

    database_type     => "ms_registry";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>During recursive Windows registry scanning, this option allows us to ignore keys of values matching a list of regular expressions. Some values in the registry are ephemeral and some should not be considered. This provides a convenient way of avoiding names. It is analogous to <code>exclude_dirs</code> for files.

<div>
<a></a>
<a></a>

</div>


