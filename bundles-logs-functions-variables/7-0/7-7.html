<h3>7.7 <code>insert_lines</code> promises in <samp><span>edit_line</span></samp></h3>

<p><br>

   <p>This promise is part of the line-editing model. It inserts lines into the file at a specified location. The location is determined by body-attributes. The promise object referred to can be a literal line of a file-reference from which to read lines.

   <p><table><tr><td>
<pre>     
      insert_lines:
     
        "<var>literal line or file reference</var>"
     
           location = <var>location_body</var>,
           ...;
     
</pre>
   </td></tr></table>

   <p><br>

<pre>
body common control

{
any::

  bundlesequence  => {
                     example
                     };   
}

#######################################################

bundle agent example

{
files:

  "/var/spool/cron/crontabs/root"

     edit_line => addline;
}

#######################################################
# For the library
#######################################################

bundle edit_line addline

{
insert_lines:

 "0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F";

}

</pre>

   <p><br>

   <p>By parameterizing the editing bundle, one can make generic and reusable editing bundles.

   <p>Note: When inserting multiple lines anchored to a particular place in a file, be careful with your intuition. If your intention is to insert a set of lines in a given order after a marker, then the following is incorrect:

<pre>
bundle edit_line x
{
insert_lines:

  "line one" location => myloc;
  "line two" location => myloc;
}

body location myloc

{
select_line_matching => "# Right here.*";
before_after => "after";
}

</pre>
This will reverse the order of the lines and will not converge, since the anchoring after the marker applies independently for each new line. This is not a bug, but an error of logic.

   <p>What was probably intended was to add multiple ordered lines after the marker, which should be a single correlated promise.

<pre>
bundle edit_line x
{
insert_lines:
 
 "line one$(const.n)line two" location => myloc;

}

</pre>
Or:
<pre>
bundle edit_line x
{
insert_lines:
 
  "line one
line two" location => myloc;

}

</pre>

<ul>
<li><a>expand_scalars in insert_lines</a>
<li><a>insert_type in insert_lines</a>
<li><a>insert_select in insert_lines</a>
<li><a>location in insert_lines</a>
<li><a>whitespace_policy in insert_lines</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.7.1 <code>expand_scalars</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>true</code>
               <code>false</code>
               <code>yes</code>
               <code>no</code>
               <code>on</code>
               <code>off</code>
</pre>
   <p><b>Default value:</b> false

<p><b>Synopsis</b>: Expand any unexpanded variables

<p><b>Example</b>:<br>
<br>

<pre>
body common control

{
bundlesequence  => { "testbundle"  };
}

########################################################

bundle agent testbundle

{
files:

  "/home/mark/tmp/file_based_on_template"

       create    => "true",
       edit_line => ExpandMeFrom("/tmp/source_template");


}

########################################################

bundle edit_line ExpandMeFrom(template)
{
insert_lines:

   "$(template)"

          insert_type => "file",
       expand_scalars => "true";
}

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>A way of incorporating templates with variable expansion into file operations. Variables should be named and scoped appropriately for the bundle in which this promise is made. In other words, you should qualify the variables with the bundle in which they are defined. For example:

<pre>$(bundle.variable)
$(sys.host)
$(mon.www_in)
</pre>

   <p>In CFEngine 2 <code>editfiles</code> this was called <samp><span>ExpandVariables</span></samp>.

<div>
<a></a>
<a></a>

</div>

<h4>7.7.2 <code>insert_type</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>literal</code>
               <code>string</code>
               <code>file</code>
               <code>file_preserve_block</code>
               <code>preserve_block</code>
</pre>
   <p><b>Default value:</b> literal

<p><b>Synopsis</b>: Type of object the promiser string refers to

<p><b>Example</b>:<br>
<br>

<pre>bundle edit_line lynryd_skynyrd
{
 vars:
    "keepers" slist => { "Won't you give me", "Gimme three steps" };

 insert_lines:

     "And you'll never see me no more"
       insert_type => "literal";	# the default

     "/song/lyrics"
       insert_type => "file",		# read selected lines from /song/lyrics
       insert_select => keep("@{keepers}");
}

body insert_select keep(s)
{
insert_if_startwith_from_list => { "@(s)" };
}

</pre>

   <p>This will ensure that the following lines are inserted into the promised file:

<pre>And you'll never see me no more
Gimme three steps, Mister
Gimme three steps towards the door
Gimme three steps
</pre>

<p><b>Notes</b>:<br>
<br>

   <p>The default is to treat the promiser as a literal string of convergent lines (the values <code>literal</code> and <code>string</code> are synonymous).

   <p>The default behaviour assumes that multi-line entries are not ordered specifically. They should be treated as a collection of lines of text, and not as a single unbroken object.

   <p>If the option <samp><span>preserve_block</span></samp> is used, then CFEngine will not break up multiple lines into individual, non-ordered objects, so that the block of text will be preserved. Even if some of the lines in the block already exist, they will be added again as a coherent block. Thus if you suspect that some stray / conflicting lines might be present they should be cleaned up with <code>delete_lines</code> first.

   <p>The value <code>file</code> is used to tell CFEngine that the string is non-literal and should be interpreted as a filename from which to import lines. 
   
   <p>See: <a>insert_select</a>. 
   
   <p>Inserted files assume non-<samp><span>preserve_block</span></samp> semantics. An equivalent file setting that does preserve the ordering of lines in the file is called <code>file_preserve_block</code>. This was added in CFEngine Core 3.5.x.

<div>
<a></a>
<a></a>

</div>

<h4>7.7.3 <code>insert_select</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>insert_if_startwith_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Insert line if it starts with a string in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body insert_select example
     {
     insert_if_startwith_from_list => { "find_me_1", "find_me_2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>
The list contains literal strings to search for in the secondary file (the file being read via the <code>insert_type</code> attribute, not the main file being edited). If a string with matching starting characters is found, then that line from the secondary file will be inserted at the present location in the primary file.

     <p><code>insert_if_startswith_from_list</code> is ignored unless <code>insert_type</code> is <code>file</code> (see <a>insert_type in insert_lines</a>), or the promiser is a multi-line block.

     <br><dt><samp><code>insert_if_not_startwith_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Insert line if it DOES NOT start with a string in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body insert_select example
     {
     insert_if_not_startwith_from_list => { "find_me_1", "find_me_2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The complement of <code>insert_if_startwith_from_list</code>.  If the start of a line does <i>not</i> match one of the strings, that line is inserted into the file being edited.

     <p><code>insert_if_not_startswith_from_list</code> is ignored unless <code>insert_type</code> is <code>file</code> or the promiser is a multi-line block.
     
     <p>See: <a>insert_type in insert_lines</a>

     <br><dt><samp><code>insert_if_match_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Insert line if it fully matches a regex in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body insert_select example
     {
     insert_if_match_from_list => { ".*find_.*_1.*", ".*find_.*_2.*" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>
The list contains literal strings to search for in the secondary file (the file being read via the <code>insert_type</code> attribute, not the main file being edited). If the regex matches a <i>complete</i> line of the file, that line from the secondary file will be inserted at the present location in the primary file. That is, the regex's in the list are anchored.

     <p>See: <a>Anchored vs. unanchored regular expressions</a>

     <p><code>insert_if_match_from_list</code> is ignored unless <code>insert_type</code> is <code>file</code>, or the promiser
is a multi-line block.
     
     <p>See <a>insert_type in insert_lines</a>

     <br><dt><samp><code>insert_if_not_match_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Insert line if it DOES NOT fully match a regex in the list

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body insert_select example
     {
     insert_if_not_match_from_list => { ".*find_.*_1.*", ".*find_.*_2.*" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The complement of <code>insert_if_match_from_list</code>. If the line does <i>not</i> match a line in the secondary file, it is inserted into the file being edited.

     <p><code>insert_if_not_match_from_list</code> is ignored unless <code>insert_type</code> is <code>file</code>, or the promiser is a multi-line block.
     
     <p>See: <a>insert_type in insert_lines</a>

     <br><dt><samp><code>insert_if_contains_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Insert line if a regex in the list match a line fragment

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body insert_select example
     {
     insert_if_contains_from_list => { "find_me_1", "find_me_2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The list contains literal strings to search for in the secondary file; in other words, the file being read via the <code>insert_type</code> attribute, not the main file being edited. If the string is found in a line of the file, that line from the secondary file will be inserted at the present location in the primary file.

     <p><code>insert_if_contains_from_list</code> is ignored unless <code>insert_type</code> is <code>file</code>, or the promiser is a multi-line block.

     <p>See: <a>insert_type in insert_lines</a>

     <br><dt><samp><code>insert_if_not_contains_from_list</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Insert line if a regex in the list DOES NOT match a line fragment

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body insert_select example
     {
     insert_if_not_contains_from_list => { "find_me_1", "find_me_2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The complement of <code>insert_if_contains_from_list</code>.  If the line is <i>not</i> found in the secondary file, it is inserted into the file being edited.

     <p><code>insert_if_not_contains_from_list</code> is ignored unless <code>insert_type</code> is <code>file</code>, or the promiser is a multi-line block.
     
     <p>See: <a>insert_type in insert_lines</a>

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.7.4 <code>location</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>before_after</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>before</code>
                    <code>after</code>
</pre>
     <p><b>Synopsis</b>: Menu option, point cursor before of after matched line

     <p><b>Default value:</b> after

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body location append
     
     {
     #...
     before_after => "before";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Determines whether an edit will occur before or after the currently matched line.

     <br><dt><samp><code>first_last</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>first</code>
                    <code>last</code>
</pre>
     <p><b>Synopsis</b>: Menu option, choose first or last occurrence of match in file

     <p><b>Default value:</b> last

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body location example
     {
     first_last => "last";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>In multiple matches, decide whether the first or last occurrence of the matching pattern in the case affected by the change. In principle this could be generalized to more cases but this seems like a fragile quality to evaluate, and only these two cases are deemed of reproducible significance.

     <br><dt><samp><code>select_line_matching</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Regular expression for matching file line location

     <p><b>Example</b>:<br>
<br>

     <pre>     
     # Editing
     
     body location example
     {
     select_line_matching => "Expression match.* whole line";
     }
     
     # Measurement promises
     
     body match_value example
     {
     select_line_matching => "Expression match.* whole line";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The expression must match a whole line, not a fragment within a line; that is, it is anchored.
     
     <p>See: <a>Anchored vs. unanchored regular expressions</a>

     <p>This attribute is mutually exclusive of <code>select_line_number</code>.

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.7.5 <code>whitespace_policy</code></h4>

<p><b>Type</b>: (option list)

<p><b>Allowed input range</b>: <br>
<pre>               <code>ignore_leading</code>
               <code>ignore_trailing</code>
               <code>ignore_embedded</code>
               <code>exact_match</code>
</pre>
   <p><b>Synopsis</b>: Criteria for matching and recognizing existing lines
   
   <p><b>Default value</b>: <code>exact_match</code> 

<p><b>Example</b>:<br>
<br>

<pre>bundle edit_line Insert(service, filename)
{
insert_lines:

  "$(service).* $(filename)"

      whitespace_policy => { "ignore_trailing", "ignore_embedded" };

}

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>The white space matching policy applies only to <code>insert_lines</code>, as a convenience. It works by rewriting the insert string as a regular expression when <i>matching</i> lines (that is, when determining if the line is already in the file), but leaving the string as specified when actually inserting it.

   <p>Simply put, the `does this line exist' test will be changed to a regexp match. The line being tested will optionally have "\s*" prepended or appended if <code>ignore_leading</code> or <code>ignore_trailing</code> is specified, and if <code>ignore_imbedded</code> is used then all embedded white spaces are replaced with <samp><span>\s+</span></samp>. Since <code>whitespace_policy</code> is additive you may specify more than one.

   <p>Any regular expression meta-characters that exist in your input line will be escaped. In this way, it is possible to safely insert a line such as <samp><span>"authpriv.* /var/log/something"</span></samp> into a syslog config file.
   
   <p>Unless you use this new attribute, your <code>insert_line</code> promises should behave as before.

   <p><b>History</b>: This attribute was introduced in CFEngine version 3.0.5 (2010)

<div>
<a></a>
<a></a>

</div>


