<h3>7.24 <code>services</code> promises in <samp><span>agent</span></samp></h3>

<p><br>
A service is a set of zero or more processes. It can be zero if the service is not currently running. Services run in the background, and do not require user intervention.

   <p>Service promises may be viewed as an abstraction of process and commands promises. An important distinguisher is however that a single service may consist of multiple processes. Additionally, services are registered in the operating system in some way, and get a unique name. Unlike processes and commands promises, this makes it possible to use the same name both when it is running and not.

   <p>Some operating systems are bundled with a lot of unused services that are running as default. At the same time, faulty or inherently insecure services are often the cause of security issues. With CFEngine, one can create promises stating the services that should be stopped and disabled.

   <p>The operating system may start a service at boot time, or it can be started by CFEngine. Either way, CFEngine will ensure that the service maintains the correct state (started, stopped, or disabled). On some operating systems, CFEngine also allows services to be started on demand, when they are needed. This is implemented though the <code>inetd</code> or <code>xinetd</code> daemon on Unix. Windows does not support this.

   <p>CFEngine also allows for the concept of dependencies between services, and can automatically start or stop these, if desired. Parameters can be passed to services that are started by CFEngine.

   <p><br>

<pre>
bundle agent example
{
services:

  "Dhcp"
    service_policy => "start",
    service_dependencies => { "Alerter", "W32Time" },
    service_method => winmethod;
}
 
########################################################

body service_method winmethod
{
  service_type => "windows";
  service_args => "--netmask=255.255.0.0";
  service_autostart_policy => "none";
  service_dependence_chain => "start_parent_services";
}

</pre>

   <p><br>

   <p>Services promises for Windows are only available in CFEngine Nova and above. Windows Vista/Server 2008 and later introduced new complications to the service security policy. Therefore, when testing <code>services</code> promises from the command line, CFEngine may not be given proper access rights, which gives errors like "Access is denied". However, when running through the CFEngine Nova Executor service, typical for on production machines, CFEngine has sufficient rights.

   <p>Services of type <samp><span>generic</span></samp> promises are implemented for all operating systems and are merely as a convenient front-end to <code>processes</code> and <code>commands</code>.  If nothing else is specified, CFEngine looks for an special reserved agent bundle called

<pre>bundle agent standard_services(service,state)
{
...
}
</pre>

   <p>This bundle is called with two parameters: the name of the service and a start/stop state variable. The CFEngine standard library defines many common services for standard operating systems for convenience. If no <code>service_bundle</code> is defined in a <code>service_method</code> body, then CFEngine assumes the <samp><span>standard_services</span></samp> bundle to be the default source of action for the services. This is executed just like a <code>methods</code> promise on the service bundle, so this is merely a front-end.

   <p>The standard bundle can be replaced with another, as follows:

<pre>body common control
{
bundlesequence => { "test" };
}

#

bundle agent test
{
vars:

 "mail" slist => { "spamassassin", "postfix" };


services:

  "www" service_policy => "start",
        service_method => service_test;


  "$(mail)" service_policy => "stop",
        service_method => service_test;
}

#

body service_method service_test
{
service_bundle => non_standard_services("$(this.promiser)","$(this.service_policy)");
}

#

bundle agent non_standard_services(service,state)
{
reports:

  !done::

    "Test service promise for \"$(service)\" -> $(state)";
}
</pre>

   <p>Note that the special variables <code>$(this.promiser)</code> and <code>$(this.service_policy)</code> may be used to fill in the service and state parameters from the promise definition. The <code>$(this.service_policy)</code> variable is only defined for services promises.

<ul>
<li><a>service_policy in services</a>
<li><a>service_dependencies in services</a>
<li><a>service_method in services</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.24.1 <code>service_policy</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>start</code>
               <code>stop</code>
               <code>disable</code>
               <code>restart</code>
               <code>reload</code>
</pre>
   <p><b>Synopsis</b>: Policy for cfengine service status

<p><b>Example</b>:<br>
<br>

<pre>
services:
  
  "Telnet"
     service_policy => "disable";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>If set to <code>start</code>, CFEngine Nova will keep the service in a running state, while <code>stop</code> means that the service is kept in a stopped state. <code>disable</code> implies <code>stop</code>, and ensures that the service can not be started directly, but needs to be enabled somehow first (e.g. by changing file permissions).

<div>
<a></a>
<a></a>

</div>

<h4>7.24.2 <code>service_dependencies</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

<p><b>Synopsis</b>: A list of services on which the named service abstraction depends

<p><b>Example</b>:<br>
<br>

<pre>
services:
  
  "ftp"
    service_policy => "start",
    service_dependencies => { "network", "logging" };

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>A list of services that must be running before the service can be started. These dependencies can be started automatically by CFEngine Nova if they are not running  see <code>service_dependence_chain</code>. However, the dependencies will never be implicitly stopped by CFEngine Nova. Specifying dependencies is optional.

   <p>Note that the operating system may keep an additional list of dependencies for a given service, defined during installation of the service. CFEngine Nova requires these dependencies to be running as well before starting the service. The complete list of dependencies is thus the union of <code>service_dependencies</code> and the internal operating system list.

<div>
<a></a>
<a></a>

</div>

<h4>7.24.3 <code>service_method</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>service_args</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Parameters for starting the service as command

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body service_method example
     {
       service_args => "-f filename.conf --some-argument";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>These arguments will only be passed if CFEngine Nova starts the service. Thus, set <code>service_autostart_policy</code> to <code>none</code> to ensure that the arguments are always passed.

     <p>Escaped quotes can be used to pass an argument containing spaces as a single argument, e.g. "-f \"file name.conf\"". Passing arguments is optional.

     <br><dt><samp><code>service_autostart_policy</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>none</code>
                    <code>boot_time</code>
                    <code>on_demand</code>
</pre>
     <p><b>Synopsis</b>: Should the service be started automatically by the OS

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body service_method example
     {
       service_autostart_policy => "boot_time";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Defaults to <code>none</code>, which means that the service is not registered for automatic startup by the operating system in any way. It must be <code>none</code> if <code>service_policy</code> is not <code>start</code>. <code>boot_time</code> means the service is started at boot time, while <code>on_demand</code> means that the service is dispatched once it is being used.

     <p><code>on_demand</code> is not supported by Windows, and is implemented through inetd or xinetd on Unix.

     <br><dt><samp><code>service_bundle</code></samp><dd><b>Type</b>: (ext bundle)
 (Separate Bundle)

     <br><dt><samp><code>service_dependence_chain</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>ignore</code>
                    <code>start_parent_services</code>
                    <code>stop_child_services</code>
                    <code>all_related</code>
</pre>
     <p><b>Synopsis</b>: How to handle dependencies and dependent services

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body service_method example
     {
       service_dependence_chain => "start_parent_services";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The service dependencies include both the dependencies defined by the operating system and in <code>service_dependencies</code>, as described there.

     <p>Defaults to <code>ignore</code>, which means that CFEngine Nova will never start or stop dependencies or dependent services, but fail if dependencies are not satisfied. <code>start_parent_services</code> means that all dependencies of the service will be started if they are not already running. When stopping a service, <code>stop_child_services</code> means that other services that depend on this service will be stopped also. <code>all_related</code> means both <code>start_parent_services</code> and <code>stop_child_services</code>.

     <p>Note that this setting also affects dependencies of dependencies and so on.

     <p>For example, consider the case where service A depends on B, which depends on C. If we want to start B, we must first make sure A is running. If <code>start_parent_services</code> or <code>all_related</code> is set, CFEngine Nova will start A, if it is not running. On the other hand, if we want to stop B, C needs to be stopped first. <code>stop_child_services</code> or <code>all_related</code> means that CFEngine Nova will stop C, if it is running.

     <br><dt><samp><code>service_type</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>windows</code>
                    <code>generic</code>
</pre>
     <p><b>Synopsis</b>: Service abstraction type

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body service_method example
     {
       type => "windows";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>On Windows this defaults to, and must be <code>windows</code>.  Unix systems can however have multiple means of registering services, but the choice must be available on the given system.

   </dl>

<div>
<a></a>

</div>


