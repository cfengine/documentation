<h3>7.8 <code>field_edits</code> promises in <samp><span>edit_line</span></samp></h3>

<p><br>

   <p>Certain types of text files (e.g. the <samp><span>passwd</span></samp> and <samp><span>group</span></samp> files in Unix) are tabular in nature, with field separators (e.g. <samp><span>:</span></samp> or <samp><span>,</span></samp>). This promise assumes a parameterizable model for editing the fields of such files, using a regular expression to separate major fields and a character to separate sub-fields. 
   
   First you match the line with a regular expression. The regular expression must match the entire line; that is, it is anchored (see <a>Anchored vs. unanchored regular expressions</a>). Then a <code>field_edits</code> body describes the separators for fields and one level of sub-fields, along with policies for editing these fields, ordering the items within them.

   <p><table><tr><td>
<pre>     
     field_edits:
     
         "<var>regex matching line</var>"
     
                   edit_field = <var>body</var>;
     
</pre>
   </td></tr></table>

   <p><br>

<pre>
bundle agent example

{
vars:

 "userset" slist => { "one-x", "two-x", "three-x" };

files:

  "/tmp/passwd"

       create    => "true",
       edit_line => SetUserParam("mark","6","/set/this/shell");

  "/tmp/group"

       create    => "true",
       edit_line => AppendUserParam("root","4","@(userset)");
}

########################################################

bundle edit_line SetUserParam(user,field,val)
  {
  field_edits:

   "$(user):.*"

      # Set field of the file to parameter

      edit_field => col(":","$(field)","$(val)","set");
  }

########################################################

bundle edit_line AppendUserParam(user,field,allusers)
  {
  vars:

    "val" slist => { @(allusers) };

  field_edits:

   "$(user):.*"

      # Set field of the file to parameter

      edit_field => col(":","$(field)","$(val)","alphanum");

  }

########################################
# Bodies
########################################

body edit_field col(split,col,newval,method)

{
field_separator => "$(split)";
select_field    => "$(col)";
value_separator  => ",";
field_value     => "$(newval)";
field_operation => "$(method)";
extend_fields => "true";
}

</pre>

   <p><br>

   <p>Field editing allows us to edit tabular files in a unique way, adding and removing data from addressable fields. The <samp><span>passwd</span></samp> and <samp><span>group</span></samp> files are classic examples of tabular files, but there are many ways to use this feature. For example, editing a string:

<pre>
VARIABLE="one two three"

</pre>

<p>View this line as a tabular line separated by <samp><span>"</span></samp> and with sub-separator given by the space.

<ul>
<li><a>edit_field in field_edits</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.8.1 <code>edit_field</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>allow_blank_fields</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false allow blank fields in a line (do not purge)

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_field example
     {
     # ...
     allow_blank_fields => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>When editing a file using the field or column model, blank fields, especially at the start and end are generally discarded. If this is set to true, CFEngine will retain the blank fields and print the appropriate number of field separators.

     <br><dt><samp><code>extend_fields</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false add new fields at end of line if necessary to complete edit

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_field example
     {
     extend_fields => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If a user specifies a field that does not exist, because there are not so many fields, this allows the number of fields to be extended. Without this setting, CFEngine will issue an error if a non-existent field is referenced.  Blank fields in a tabular file can be eliminated or kept depending
in this setting. If in doubt, set this to true.

     <br><dt><samp><code>field_operation</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>prepend</code>
                    <code>append</code>
                    <code>alphanum</code>
                    <code>delete</code>
                    <code>set</code>
</pre>
     <p><b>Synopsis</b>: Menu option policy for editing subfields

     <p><b>Default value:</b> none

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_field example
     {
     field_operation => "append";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The method by which to edit a field in multi-field/column editing of tabular files. The methods mean:

     <p><samp><span>append</span></samp> - append the specified value to the end of the field/column, separating
    (potentially) multiple values with <samp><span>value_separator</span></samp>

     <p><samp><span>prepend</span></samp> - prepend the specified value at the beginning of the field/column,
    separating (potentially) multiple values with <samp><span>value_separator</span></samp>

     <p><samp><span>alphanum</span></samp> - insert the specified value into the field/column, keeping all the
    values (separated by <samp><span>value_separator</span></samp>) in alphanumerically sorted order

     <p><samp><span>set</span></samp> - replace the entire field/column with the specified value

     <p><samp><span>delete</span></samp> - delete the specified value (if present) in the specified field/column

     <p><b>Default value</b>: append

     <br><dt><samp><code>field_separator</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: The regular expression used to separate fields in a line

     <p><b>Default value:</b> none

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_field example
     {
     field_separator => ":";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Most tabular files are separated by simple characters, but by allowing a general regular expression one can make creative use of this model to edit all kinds of line-based text files.

     <br><dt><samp><code>field_value</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>.*</code>

     <p><b>Synopsis</b>: Set field value to a fixed value

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_field example(s)
     {
     field_value => "$(s)";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Set a field to a constant value. For example, reset the value to a constant default, empty the field, or set it fixed list.

     <br><dt><samp><code>select_field</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99999999</code>

     <p><b>Synopsis</b>: Integer index of the field required 0..n (default starts from 1)

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body field_edits example
     {
     select_field => "5";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Numbering starts from 1 (not from 0).

     <br><dt><samp><code>start_fields_from_zero</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: If set, the default field numbering starts from 0

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body edit_field col(split,col,newval,method)
     
     {
     field_separator    => "$(split)";
     select_field       => "$(col)";
     value_separator    => ",";
     field_value        => "$(newval)";
     field_operation    => "$(method)";
     extend_fields      => "true";
     allow_blank_fields => "true";
     start_fields_from_zero => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p><i>History</i>: Was introduced in version 3.1.0b1,Nova 2.0.0b1 (2010)

     <p>The numbering of fields is a matter for consistency and convention. Arrays are usually thought to start with first index equal to zero (0), but the first column in a file would normally be 1. By setting this option, you can tell CFEngine that the first column should be understood as number 0 instead, for consistency with other array functions.

     <br><dt><samp><code>value_separator</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>^.$</code>

     <p><b>Synopsis</b>: Character separator for subfields inside the selected field

     <p><b>Default value:</b> none

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body field_edit example
     {
     value_separator => ",";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>For example, elements in the group file are separated by <samp><span>:</span></samp>, but the lists of users in these fields are separated by <samp><span>,</span></samp>.

   </dl>

<div>
<a></a>
<a></a>

</div>


