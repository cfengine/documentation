<h3>7.23 <code>processes</code> promises in <samp><span>agent</span></samp></h3>

<p><br>

   <p>Process promises refer to items in the system process table. Note that this is not the same as commands (which are instructions that CFEngine will execute). A process is a command in some state of execution (with a Process Control Block). Promiser objects here are patterns that are unanchored, meaning that they match line fragments in the system process table (see <a>Anchored vs. unanchored regular expressions</a>). 

   <p><i>Take care to note that process table formats differ between operating systems, and the use of simple patterns such as program-names is recommended. For more sophisticated matches, users should use the </i><code>process_select</code><i> feature.</i> For example, on many systems, the process pattern <code>"^cp"</code> may not match any processes, even though <code>"cp"</code> is running. This is because the process table entry may list <code>"/bin/cp"</code>. However, the process pattern <code>"cp"</code> will also match a process containing <code>"scp"</code>, so take care not to oversimplify your patterns (the PCRE pattern anchors <code>"\b"</code> and <code>"\B"</code> may prove very useful to you).

   <p><table><tr><td>
<pre>     
      processes:
     
        "<var>regex contained in process line</var>"
     
            process_select = <var>process_filter_body</var>,
            restart_class = "activation class for process",
            ..;
     
</pre>
   </td></tr></table>

   <p>In CFEngine 2 there was a restart clause for directly executing a command to restart a process. In CFEngine 3 there is instead a class to activate. You must then describe a <code>command</code> in that class to restart the process.

<pre>
commands:

  restart_me::

   "/path/executable" ... ;

</pre>
This rationalizes complex restart-commands and avoids unnecessary overlap between <code>processes</code> and <code>commands</code>.

   <p>The <code>process_stop</code> is also arguably a command, but it should be an ephemeral command that does not lead to a persistent process. It is intended only for commands of the form <samp><span>/etc/inetd service stop</span></samp>, not for processes that persist. Processes are restarted at the end of a bundle's execution, but stop commands are executed immediately.

   <p>Note: <code>process_select</code> was previously called process <code>filters</code> in CFEngine 2 and earlier.

   <p><br>

<pre>
bundle agent example
{
processes:

 ".*"

    process_count   => anyprocs,
    process_select  => proc_finder;

reports:

 any_procs::

   "Found processes out of range";
}

########################################################

body process_select proc_finder

{
# Processes started between 5.5 hours and 20 minutes ago
stime_range => irange(ago(0,0,0,5,30,0),ago(0,0,0,0,20,0));
process_result => "stime";
}

########################################################

body process_count anyprocs

{
match_range => "0,0";
out_of_range_define => { "any_procs" };
}

</pre>

   <p><br>

   <p>In CFEngine 3 we have

<pre>      processes
      commands
</pre>
   <p>so that there is a clean separation between detection (promises about the process table) and certain repairs (promises to execute commands that start processes). 

   <p>Executions are about jobs, services, scripts etc. They are properties of an executable file. The referring `promiser' is a file object. On the other hand a process is a property of a "process identifier" which is a kernel instantiation, a quite different object altogether. For example:

     <ul>
<li>A "PID" (which is not an executable) promises to be reminded of a signal, e.g.
     <pre>              kill signal pid
</pre>
     <li>An "command" promises to start or stop itself with a parameterized specification.
     <pre>              exec command argument1 argument2 ...
</pre>
     </ul>
       
     
   <p>Neither the file nor the pid necessarily promise to respond to these activations, but they are nonetheless physically meaningful phenomena or attributes associated with these objects.

     <ul>
<li>Executable files do not listen for signals as they have no active state. 
<li>PIDs do not run themselves or stop themselves with new arguments, but they can use signals as they are running. 
</ul>

   <p>Executions lead to processes for the duration of their lifetime, so these two issues are related, although the promises themselves are not.

   <p><br>
<b>Services versus processes</b>:
<br>

   <p>A service is an abstraction that requires processes to run and files to be configured. It makes a lot of sense to wrap services in modular bundles. Starting and stopping a service can be handled in at least two ways. Take the web service as an example.

   <p>We can start the service by promising an execution of a daemon (e.g. <code>httpd</code>). Normally this execution does not terminate without intervention. We can terminate it in one of two ways:

     <ul>
<li>Using a process signal, by promising a signal to processes matching a certain pid search
<li>Using an execution of a termination command, e.g. <samp><span>/etc/init.d/apache stop</span></samp>. 
</ul>

   <p>The first case makes sense if we need to qualify the termination by searching for the processes. The processes section of a CFEngine 3 policy includes a control promise to search for matching processes. If matches are found, signals can be sent to precisely each specific process.

   <p>Classes can also be defined, in principle triggering an execution of the stop script, but then the class refers only to the presence of matching pids, not to the individual pids concerned. So it becomes the responsibility of the execution to locate and interact with the pids necessary.

   <p><br>

   <p>If you want to ensure that a service is running, check each in the agent control promises individually.
<pre>bundlesequence => { Update, Service("apache"), Service("nfsd") };
</pre>
or
<pre>bundlesequence => { Update, @(globals.all_services)  };
</pre>

   <p>The bundle for this can look like this:
<pre>bundle agent Service(service")
{
processes:

  "$(service)" 

      process_count => up("$(service)");

commands:

   "$daemons[$(service)]"  

      ifvarclass => "$(service)_up",
      args       => "$args[$(service)]";

}
</pre>

   <p>An alternative would be self-contained:

<pre>bundle agent Service
{
vars:

  "service" slist => { "apache", "nfsd", "bind" };

processes:

  "$(service)" 

      process_count => up("$(service)");

commands:

   "$daemons[$(service)]"  

      ifvarclass => "$(service)_up",
      args       => "$args[$(service)]";

}

######################
# Parameterized body
######################

body process_count up("$(s)")

{
match_range => "[0,10]";
out_of_range_define => "$(s)_up";
}

</pre>

<ul>
<li><a>process_count in processes</a>
<li><a>process_select in processes</a>
<li><a>process_stop in processes</a>
<li><a>restart_class in processes</a>
<li><a>signals in processes</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.23.1 <code>process_count</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>in_range_define</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of classes to define if the matches are in range

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_count example
     {
     in_range_define => { "class1", "class2" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Classes are defined if the processes that are found in the process table satisfy the promised process count, in other words if the promise about the number of processes matching the other criteria is kept.

     <br><dt><samp><code>match_range</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Integer range for acceptable number of matches for this process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_count example
     {
     match_range => irange("10","50");
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is a numerical range for the number of occurrences of the process in the process table. As long as it falls within the specified limits, the promise is considered kept.

     <br><dt><samp><code>out_of_range_define</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of classes to define if the matches are out of range

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_count example(s)
     {
     out_of_range_define => { "process_anomaly", "anomaly_$(s)"};
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Classes to activate remedial promises conditional on this promise failure to be kept.

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.23.2 <code>process_select</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>command</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression matching the command/cmd field of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     
     {
     command => "cf-.*";
     
     process_result => "command";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This expression should match the entire <code>COMMAND</code> field of the process table, not just a fragment. This field is usually the last field on the line, so it thus starts with the first non-space character and ends with the end of line.

     <br><dt><samp><code>pid</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Range of integers matching the process id of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     pid => irange("1","10");
     process_result => "pid";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>pgid</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Range of integers matching the parent group id of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     pgid => irange("1","10");
     process_result => "pgid";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>ppid</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Range of integers matching the parent process id of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     ppid => irange("407","511");
     process_result => "ppid";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>priority</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>-20,+20</code>

     <p><b>Synopsis</b>: Range of integers matching the priority field (PRI/NI) of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     priority => irange("-5","0");
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>process_owner</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: List of regexes matching the user of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     process_owner => { "wwwrun", "nobody" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Regular expression should match a legal user name on the system.  The regex is anchored, meaning it must match the entire name (see <a>Anchored vs. unanchored regular expressions</a>).

     <br><dt><samp><code>process_result</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>[(process_owner|pid|ppid||pgid|rsize|vsize|status|command|ttime|stime|tty|priority|threads)[|!.]*]*</code>

     <p><b>Synopsis</b>: Boolean class expression returning the logical combination of classes set by a process selection test

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select proc_finder(p)
     
     {
     process_owner  => { "avahi", "bin" };
     command        => "$(p)";
     pid            => irange("100","199");
     vsize          => irange("0","1000");
     process_result => "command.(process_owner|vsize).!pid";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A logical combination of the process selection classifiers. The syntax is the same as that for class expressions. There should be no spaces in the expressions.

     <br><dt><samp><code>rsize</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Range of integers matching the resident memory size of a process, in kilobytes

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select
     {
     rsize => irange("4000","8000");
     }
     
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>status</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression matching the status field of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     status => "Z";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>For instance, characters in the set <samp><span>NRSsl+..</span></samp>. Windows processes do not have status fields.

     <br><dt><samp><code>stime_range</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,2147483647</code>

     <p><b>Synopsis</b>: Range of integers matching the start time of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     stime_range => irange(ago(0,0,0,1,0,0),now);
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The calculation of time from process table entries is sensitive to Daylight Savings Time (Summer/Winter Time) so calculations could be an hour off. This is for now a bug to be fixed. 

     <br><dt><samp><code>ttime_range</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,2147483647</code>

     <p><b>Synopsis</b>: Range of integers matching the total elapsed time of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     ttime_range => irange(0,accumulated(0,1,0,0,0,0));
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This is total accumulated time for a process.

     <br><dt><samp><code>tty</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: Regular expression matching the tty field of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     tty => "pts/[0-9]+";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Windows processes are not regarded as attached to any terminal, so they all have tty '?'.

     <br><dt><samp><code>threads</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Range of integers matching the threads (NLWP) field of a process

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     threads => irange(1,5);
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <br><dt><samp><code>vsize</code></samp><dd><b>Type</b>: irange [int,int]

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Range of integers matching the virtual memory size of a process, in kilobytes

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body process_select example
     {
     vsize => irange("4000","9000");
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>On Windows, the virtual memory size is the amount of memory that cannot be shared with other processes. In Task Manager, this is called Commit Size (Windows 2008), or VM Size (Windows XP).

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>7.23.3 <code>process_stop</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: <code>"?(/.*)</code>

<p><b>Synopsis</b>: A command used to stop a running process

<p><b>Example</b>:<br>
<br>

<pre>
processes:

 "snmpd"

        process_stop => "/etc/init.d/snmp stop";


</pre>

<p><b>Notes</b>:<br>
<br>

   <p>As an alternative to sending a termination or kill signal to a process, one may call a `stop script' to perform a graceful shutdown.

<div>
<a></a>
<a></a>

</div>

<h4>7.23.4 <code>restart_class</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

<p><b>Synopsis</b>: A class to be defined globally if the process is not running, so that a command: rule can be referred to restart the process

<p><b>Example</b>:<br>
<br>

<pre>
processes:

   "cf-serverd"

     restart_class => "start_cfserverd";

commands:

  start_cfserverd::

    "/var/cfengine/bin/cf-serverd";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This is a signal to restart a process that should be running, if it is not running.  Processes are signaled first and then restarted later, at the end of bundle execution, after all possible corrective actions have been made that could influence their execution.

   <p>Windows does not support having processes start themselves in the background, like Unix daemons usually do; as fork off a child process. Therefore, it may be useful to specify an action bodypart that sets background to true in a commands promise that is invoked by the class set by restart_class. See the commands promise type for more information. 

<div>
<a></a>

</div>

<h4>7.23.5 <code>signals</code></h4>

<p><b>Type</b>: (option list)

<p><b>Allowed input range</b>: <br>
<pre>               <code>hup</code>
               <code>int</code>
               <code>trap</code>
               <code>kill</code>
               <code>pipe</code>
               <code>cont</code>
               <code>abrt</code>
               <code>stop</code>
               <code>quit</code>
               <code>term</code>
               <code>child</code>
               <code>usr1</code>
               <code>usr2</code>
               <code>bus</code>
               <code>segv</code>
</pre>
   <p><b>Synopsis</b>: A list of menu options representing signals to be sent to a process

<p><b>Example</b>:<br>
<br>

<pre>
processes:

 cfservd_out_of_control::

   "cfservd"

        signals         => { "stop" , "term" },
        restart_class   => "start_cfserv";

 any::

   "snmpd"

        signals         => { "term" , "kill" };
   
</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Signals are presented as an ordered list to the process. On Windows, only the kill signal is supported, which terminates the process.

<div>
<a></a>

</div>


