<h3>7.21 <code>outputs</code> promises in <samp><span>agent</span></samp></h3>

<p><br>

   <p>Outputs promises allow promises to make meta-promises about their output levels. More simply, you can switch on <samp><span>verbose</span></samp> or <samp><span>inform</span></samp> level output to named promises, or whole bundles for debugging purposes.

   <p>If you use the <samp><span>-I</span></samp> or <samp><span>-v</span></samp> command line options, then CFEngine will generate informative or verbose output for all the promises it is processing. This can be a daunting collection of data when dealing with even a medium-sized set of promises.

   <p>Output promises enable you to selectively debug individually named promises (or bundles), thus eliminating the need for scanning unrelated CFEngine output.

   <p><br>

<pre>
outputs:

  "run_agent";		# Promise handle, verbose (default) output

  "web_server"		# Bundle handle, inform output
     output_level => "inform",
     promiser_type => "bundle";

</pre>

   <p>A very handy paradigm is to include outputs promises in every bundle, and guard them with classes. For example:

<pre>
bundle agent some_function
{
vars:
    ...
classes:
    ...
outputs:
  debug_some_function::
      "some_function"
	 output_level => "verbose",
	 promiser_type => "bundle";
files:
    ...
}

</pre>

   <p>You can then execute your promises normally with no extra output, but should you wish to temporarily enable debugging, you can simply do so from the command line by specifying <samp><span>-D debug_some_function</span></samp>. You can also supply multiple arguments to <samp><span>-D</span></samp> to debug multiple bundles. Of course, you can also provide much finer-grained control by creating outputs promises on specific promise handles.

   <p><br>

   <p>The default behaviour is to print verbose output for listed promise handles. See <a>handle in *</a>, for bundle names.

   <p><b>History</b> This was introduced in Nova version 1.1.3 (2010), Community version 3.4.0 (2012)

<ul>
<li><a>output_level in outputs</a>
<li><a>promiser_type in outputs</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>7.21.1 <code>output_level</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>verbose</code>
               <code>debug</code>
               <code>inform</code>
</pre>
   <p><b>Default value:</b> verbose

<p><b>Synopsis</b>: Output level to observe for the named promise or bundle (meta-promise)

<p><b>Example</b>:<br>
<br>

<pre>
commands:

  "/etc/init.d/agent start"

    handle => "run_agent",
    ifvarclass => "need_to_run_agent";

outputs:

  "run_agent"

    output_level => "inform"; 

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>With no attribute, <code>verbose</code> output is assumed.

<div>
<a></a>
<a></a>

</div>

<h4>7.21.2 <code>promiser_type</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>promise</code>
               <code>bundle</code>
</pre>
   <p><b>Default value:</b> promise

<p><b>Synopsis</b>: Output level to observe for the named promise or bundle (meta-promise)

<p><b>Example</b>:<br>
<br>

<pre>
outputs:

  "web_server"

     promiser_type => "bundle";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Without this attribute, CFEngine assumes a list of promises to report on. There may be a promise for a thing that has the same name as a bundle, and you must therefore explicitly specify when you want to report on a bundle of promises.

<div>
<a></a>

</div>


