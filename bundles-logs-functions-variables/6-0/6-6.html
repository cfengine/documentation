<h3>6.6 <code>*</code> promises</h3>

<p><br>

   <p>Whereas most promise types are specific to a particular kind of interpretation that requires a typed interpreter (the bundle type), a number of promises can be made in any kind of bundle since they are of a generic input/output nature. These are <code>vars</code>, <code>classes</code>, and <code>reports</code> promises.  The specific promise attributes are listed below.

<ul>
<li><a>action in *</a>
<li><a>classes in *</a>
<li><a>comment in *</a>
<li><a>depends_on in *</a>
<li><a>handle in *</a>
<li><a>ifvarclass in *</a>
<li><a>meta in *</a>
</ul>

<div>
<a></a>
<a></a>

</div>

<h4>6.6.1 <code>action</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>action_policy</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>fix</code>
                    <code>warn</code>
                    <code>nop</code>
</pre>
     <p><b>Synopsis</b>: Whether to repair or report about non-kept promises

     <p><b>Example</b>:<br>
<br>

     <p>The following example shows a simple use of transaction control, causing the promise to be verified as a separate background process.

     <pre>     
     body action background
     
     {
     action_policy => "warn";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The <code>action</code> settings allow general transaction control to be implemented on promise verification. Action bodies place limits on how
often to verify the promise and what classes to raise in the case that the promise can or cannot be kept.

     <p>Note that actions can be added to sub-bundles like methods and editing bundles, and that promises within these do not inherit action settings
at higher levels. Thus, in the following example there are two levels of action setting:

     <pre>     ########################################################
     #
     # Warn if line matched
     #
     ########################################################
     
     body common control
     
     {
     bundlesequence  => { "testbundle" };
     }
     
     ########################################################
     
     bundle agent testbundle
     
     {
     files:
     
       "/var/cfengine/inputs/.*"
     
            edit_line => DeleteLinesMatching(".*cfenvd.*"),
            action => WarnOnly;
     }
     
     ########################################################
     
     bundle edit_line DeleteLinesMatching(regex)
       {
       delete_lines:
     
         "$(regex)" action => WarnOnly;
     
       }
     
     ########################################################
     
     body action WarnOnly
     {
     action_policy => "warn";
     }
</pre>

     <p>The <code>action</code> setting for the <code>files</code> promise means that file edits will not be committed to disk, only warned about. This is a master-level promise that overrides anything that happens during the editing. The <code>action</code> setting for the edit bundle means that the internal memory modeling of the file will only warn about changes rather than committing them to the memory model. This makes little difference to the
end result, but it means that CFEngine will report

     <pre>          Need to delete line - ... - but only a warning was promised
</pre>
     <p>Instead of

     <pre>          Deleting the promised line ... Need to save file - but only a warning was promised
</pre>
     <p>In either case, no changes will be made to the disk, but the messages given by <code>cf-agent</code> will differ.

     <br><dt><samp><code>ifelapsed</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Number of minutes before next allowed assessment of promise

     <p><b>Default value:</b> control body value

     <p><b>Example</b>:<br>
<br>

     <pre>     
     #local
     
     body action example
     {
     ifelapsed   => "120";	# 2 hours
     expireafter => "240";	# 4 hours
     }
     
     # global
     
     body agent control
     {
     ifelapsed   => "180";	# 3 hours
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This overrides the global settings. Promises which take a long time to verify should usually be protected with a long value for this
parameter.  This serves as a resource `spam' protection. A CFEngine check could easily run every 5 minutes provided resource intensive
operations are not performed on every run. Using time classes such as <code>Hr12</code> is one part of this strategy; using <code>ifelapsed</code>
is another, which is not tied to a specific time.

     <br><dt><samp><code>expireafter</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: Number of minutes before a repair action is interrupted and retried

     <p><b>Default value:</b> control body value

     <p><b>Example</b>:<br>
<br>

     <pre>     body action example
     {
     ifelapsed   => "120";	# 2 hours
     expireafter => "240";	# 4 hours
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>The locking time after which CFEngine will attempt to kill and restart its attempt to keep a promise.

     <br><dt><samp><code>log_string</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: A message to be written to the log when a promise verification leads to a repair

     <p><b>Example</b>:<br>
<br>

     <pre>          
          <var>promise-type</var>:
          
           "promiser"
          
             attr = "value",
             action = log_me("checked $(this.promiser) in promise $(this.handle)");
          
          # ..
          
          body action log_me(s)
          {
          log_string = "$(s)";
          }
          
</pre>
     <p><b>Notes</b>:<br>
<br>

     <p>The <code>log_string</code> works together with <code>log_repair</code>, <code>log_kept</code> etc, to define a string for logging to one of the named files depending on promise outcome, or to standard output if the log file is stipulated as <samp><span>stdout</span></samp>. Log strings on standard output are denoted by an <samp><span>L:</span></samp> prefix.

     <p>Note that <code>log_string</code> does not interact with <code>log_level</code>, which is about regular system output messages.

     <p>Hint: the promise handle <samp><span>$(this.handle)</span></samp> can be a useful referent in a log message, indicating the origin of the message. In CFEngine Nova and above, every promise has a default handle, which is based on the filename and line number (specifying your own handle will probably be more mnemonic).

     <br><dt><samp><code>log_level</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>inform</code>
                    <code>verbose</code>
                    <code>error</code>
                    <code>log</code>
</pre>
     <p><b>Synopsis</b>: The reporting level sent to syslog

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action example
     {
     log_level => "inform";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>Use this as an alternative to auditing if you wish to use the syslog mechanism to centralize or manage messaging from CFEngine. A backup of these messages will still be kept in <samp><span>WORKDIR/outputs</span></samp> if you are using <code>cf-execd</code>.

     <p>On the native Windows version of CFEngine (Nova or above), using <samp><span>verbose</span></samp> will include a message when the promise is kept or repaired in the event log.

     <br><dt><samp><code>log_kept</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>stdout|udp_syslog|("?[a-zA-Z]:\\.*)|(/.*)</code>

     <p><b>Synopsis</b>: This should be the filename of a file to which log_string will be saved, and if undefined it goes to the system logger

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action logme(x)
     {
     log_kept => "/tmp/private_keptlog.log";
     log_failed => "/tmp/private_faillog.log";
     log_repaired => "/tmp/private_replog.log";
     log_string => "$(sys.date) $(x) promise status";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If this option is specified together with <code>log_string</code>, the current promise will log promise-kept status using the log string to
this named file. If these log names are absent, the default logging destination for the log string is syslog, but only for non-kept promises. Only the <code>log_string</code> is affected by this setting. Other messages destined for logging are sent to syslog.

     <p>It is intended that named file logs should be different for the three cases: promise kept, promise not kept and promise repaired.

     <p>This string should be the full path to a text file which will contain the log, of one of the following special values:

          <dl>
<dt><samp><span>stdout</span></samp><dd>Send the log message to the standard output, prefixed with an <samp><span>L:</span></samp> to indicate a log message. 
<br><dt><samp><span>udp_syslog</span></samp><dd>Attempt to connect to the <code>syslog_server</code> defined in <samp><span>body common control</span></samp> and log the message there, assuming the server is configured to receive the request. 
</dl>

     <br><dt><samp><code>log_priority</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>emergency</code>
                    <code>alert</code>
                    <code>critical</code>
                    <code>error</code>
                    <code>warning</code>
                    <code>notice</code>
                    <code>info</code>
                    <code>debug</code>
</pre>
     <p><b>Synopsis</b>: The priority level of the log message, as interpreted by a syslog server

     <p><b>Example</b>:<br>
<br>

     <pre>     body action low_priority
     {
     log_priority => "info";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This determines the importance of messages from CFEngine.

     <br><dt><samp><code>log_repaired</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>stdout|udp_syslog|("?[a-zA-Z]:\\.*)|(/.*)</code>

     <p><b>Synopsis</b>: This should be filename of a file to which log_string will be saved, if undefined it goes to the system logger

     <p><b>Example</b>:<br>
<br>

     <pre>     
     bundle agent test
     {
     vars:
     
       "software" slist => { "/root/xyz", "/tmp/xyz" };
     
     files:
     
       "$(software)"
     
         create => "true",
          action => logme("$(software)");
     
     }
     
     body action logme(x)
     {
     log_kept => "/tmp/private_keptlog.log";
     log_failed => "/tmp/private_faillog.log";
     log_repaired => "/tmp/private_replog.log";
     log_string => "$(sys.date) $(x) promise status";
     }
     
     body action immediate_syslog(x) 
     {
     log_repaired => "udp_syslog"; # Nova and above 
     log_string => "CFEngine repaired promise $(this.handle) - $(x)";
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This may be the name of a log to which the <code>log_string</code> is written if a promise is repaired. It should be the full path to a text file which will contain the log, of one of the following special values: 

          <dl>
<dt><samp><span>stdout</span></samp><dd>Send the log message to the standard output, prefixed with an <samp><span>L:</span></samp> to indicate a log message. 
<br><dt><samp><span>udp_syslog</span></samp><dd>Attempt to connect to the <code>syslog_server</code> defined in <samp><span>body common control</span></samp> and log the message there,
assuming the server is configured to receive the request. 
</dl>

     <br><dt><samp><code>log_failed</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: <code>stdout|udp_syslog|("?[a-zA-Z]:\\.*)|(/.*)</code>

     <p><b>Synopsis</b>: This should be the filename of a file to which log_string will be saved, and if undefined it goes to the system logger

     <p><b>Example</b>:<br>
<br>

     <pre>     
     bundle agent test
     {
     vars:
     
       "software" slist => { "/root/xyz", "/tmp/xyz" };
     
     files:
     
       "$(software)"
     
         create => "true",
          action => logme("$(software)");
     
     }
     
     
     body action logme(x)
     {
     log_kept => "/tmp/private_keptlog.log";
     log_failed => "/tmp/private_faillog.log";
     log_repaired => "/tmp/private_replog.log";
     log_string => "$(sys.date) $(x) promise status";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If this option is specified together with <code>log_string</code>, the current promise will log promise-kept status using the log string to
this named file. If these log names are absent, the default logging destination for the log string is syslog, but only for non-kept promises. Only the <code>log_string</code> is affected by this setting. Other messages destined for logging are sent to syslog.

     <p>It is intended that named file logs should be different for the three cases: promise kept, promise not kept and promise repaired. This string should be the full path to a text file which will contain the log, of one of the following special values: 

          <dl>
<dt><samp><span>stdout</span></samp><dd>Send the log message to the standard output, prefixed with an <samp><span>L:</span></samp> to indicate a log message. 
<br><dt><samp><span>udp_syslog</span></samp><dd>Attempt to connect to the <code>syslog_server</code> defined in <samp><span>body common control</span></samp> and log the message there,
assuming the server is configured to receive the request. 
</dl>

     <br><dt><samp><code>value_kept</code></samp><dd><b>Type</b>: real

     <p><b>Allowed input range</b>: <code>-9.99999E100,9.99999E100</code>

     <p><b>Synopsis</b>: A real number value attributed to keeping this promise

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action mydef
     {
     value_kept     => "4.5";   # this promise is worth 4.5 dollars per hour
     value_repaired => "2.5";   # fixing this promise is worth 2.5 dollars per hour
     value_notkept  => "-10.0"; # not keeping this promise costs is 10 dollars per hour
     ifelapsed       => "60";   # one hour
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If nothing is specified, the default value is +1.0. However, nothing is logged unless the agent control body switched on <samp><span>track_value = "true"</span></samp>.

     <br><dt><samp><code>value_repaired</code></samp><dd><b>Type</b>: real

     <p><b>Allowed input range</b>: <code>-9.99999E100,9.99999E100</code>

     <p><b>Synopsis</b>: A real number value attributed to repairing this promise

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action mydef
     {
     value_kept     => "4.5";   # this promise is worth 4.5 dollars per hour
     value_repaired => "2.5";   # fixing this promise is worth 2.5 dollars per hour
     value_notkept  => "-10.0"; # not keeping this promise costs is 10 dollars per hour
     ifelapsed       => "60";   # one hour
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If nothing is specified, the default value is 0.5. However, nothing is logged unless the agent control body switched on <samp><span>track_value = "true"</span></samp>.

     <br><dt><samp><code>value_notkept</code></samp><dd><b>Type</b>: real

     <p><b>Allowed input range</b>: <code>-9.99999E100,9.99999E100</code>

     <p><b>Synopsis</b>: A real number value (possibly negative) attributed to not keeping this promise

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action mydef
     {
     value_kept     => "4.5";   # this promise is worth 4.5 dollars per hour
     value_repaired => "2.5";   # fixing this promise is worth 2.5 dollars per hour
     value_notkept  => "-10.0"; # not keeping this promise costs is 10 dollars per hour
     ifelapsed       => "60";   # one hour
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If nothing is specified, the default value is -1.0. However, nothing is logged unless the agent control body switched on <samp><span>track_value = "true"</span></samp>.

     <br><dt><samp><code>audit</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false switch for detailed audit records of this promise

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action example
     {
     # ...
     
     audit => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If this is set, CFEngine will perform auditing on this specific promise. This means that all details surrounding the verification of the current promise will be recorded in the audit database. The database may be inspected with <code>cf-report</code>, or <code>cfshow</code> in CFEngine 2. 

     <br><dt><samp><code>background</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>true</code>
                    <code>false</code>
                    <code>yes</code>
                    <code>no</code>
                    <code>on</code>
                    <code>off</code>
</pre>
     <p><b>Synopsis</b>: true/false switch for parallelizing the promise repair

     <p><b>Default value:</b> false

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action example
     {
     background => "true";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If possible, perform the verification of the current promise in the background. This is advantageous only if the verification might take a significant amount of time, e.g. in remote copying of filesystem/disk scans.

     <p>On the windows version of CFEngine Nova, this can be useful if we don't want to wait for a particular command to finish execution before
checking the next promise. This is particular for the Windows platform because there is no way that a program can start itself in the background here; in other words, fork off a child process. However, file operations can not be performed in the background on windows.

     <br><dt><samp><code>report_level</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>inform</code>
                    <code>verbose</code>
                    <code>error</code>
                    <code>log</code>
</pre>
     <p><b>Synopsis</b>: The reporting level for standard output for this promise

     <p><b>Default value:</b> none

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body action example
     {
     report_level => "verbose";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>cf-agent can be run in verbose mode (-v), inform mode (-I) and just print errors (no arguments). This attribute allows to set these three output levels on a per promise basis, allowing the promise to be more verbose than the global setting (but not less).

     <p>In CFEngine 2 one would say <samp><span>inform=true</span></samp> or <samp><span>syslog=true</span></samp>, and so on. This replaces these levels since they act as encapsulating super-sets. 

     <br><dt><samp><code>measurement_class</code></samp><dd><b>Type</b>: string

     <p><b>Allowed input range</b>: (arbitrary string)

     <p><b>Synopsis</b>: If set performance will be measured and recorded under this identifier

     <p><b>Example</b>:<br>
<br>

     <pre>     
     
     body action measure
     {
     measurement_class => "$(this.promiser) long job scan of /usr";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>By setting this string you switch on performance measurement for the current promise, and also give the measurement a name. The identifier forms a partial identity for optional performance scanning of promises of the form:

     <pre>          <var>ID:promise-type:promiser</var>.
</pre>
     <p>These can be seen identifying  using <code>cf-report</code>, for example in the generated file <samp><span>performance.html</span></samp>. 



   </dl>

<div>
<a></a>
<a></a>


</div>

<h4>6.6.2 <code>classes</code> (body template)</h4>

<p><b>Type</b>: (ext body)

     <dl>
<dt><samp><code>promise_repaired</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be defined globally

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     promise_repaired => { "change_happened" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If a promise is `repaired' it means that a corrective action had to be taken to keep the promise.

     <p>Note that any strings passed to this list are automatically canonified, so it is unnecessary to call a canonify function on such inputs.

     <p>Important: complex promises can report misleadingly; for example, <code>files</code> promises that set multiple parameters on a file simultaneously. 
     
     <p>The classes for different parts of a promise are not separable. Thus, if you promise to create and file and change its permissions, when the file exists with incorrect permissions, <code>cf-agent</code> will report that the <samp><span>promise_kept</span></samp> for the file existence, but <samp><span>promise_repaired</span></samp> for the permissions. If you need separate reports, you should code two separate promises rather than `overloading' a single one. 

     <br><dt><samp><code>repair_failed</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be defined globally

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     repair_failed => { "unknown_error" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A promise could not be repaired because the corrective action failed for some reason.

     <p>Any strings passed to this list are automatically canonified, so it is unnecessary to call a canonify function on such inputs.

     <br><dt><samp><code>repair_denied</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be defined globally

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     repair_denied => { "permission_failure" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A promise could not be kept because access to a key resource was denied.

     <p>Note that any strings passed to this list are automatically canonified, so it is unnecessary to call a canonify function on such inputs.

     <br><dt><samp><code>repair_timeout</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be defined globally

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     repair_timeout => { "too_slow", "did_not_wait" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A promise maintenance repair timed-out waiting for some dependent resource.

     <br><dt><samp><code>promise_kept</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be defined globally

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     promise_kept => { "success", "kaplah" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>This class is set if no action was necessary by <code>cf-agent</code> because the promise concerned was already kept without further action
required.

     <p>Note that any strings passed to this list are automatically canonified, so it is unnecessary to call a canonify function on such inputs.

     <p>Important: complex promises can report misleadingly; for example <code>files</code> promises that set multiple parameters on a file simultaneously . 

     <p>The classes for different parts of a promise are not separable. Thus, if you promise to create and file and change its permissions, when the file exists with incorrect permissions, <code>cf-agent</code> will report that the <samp><span>promise_kept</span></samp> for the file existence, but <samp><span>promise_repaired</span></samp> for the permissions. If you need separate reports, you should code two separate promises rather than `overloading' a single one.

     <br><dt><samp><code>cancel_kept</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be canceled if the promise is kept

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     cancel_kept => { "success", "kaplah" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If the promise was already kept and nothing was done, cancel (undefine) any of the listed classes so that they are no longer defined.

     <p>Note that any strings passed to this list are automatically canonified, so it is unnecessary to call a canonify function on such inputs.

     <p><b>History</b>: This attribute was introduced in CFEngine version 3.0.4 (2010)

     <br><dt><samp><code>cancel_repaired</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be canceled if the promise is repaired

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     cancel_repaired => { "change_happened" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If the promise was repaired and changes were made to the system,
cancel (undefine) any of the listed classes so that they are no longer defined.

     <p>Note that any strings passed to this list are automatically canonified, so it is unnecessary to call a canonify function on such inputs.

     <p><b>History</b>: This attribute was introduced in CFEngine version 3.0.4 (2010)

     <br><dt><samp><code>cancel_notkept</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[a-zA-Z0-9_$(){}\[\].:]+</code>

     <p><b>Synopsis</b>: A list of classes to be canceled if the promise is not kept for any reason

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     cancel_notkept => { "failure" };
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>If the promise was not kept but nothing could be done, cancel (undefine) any of the listed classes so that they are no longer defined.

     <p>Note that any strings passed to this list are automatically canonified, so it is unnecessary to call a canonify function on such inputs.

     <p><b>History</b>: This attribute was introduced in CFEngine version 3.0.4 (2010)

     <br><dt><samp><code>kept_returncodes</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[-0-9_$(){}\[\].]+</code>

     <p><b>Synopsis</b>: A list of return codes indicating a kept command-related promise

     <p><b>Example</b>:<br>
<br>
<pre>     bundle agent cmdtest
     {
     commands:
       "/bin/false"
        classes => example;
     
     reports:
     waskept::
       "The command-promise was kept!";
     }
     
     body classes example
     {
     kept_returncodes => { "0", "1" };
     promise_kept => { "waskept" };
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A list of integer return codes indicating that a command-related promise has been kept. This can in turn be used to define classes
using the <code>promise_kept</code> attribute, or merely alter the total compliance statistics.

     <p>Currently, the attribute has impact on the following command-related promises.

          <ul>
<li>All promises of type <code>commands:</code>
<li><code>files</code>-promises containing a <code>transformer</code>-attribute
<li>The package manager change command in <code>packages</code>-promises
(e.g. the command for add, remove, etc.) 
</ul>

     <p>If none of the attributes <code>kept_returncodes</code>, <code>repaired_returncodes</code>, or <code>failed_returncodes</code> are set, the default is to consider a return code zero as promise repaired, and nonzero as promise failed.

     <p>Note that the return codes may overlap, so multiple classes may be set from one return code. In Unix systems the possible return codes are usually in the range from 0 to 255.

     <p><i>History</i>: Was introduced in version 3.1.3, Nova 2.0.2 (2010)

     <br><dt><samp><code>repaired_returncodes</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[-0-9_$(){}\[\].]+</code>

     <p><b>Synopsis</b>: A list of return codes indicating a repaired command-related promise

     <p><b>Example</b>:<br>
<br>
<pre>     bundle agent cmdtest
     {
     commands:
       "/bin/false"
        classes => example;
     
     reports:
     wasrepaired::
       "The command-promise got repaired!";
     }
     
     body classes example
     {
     repaired_returncodes => { "0", "1" };
     promise_repaired => { "wasrepaired" };
     }
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A list of integer return codes indicating that a command-related promise has been repaired. This can in turn be used to define classes using the <code>promise_repaired</code> attribute, or merely alter the total compliance statistics.

     <p>Currently, the attribute has impact on the following command-related promises.

          <ul>
<li>All promises of type <code>commands:</code>
<li><code>files</code>-promises containing a <code>transformer</code>-attribute
<li>The package manager change command in <code>packages</code>-promises (e.g. the command for add, remove, etc.) 
</ul>

     <p>If none of the attributes <code>kept_returncodes</code>, <code>repaired_returncodes</code>, or <code>failed_returncodes</code> are set, the default is to consider a return code zero as promise repaired, and nonzero as promise failed.

     <p>Note that the return codes may overlap, so multiple classes may be set from one return code. In Unix systems the possible return codes are usually in the range from 0 to 255.

     <p><i>History</i>: Was introduced in version 3.1.3, Nova 2.0.2 (2010)

     <br><dt><samp><code>failed_returncodes</code></samp><dd><b>Type</b>: slist

     <p><b>Allowed input range</b>: <code>[-0-9_$(){}\[\].]+</code>

     <p><b>Synopsis</b>: A list of return codes indicating a failed command-related promise

     <p><b>Example</b>:<br>
<br>
<pre>     body common control
     {
     bundlesequence => { "cmdtest" };
     }
     
     bundle agent cmdtest
     {
     files:
     "/tmp/test"
       copy_from => copy("/etc/passwd");
     
     
     "/tmp/test"
       classes => example,
       transformer => "/bin/grep -q lkajfo999999 $(this.promiser)";
     
     reports:
     wasfailed::
       "The files-promise failed!";
     }
     
     body classes example
     {
     failed_returncodes => { "1" };
     repair_failed => { "wasfailed" };
     }
     
     body copy_from copy(file)
     {
     source => "$(file)";
     } 
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>A list of integer return codes indicating that a command-related promise has failed. This can in turn be used to define classes using the <code>promise_repaired</code> attribute, or merely alter the total compliance statistics.

     <p>Currently, the attribute has impact on the following command-related promises.

          <ul>
<li>All promises of type <code>commands:</code>
<li><code>files</code>-promises containing a <code>transformer</code>-attribute
<li>The package manager change command in <code>packages</code>-promises
(e.g. the command for add, remove, etc.) 
</ul>

     <p>If none of the attributes <code>kept_returncodes</code>, <code>repaired_returncodes</code>, or <code>failed_returncodes</code> are set, the default is to consider a return code zero as promise repaired, and nonzero as promise failed.

     <p>Note that the return codes may overlap, so multiple classes may be set from one return code. In Unix systems the possible return codes are usually in the range from 0 to 255.

     <p><i>History</i>: Was introduced in version 3.1.3, Nova 2.0.2 (2010)

     <br><dt><samp><code>persist_time</code></samp><dd><b>Type</b>: int

     <p><b>Allowed input range</b>: <code>0,99999999999</code>

     <p><b>Synopsis</b>: A number of minutes the specified classes should remain active

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     persist_time => "10";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>By default classes are ephemeral entities that disappear when <code>cf-agent</code> terminates. By setting a persistence time, they can last even when the agent is not running.

     <br><dt><samp><code>timer_policy</code></samp><dd><b>Type</b>: (menu option)

     <p><b>Allowed input range</b>: <br>
     <pre>                    <code>absolute</code>
                    <code>reset</code>
</pre>
     <p><b>Synopsis</b>: Whether a persistent class restarts its counter when rediscovered

     <p><b>Default value:</b> reset

     <p><b>Example</b>:<br>
<br>

     <pre>     
     body classes example
     {
     timer_policy => "reset";
     }
     
</pre>

     <p><b>Notes</b>:<br>
<br>

     <p>In most cases resetting a timer will give a more honest appraisal of which classes are currently important, but if we want to activate a response of limited duration as a rare event then an absolute time limit is useful.

   </dl>

<div>
<a></a>
<a></a>

</div>

<h4>6.6.3 <code>comment</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: A comment about the real intention of the promise

<p><b>Example</b>:<br>
<br>

<pre>
comment => "This comment follows the data for reference ...",
</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Comments written in code follow the program, they are not merely discarded. They appear in reports and error messages.

<div>
<a></a>
<a></a>

</div>

<h4>6.6.4 <code>depends_on</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: A list of promise handles that this promise builds on or depends on somehow

<p><b>Example</b>:<br>
<br>

<pre>
body common control
{
bundlesequence => { "one"  };
}

bundle agent one
{
reports:

 cfengine_3::

   "two"
     depends_on => { "handle_one" };

   "one"
     handle => "handle_one";

}


</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This is a list of promise handles for whom this promise is a promisee. In other words, we acknowledge that this promise will be affected by the list of promises whose handles are specified. It has the effect of partially ordering promises.

   <p>As of version 3.4.0, this feature is active and may be considered short-hand for setting classes. If one promise depends on a list of others, it will not be verified unless the dependent promises have already been verified and kept: in other words, as long as the dependent promises are either kept or repaired the dependee can be verified.

   <p>Handles in other namespaces may be referred to by <var>namespace:handle</var>.

<div>
<a></a>
<a></a>

</div>

<h4>6.6.5 <code>handle</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: A unique id-tag string for referring to this as a promisee elsewhere

<p><b>Example</b>:<br>
<br>

<pre>
access:

  "/source"

    handle  => "update_rule",
    admit   => { "127.0.0.1" };

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>A promise handle is like a `goto' label. It allows you to refer to a promise as the promisee of <code>depends_on</code> client of another promise. Handles are essential for mapping dependencies and performing impact analyses. In Enterprise versions of CFEngine, promise handles can also be used in <code>outputs</code> promises, See <a>outputs in agent promises</a>.

   <p>Handles may consist of regular identifier characters. CFEngine automatically `canonifies' the names of handles to conform to this standard. 
   
   <p>Caution: If the handle name is based on a variable, and the variable fails to expand, the handle will be based on the name of the variable rather than its content.

<div>
<a></a>
<a></a>

</div>

<h4>6.6.6 <code>ifvarclass</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: Extended classes ANDed with context

<p><b>Example</b>:<br>
<br>

   <p>The generic example has the form:
<pre>     
     <var>promise-type</var>:
     
       "<var>promiser</var>"
     
         ifvarclass = "$(program)_running|($(program)_notfoundHr12)";
     
</pre>
   <p>A specific example would be:

<pre>
bundle agent example

{     
commands:

 any::

    "/bin/echo This is linux"

       ifvarclass => "linux";


    "/bin/echo This is solaris"

       ifvarclass => "solaris";

}

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This is an additional class expression that will be evaluated after the <samp><var>class</var><span>::</span></samp> classes have selected promises. It is provided in order to enable a channel between variables and classes. 

   <p>The result is thus the logical AND of the ordinary classes and the variable classes.

   <p>This function is provided so that one can form expressions that link variables and classes. For example:

<pre># Check that all components are running

vars:

  "component" slist => { "cf-monitord", "cf-serverd" };

processes:

  "$(component)" restart_class => canonify("start_$(component)");

commands:

   "/var/cfengine/bin/$(component)"

       ifvarclass => canonify("start_$(component)");

</pre>

   <p>Notice that the function <code>canonify()</code> is provided to convert a general variable input into a string composed only of legal characters, using the same algorithm that CFEngine uses.

<div>
<a></a>
<a></a>

</div>

<h4>6.6.7 <code>meta</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: User-data associated with policy, e.g. key=value strings

<p><b>Example</b>:<br>
<br>

<pre>
files:

  "/etc/special_file"

    comment => "Special file is a requirement. Talk to Fred X.",
    create => "true",

    meta => { "owner=John",  "version=2.0" };

</pre>

<p><b>Notes</b>:<br>
<br>

   <p><i>History</i>: Was introduced in 3.3.0, Nova 2.2.0 (2012)

   <p>It is sometimes convenient to attach meta-data of a more technical nature to policy. It may be used for arbitrary key=value strings for example.






<div>
<a></a>

</div>


