<h3>6.1 <code>classes</code> promises in <samp><span>*</span></samp></h3>

<p><br>

   <p>Classes promises refer to the classification of different run-contexts.  These are not related to object oriented classes, but are more like tag labels representing different properties of the
environment.

   <p>Note: The words class and context are sometimes used interchangeably.

   <p><br>

<pre>
bundle common g
{
classes:

  "one" expression => "any";

  "client_network" expression => iprange("128.39.89.0/24");
}

</pre>

   <p><br>

   <p>Classes promises may be made in any bundle. In other words, bundles that pertain to any agent. 
   <p>Classes that are defined in common bundles are global in scope, while classes in all other bundles are local.

<ul>
<li><a>and in classes</a>
<li><a>dist in classes</a>
<li><a>expression in classes</a>
<li><a>or in classes</a>
<li><a>persistence in classes</a>
<li><a>not in classes</a>
<li><a>select_class in classes</a>
<li><a>xor in classes</a>
</ul>

<div>
<a></a>

</div>

<h4>6.1.1 <code>and</code></h4>

<p><b>Type</b>: clist

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_!@@$|.()\[\]{}:]+</code>

<p><b>Synopsis</b>: Combine class sources with AND

<p><b>Example</b>:<br>
<br>

<pre>
classes:

  "compound_class" and => { classmatch("host[0-9].*"), "Monday", "Hr02" };

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>If an expression contains a mixture of different object types that need to be ANDed together, this list form is more convenient than providing an expression. If all of the class expressions listed on the right-hand side match, then the class on the left-hand side is defined. 

<div>
<a></a>

</div>

<h4>6.1.2 <code>dist</code></h4>

<p><b>Type</b>: rlist

<p><b>Allowed input range</b>: <code>-9.99999E100,9.99999E100</code>

<p><b>Synopsis</b>: Generate a probabilistic class distribution (from strategies in CFEngine 2)

<p><b>Example</b>:<br>
<br>

<pre>
classes:

  "my_dist"  

    dist => { "10", "20", "40", "50" };

</pre>

<p><b>Notes</b>:<br>
<br>



   <p>Assign one generic class (always) and one additional class, randomly weighted on a probability distribution.  The sum of <code>10+20+40+50 = 120</code> in the example above, so in generating a distribution, CFEngine picks a number between <code>1-120</code>. This will generate the following classes:

<pre>     my_dist    (always)
     my_dist_10 (10/120 of the time)
     my_dist_20 (20/120 of the time)
     my_dist_40 (40/120 of the time)
     my_dist_50 (50/120 of the time)
</pre>
   <p>This was previous called a <samp><span>strategy</span></samp> in CFEngine 2.

<div>
<a></a>

</div>

<h4>6.1.3 <code>expression</code></h4>

<p><b>Type</b>: class

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_!@@$|.()\[\]{}:]+</code>

<p><b>Synopsis</b>: Evaluate string expression of classes in normal form

<p><b>Example</b>:<br>
<br>
<pre>
classes:

  "class_name" expression => "solaris|(linux.specialclass)";
  "has_toor"   expression => userexists("toor");

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>A way of aliasing class combinations.

<div>
<a></a>

</div>

<h4>6.1.4 <code>or</code></h4>

<p><b>Type</b>: clist

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_!@@$|.()\[\]{}:]+</code>

<p><b>Synopsis</b>: Combine class sources with inclusive OR

<p><b>Example</b>:<br>
<br>

<pre>
classes:

    "compound_test" 

      or => { classmatch("linux_x86_64_2_6_22.*"), "suse_10_3" };

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>The class on the left-hand side will be defined if any one (or more) of the class expressions on the right-hand side are true. This is useful construction for writing expressions that contain special functions.

<div>
<a></a>

</div>

<h4>6.1.5 <code>persistence</code></h4>

<p><b>Type</b>: int

<p><b>Allowed input range</b>: <code>0,99999999999</code>

<p><b>Synopsis</b>: Make the class persistent (cached) to avoid reevaluation, time in minutes

<p><b>Example</b>:<br>
<br>

<pre>bundle common setclasses
{
classes:

  "cached_classes" 
                or => { "any" },
       persistence => "1";

  "cached_class" 
       expression => "any",
       persistence => "1";

}
</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This feature can be used to avoid recomputing expensive classes calculations on each invocation, if a class discovered is essentially constant or only slowly varying. For example, a hostname or alias from a non-standard naming facility)

   <p>For example, to create a conditional inclusion of costly class definitions, put them into a separate bundle in a file <samp><span>classes.cf</span></samp>.
<pre># promises.cf

body common control 
{
cached_classes::
  bundlesequence => { "test" };

!cached_classes::
  bundlesequence => {  "setclasses", "test" };

!cached_classes::
  inputs => { "classes.cf" };
}
 

bundle agent test
{
reports:

  !my_cached_class::
   "no cached class";

  my_cached_class::
    "cached class defined";
}
 
</pre>
Then create <samp><span>classes.cf</span></samp>
<pre># classes.cf

bundle common setclasses
{
classes:

  "cached_classes"            # timer flag 
         expression => "any",
        persistence => "480";

  "my_cached_class" 
                or => { ...long list or heavy function... } ,
       persistence => "480";

}

</pre>

<div>
<a></a>

</div>

<h4>6.1.6 <code>not</code></h4>

<p><b>Type</b>: class

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_!@@$|.()\[\]{}:]+</code>

<p><b>Synopsis</b>: Evaluate the negation of string expression in normal form

<p><b>Example</b>:<br>
<br>

<pre>
classes:

   "others"  not => "linux|solaris";
   "no_toor" not => userexists("toor");

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This negates the effect of the promiser-pattern regular expression.  The class on the left-hand side will only be defined if the class expression on the right-hand side is false.

<div>
<a></a>
<a></a>

</div>

<h4>6.1.7 <code>select_class</code></h4>

<p><b>Type</b>: clist

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_!@@$|.()\[\]{}:]+</code>

<p><b>Default value:</b> random_selection

<p><b>Synopsis</b>: Select one of the named list of classes to define based on host identity

<p><b>Example</b>:<br>
<br>

<pre>bundle common g
{
classes:
  "selection" select_class => { "one", "two" };

reports:
  one::
    "One was selected";
  two::
    "Two was selected";
  selection::
     "A selection was made";
}
</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This feature is similar to the <code>splayclass</code> function. However, instead of selecting a class for a moment in time, it always chooses one class in the list; the same class each time for a given host. This allows hosts to be distributed across a controlled list of classes (e.g for load balancing purposes).

   <p>The class is chosen deterministically (not randomly) but it is not possible to say which host will end up in which class in advance. Only that hosts will always end up in the same class every time. 

<div>
<a></a>

</div>

<h4>6.1.8 <code>xor</code></h4>

<p><b>Type</b>: clist

<p><b>Allowed input range</b>: <code>[a-zA-Z0-9_!@@$|.()\[\]{}:]+</code>

<p><b>Synopsis</b>: Combine class sources with XOR

<p><b>Example</b>:<br>
<br>

<pre>
classes:

 "another_global" xor => { "any", "linux", "solaris"};

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>This behaves as the XOR operation on class expressions. It can be used to define a class if exactly one of the class expressions on the right-hand side matches.

<div>
<a></a>

</div>


