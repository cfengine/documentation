<h3>6.5 <code>vars</code> promises in <samp><span>*</span></samp></h3>

<p><br>

   <p>Variables in CFEngine are defined as promises that an identifier represents a particular value. Variables in CFEngine are dynamically typed as strings, integers and real numbers. Lists of these types are also possible.

   <p>Arrays are <code>associative</code> and use square brackets <samp><span>[]</span></samp> to enclose an arbitrary key. 

   <p><br>

<pre>
bundle agent example

{     
vars:

  "scalar1" string => "SCALAR 1";
  "list1" slist => { "LIST1_1", "LIST1_2" } ;
  "array[1]" string => "ARRAY 1";
  "array[2]" string => "ARRAY 2";

  "i" slist => getindices("array");

reports:

  cfengine_3::

    "Scalar $(scalar1)";
    "List $(list1)";
    "Array $(array[$(i)])";
}


</pre>

   <p><br>

<ul>
<li><a>string in vars</a>
<li><a>int in vars</a>
<li><a>real in vars</a>
<li><a>slist in vars</a>
<li><a>ilist in vars</a>
<li><a>rlist in vars</a>
<li><a>policy in vars</a>
</ul>

<div>
<a></a>

</div>

<h4>6.5.1 <code>string</code></h4>

<p><b>Type</b>: string

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: A scalar string

<p><b>Example</b>:<br>
<br>

<pre>
vars:

 "xxx"    string => "Some literal string...";

 "yyy"    string => readfile( "/home/mark/tmp/testfile" , "33" );

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>In previous versions of CFEngine lists were represented (as in the shell) using separated scalars; similar to the PATH variable. In CFEngine 3 lists are kept as an independent type. 
   
   

<div>
<a></a>

</div>

<h4>6.5.2 <code>int</code></h4>

<p><b>Type</b>: int

<p><b>Allowed input range</b>: <code>-99999999999,9999999999</code>

<p><b>Synopsis</b>: A scalar integer

<p><b>Example</b>:<br>
<br>

<pre>vars:

 "scalar" int    => "16k";

 "ran"    int    => randomint(4,88);

 "dim_array" int =>  readstringarray("array_name","/etc/passwd","#[^\n]*",":",10,4000);

</pre>

<p><b>Notes</b>:<br>
<br>
Int variables are strings that are expected to be used as integer numbers. The typing in CFEngine is dynamic, so the variable types are interchangeable. However, when you declare a variable to be type <code>int</code>, CFEngine verifies that the value you assign to it looks like an integer (e.g., <samp><span>3</span></samp>, <samp><span>-17</span></samp>, <samp><span>16K</span></samp>).

   <p>Integer values may use suffices <samp><span>k</span></samp>, <samp><span>K</span></samp>, <samp><span>m</span></samp>, <samp><span>M</span></samp>, and so forth. However, they must only have an integer numeric part (e.g. <samp><span>1.5M</span></samp> is not allowed).

     <dl>
<dt><samp><span>k</span></samp><dd>The value multiplied by 1000. 
<br><dt><samp><span>K</span></samp><dd>The value multiplied by 1024. 
<br><dt><samp><span>m</span></samp><dd>The value multiplied by 1000 * 1000. 
<br><dt><samp><span>M</span></samp><dd>The value multiplied by 1024 * 1024. 
<br><dt><samp><span>g</span></samp><dd>The value multiplied by 1000 * 1000 * 1000. 
<br><dt><samp><span>G</span></samp><dd>The value multiplied by 1024 * 1024 * 1024. 
<br><dt><samp><span>%</span></samp><dd>A percentage between 1 and 100 - mainly for use in a storage context.

   </dl>

   <p>The value <samp><span>inf</span></samp> may also be used to represent an unlimited positive value.

<div>
<a></a>

</div>

<h4>6.5.3 <code>real</code></h4>

<p><b>Type</b>: real

<p><b>Allowed input range</b>: <code>-9.99999E100,9.99999E100</code>

<p><b>Synopsis</b>: A scalar real number

<p><b>Example</b>:<br>
<br>

<pre>
vars:
   
 "scalar" real   => "0.5";

</pre>

<p><b>Notes</b>:<br>
<br>
Real variables are strings that are expected to be used as real numbers. The typing in CFEngine is dynamic, so the variable types are interchangeable, but when you declare a variable to be type <code>real</code>, CFEngine verifies that the value you assign to it looks like a real number (e.g., <samp><span>3</span></samp>, <samp><span>3.1415</span></samp>, <samp><span>.17</span></samp>, <samp><span>6.02e23</span></samp>, <samp><span>-9.21e-17</span></samp>).

   <p>Real numbers are not used in many places in CFEngine, but they are useful for representing probabilities and performance data.

<div>
<a></a>

</div>

<h4>6.5.4 <code>slist</code></h4>

<p><b>Type</b>: slist

<p><b>Allowed input range</b>: (arbitrary string)

<p><b>Synopsis</b>: A list of scalar strings

<p><b>Example</b>:<br>
<br>

<pre>vars:

 "xxx"    slist  => {  "literal1",  "literal2" };

 "yyy"    slist  => { 
                    readstringlist(
                                  "/home/mark/tmp/testlist",
                                  "#[a-zA-Z0-9 ]*",
                                  "[^a-zA-Z0-9]",
                                  15,
                                  4000
                                  ) 
                    };

 "zzz"    slist  => { readstringlist("/home/mark/tmp/testlist2","#[^\n]*",",",5,4000) };


</pre>

<p><b>Notes</b>:<br>
<br>
Some functions return <code>slist</code>s (see <a>Introduction to functions</a>), and an <code>slist</code> may contain the values copied from another <code>slist</code>, <code>rlist</code>, or <code>ilist</code> (see <a>List variable substitution and expansion</a>, see <a>policy in vars</a>).  

<div>
<a></a>

</div>

<h4>6.5.5 <code>ilist</code></h4>

<p><b>Type</b>: ilist

<p><b>Allowed input range</b>: <code>-99999999999,9999999999</code>

<p><b>Synopsis</b>: A list of integers

<p><b>Example</b>:<br>
<br>

<pre>
vars:

  "variable_id"

       ilist => { "10", "11", "12" };

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Integer lists are lists of strings that are expected to be treated as integers.  The typing in CFEngine is dynamic, so the variable types are interchangeable, but when you declare a variable to be type <code>ilist</code>, CFEngine verifies that each value you assign to it looks like an integer (e.g., <samp><span>3</span></samp>, <samp><span>-17</span></samp>, <samp><span>16K</span></samp>).

   <p>Some functions return <code>ilist</code>s (see <a>Introduction to functions</a>), and an <code>ilist</code> may contain the values copied from another <code>slist</code>, <code>rlist</code>, or <code>ilist</code> (see <a>List variable substitution and expansion</a>, see <a>policy in vars</a>). 


<div>
<a></a>

</div>

<h4>6.5.6 <code>rlist</code></h4>

<p><b>Type</b>: rlist

<p><b>Allowed input range</b>: <code>-9.99999E100,9.99999E100</code>

<p><b>Synopsis</b>: A list of real numbers

<p><b>Example</b>:<br>
<br>

<pre>
vars:

  "varid" rlist => { "0.1", "0.2", "0.3" };

</pre>

<p><b>Notes</b>:<br>
<br>
Real lists are lists of strings that are expected to be used as real numbers. The typing in CFEngine is dynamic, so the variable types are interchangeable, but when you declare a variable to be type <code>rlist</code>, CFEngine verifies that each value you assign to it looks like a real number (e.g., <samp><span>3</span></samp>, <samp><span>3.1415</span></samp>, <samp><span>.17</span></samp>, <samp><span>6.02e23</span></samp>, <samp><span>-9.21e-17</span></samp>).

   <p>Some functions return <code>rlist</code>s (see <a>Introduction to functions</a>), and an <code>rlist</code> may contain the values copied from another <code>slist</code>, <code>rlist</code>, or <code>ilist</code> (see <a>List variable substitution and expansion</a>, see <a>policy in vars</a>). 


<div>
<a></a>

</div>

<h4>6.5.7 <code>policy</code></h4>

<p><b>Type</b>: (menu option)

<p><b>Allowed input range</b>: <br>
<pre>               <code>free</code>
               <code>overridable</code>
               <code>constant</code>
               <code>ifdefined</code>
</pre>
   <p><b>Synopsis</b>: The policy for (dis)allowing (re)definition of variables

<p><b>Example</b>:<br>
<br>

<pre>
vars:

  "varid" string => "value...",
          policy => "constant";

</pre>

<p><b>Notes</b>:<br>
<br>

   <p>Variables can either be allowed to change their value dynamically (be redefined) or they can be constant. The use of private variable spaces
in CFEngine 3 makes it unlikely that variable redefinition would be necessary in CFEngine 3.

   <p>The value <code>constant</code> indicates that the variable value may not be changed.  The values <code>free</code> and <code>overridable</code> are synonymous, and indicated that the variable's value may be changed.

   <p>The value <code>ifdefined</code> applies only to lists and implies that unexpanded or undefined lists are dropped. The default behaviour is otherwise to retain this value as an indicator of the failure to quench the variable reference, for example:  
<pre>   
    "one" slist => { "1", "2", "3" };

   "list" slist => { "@(one)", @(two) },

            policy => "ifdefined";

</pre>
This would result in <samp><span>@(list)</span></samp> being the same as <samp><span>@(one)</span></samp>, and the reference to <samp><span>@(two)</span></samp> would disappear. This is useful for combining lists, `inheritance-style' where one can extend a base with special cases if they are defined.

<p><b>Default value</b>:<br>
<br>

   <p><code>policy = constant</code>

<div>
<a></a>

</div>


