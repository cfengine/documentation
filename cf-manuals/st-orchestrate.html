<html lang="en">
<head>
<title>Orchestrating and Modularizing Business Processes</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Orchestrating and Modularizing Business Processes">
<meta name="generator" content="makeinfo 4.12">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; }
  span.sansserif { font-family:sans-serif; font-weight:normal; }
body {
	font-family: Verdana, DejaVu, Vera, Geneva, sans-serif;
	padding: 10px;
}
.node
{
	text-align: right;
	padding: 2px;
	font-size: smaller;
}
.node hr {
	border: 0;
	width: 100%;
	color: #CCC;
	background-color: #CCC;
	height: 5px;
}
.section {
	padding-right: 0px;
	padding-bottom: 0px;
	padding-left: 0px;
}
h1 {
	font-weight: bold;
	color: #666;
}
h2 {
	font-weight: bold;
	color: #666;
}
h3 {
	margin-top: 3px;
	margin-right: 0px;
	margin-bottom: 10px;
	margin-left: 0px;
}

.menu
{
}

.contents
{
	background-color: #CCC;
	padding-top: 2px;
	padding-right: 2px;
	padding-bottom: 2px;
	padding-left: 10px;
}

.index-cp
{
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 70%; }

.tynn {
        font-family: Arial, Helvetica, sans-serif;
        font-size: smaller;
        font-style: normal;
        font-weight: lighter;
        margin-bottom: 0em;
     font-size: 11pt;
        }
.verbatim {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.example {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	width: 100%;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.smallexample {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	width: 100%;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.cartouche {
	background-color: #CCC;
	border-top-style: none;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
	padding: 5px;
	font-style: italic;
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }--></style>
</head>
<body>
<h1 class="settitle">Orchestrating and Modularizing Business Processes</h1>
<div class="node">
<p><hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-modularity_003f">What is modularity?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Orchestration</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-modularity_003f">What is modularity?</a>
<li><a accesskey="2" href="#What-is-orchestration_003f">What is orchestration?</a>
<li><a accesskey="3" href="#How-does-cfengine-deal-with-modularity-and-orchestration_003f">How does cfengine deal with modularity and orchestration?</a>
<li><a accesskey="4" href="#High-level-services-in-cfengine">High level services in cfengine</a>
<li><a accesskey="5" href="#Hiding-details">Hiding details</a>
<li><a accesskey="6" href="#Black">Black</a>
<li><a accesskey="7" href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>
<li><a accesskey="8" href="#Ordering-operations-in-cfengine">Ordering operations in cfengine</a>
<li><a accesskey="9" href="#Bundle-ordering">Bundle ordering</a>
<li><a href="#Overriding-order">Overriding order</a>
<li><a href="#Distributing-Ordering-between-hosts-with-cfengine-Nova">Distributing Ordering between hosts with cfengine Nova</a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<div class="node">
<p><hr>
<a name="What-is-modularity%3f"></a>
<a name="What-is-modularity_003f"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-orchestration_003f">What is orchestration?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is modularity?</h3>

<pre class="sp">

</pre>
Modularity is the ability to separate concerns in a process and hide
the details of the different concerns in different containers. It is a
<i>service oriented view</i>, in which different aspects of a problem are
separated and turned into generic components that offer a service.  We
often talk about black boxes, grey boxes or white boxes depending on
the extent to which the user of a service can see the details within
the containers.

<div class="node">
<p><hr>
<a name="What-is-orchestration%3f"></a>
<a name="What-is-orchestration_003f"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-does-cfengine-deal-with-modularity-and-orchestration_003f">How does cfengine deal with modularity and orchestration?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-modularity_003f">What is modularity?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is orchestration?</h3>

<pre class="sp">

</pre>
Orchestration is the ability to coordinate many different processes in
a system so that the sum of those processes yields a harmonious result.
Orchestration is not about centralized control, though this is common
misperception.

   <p>An orchestra does not manage to play a symphony because the conductor
pulls every player's strings or blows every trumpet in person, but
rather because each <i>autonomous</i> player has a copy of the script,
knows what to do, and can use just the little additional information
from the conductor to access a viewpoint that is not available to an
individual. An orchestra is a weakly coupled expert system in which
the management (conductor) provides a service to the players.

   <p>CFEngine works like an orchestra &ndash; this is why is scales so well.
Each computer is an autonomous entity, getting its script and a few
occasional pieces of information from the policy server (conductor).
The coupling between the agents is weak &ndash; there is slack that makes
the behaviour robust to minor errors in communication or timing.

<div class="node">
<p><hr>
<a name="How-does-cfengine-deal-with-modularity-and-orchestration%3f"></a>
<a name="How-does-cfengine-deal-with-modularity-and-orchestration_003f"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#High-level-services-in-cfengine">High level services in cfengine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-orchestration_003f">What is orchestration?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">How does cfengine deal with modularity and orchestration?</h3>

<p>Promise Theory provides simple principles for hiding details: agents are
considered to reveal a kind of <i>service interface</i> to peers, that is
advertised by making a promise to someone.  We assume an agent exerts
best effort in keeping its promises. Orchestration requires a promise
to coordinate and the promise to use that coordination service.
These basic ideas are built into CFEngine.

   <p>CFEngine provides containers called <i>bundles</i> for creating modular
parts. Bundles can be independent (and therefore parallelizable)
or they can be dependent (in which case the sequence in which they
verify their promises matters).

   <p>In a computer centre with many different machines, there is an
additional dimension to orchestration &ndash; multiple orchestras. Each
machine has a number of resources that need to be orchestrated, and
the different machines themselves might also need to cooperate because
they provide services to one another. The principles are the same in
both cases, but the confusion between them is typically the reason why
large systems do not scale well.

<div class="node">
<p><hr>
<a name="High-level-services-in-cfengine"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Hiding-details">Hiding details</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-does-cfengine-deal-with-modularity-and-orchestration_003f">How does cfengine deal with modularity and orchestration?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">High level services in cfengine</h3>

<p>CFEngine is designed to handle high level simplicity (without
sacrificing low level capability) by working with configuration
<i>patterns</i>, after all configuration is all about promising
consistent patterns of system <i>state</i> in the resources of the
system. Lists, for instance, are a particularly common kind of
pattern: <i>for each of the following... make a similar promise</i>.
There are several ways to organize patterns, using containers, lists
and associative arrays. Let's look at how to configure a number of
application services.

   <p>At the simplest or highest level, we can turn services into "genes"
to switch on and off on your basic "stem cell" machines.

<pre class="verbatim">body agent control
{
bundlesequence => {
                  webserver("on"),
                  dns("on"),
                  security_set("on"),
                  ftp("off")
                  };
}
</pre>

   <p>This obviously looks simple, but this kind of simplicity is cheating
as we are hiding <i>all</i> the details of what is going to happen &ndash; we
don't know if they are hard-coded, or whether we can decide
ourselves. Anyone can play that game! The true test is whether we can
retain the power to decide the low-level details without having to
program in a low level language like Ruby, Python or Perl. Let's peel
back some of the layers, knowing that we can hide as many of the
details as we like.

   <p>A simple, but low level approach to deploying a service, that veteran
users will recognize, is the following. This is a simple example of
orchestration between a promise to raise a signal about a missing process and
another promise to restart said process once its absence has been
discovered and signalled.

<pre class="verbatim">bundle agent application_services
{
processes:

  "sshd"  restart_class => "start_ssh";
  "httpd" restart_class => "start_spache";

commands:

 start_ssh::
   "/etc/init.d/sshd restart";

 start_apache::
   "/etc/init.d/apache restart";

}
</pre>

   <p>But the first thing we see is that there is a repeated pattern, so we could
rewrite this as a single promise for a list of services, at the cost of a loss
of transparency. However, this is the power of abstraction.

<pre class="verbatim">bundle agent application_services
{
vars:

  "service" slist => { "ssh", "apache", "mysql" };

 #
 # Apply the following promises to this list...
 #

processes:

  "$(daemon[$(service)])" restart_class => canonify("start_$(service)");

commands:

   "$(start[$(service)])"
       ifvarclass => canonify("start_$(service)");

}
</pre>

   <p>This assumes that we can define the necessary information about these
services in array variables of the form <code>$(array[index])</code>.
This is what other tools refer to as a <i>resource abstraction layer</i>,
though in some other tools this layer has to be partially hard-coded.
We can see some more approaches below, but let's look at this abstraction for a moment.

<div class="node">
<p><hr>
<a name="Hiding-details"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Black">Black</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#High-level-services-in-cfengine">High level services in cfengine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Hiding details</h3>

<p>Resource abstraction, or hiding system specific details inside a kind of
grey-box, is just another service as far as cfengine is concerned &ndash; and we
generally map services to bundles.

   <p>Many system variables are discovered automatically by cfengine and provided
"out of the box", e.g. the location of the filesystem table might be <code>/etc/fstab</code>,
or <code>/etc/vfstab</code> or even <code>/etc/filesystems</code>, but cfengine allows you to
refer simply to <code>&lt;b&gt;$(sys.fstab)&lt;/b&gt;</code>. Soft-coded abstraction needs cannot
be discovered by the system however.
So how do we create this mythical resource abstraction layer? It is
simple.  Elsewhere we have defined basic settings.

<pre class="verbatim">bundle common res # abstraction layer
{
vars:

  solaris::

   "cfg_file[ssh]" string => "/etc/sshd_config";
   "daemon[ssh] "  string => "sshd";
   "start[ssh] "   string => "/etc/init.d/sshd restart";

  linux.SuSE::

   "cfg_file[ssh]" string => "/etc/ssh/sshd_config";
   "daemon[ssh] "  string => "sshd";
   "start[ssh] "   string => "/etc/init.d/sshd restart";

  default::

   "cfg_file[ssh]" string => "/etc/sshd_config";
   "daemon[ssh] "  string => "sshd";
   "start[ssh] "   string => "/etc/init.d/sshd restart";

classes:

  "default" and => { "!SuSE", "solaris" };
}
</pre>

   <p>Some of the attempts to recreate a CFEngine-like tool try to hard code
many decisions, meaning that minor changes in operating system versions
require basic recoding of the software. CFEngine does not make decisions
for you without your permission.

<div class="node">
<p><hr>
<a name="Black"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Hiding-details">Hiding details</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Black, grey and white box encapsulation in cfengine</h3>

<p>Cfengine's ability to abstract system decisions as promises also
applies to bundles of promises. After all, we can package promises
as bumper compendia for grouping together related matters in
a single package. Naturally, cfengine never abandons its insistence
on &lt;b&gt;convergence&lt;/b&gt;, merely for the sake of making things look
simple. Using cfengine, you can create convergent orchestration.

<pre class="verbatim">bundle agent services
{
vars:
 "service" slist => { "dhcp", "ntp", "sshd" };
methods:
 "any" usebundle => fix_service("$(service)"),
         comment => "Make sure the basic application services are running";
}
</pre>
The code above is all you really want to see. The rest can be hidden in libraries that
you rarely look at. In cfengine, we want the intentions to shine forth and the
low level details to be clear on inspection, but hidden from view.

   <p>We can naturally modularize the packaged bundle of fully convergent
promises and keep it as library code for reuse. Notice that
cfengine adds comments in the code that follow processes through
execution, allowing you to see the full intentions behind the
promises in logs and error messages. In commercial versions, you can
trace these comments to see your process details.

<pre class="verbatim">bundle agent fix_service(service)
{
files:

  "$(res.cfg_file[$(service)])"

 #
 # reserved_word => use std templates, e.g. cp(), p(), or roll your own
 #
     copy_from => cp("$(g.masterfiles)/$(service)","policy_host.mydomain"),
         perms => p("0600","root","root"),
       classes => define("$(service)_restart", "failed"),
       comment => "Copy a stock configuration file template from repository";

processes:

  "$(res.daemon[$(service)])"

     restart_class => canonify("$(service)_restart"),
           comment => "Check that the server process is running...";

commands:

  "$(res.start[$(service)])"

           comment => "Method for starting this service",
        ifvarclass => canonify("$(service)_restart");

}

</pre>

<div class="node">
<p><hr>
<a name="Bulk-operations-are-handled-by-repeating-patterns-over-lists"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ordering-operations-in-cfengine">Ordering operations in cfengine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Black">Black</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Bulk operations are handled by repeating patterns over lists</h3>

<p>The power of cfengine is to be able to handle lists of similar
patterns in a powerful way.  You can also wrap the whole experience in
a method-bundle, and we can extend this kind of pattern to
implement other interfaces, all without low level programming.

<pre class="verbatim">#
# Remove certain services from xinetd - for system hardening
#

bundle agent linux_harden_methods
{
vars:

   "services" slist => {
                       "chargen",
                       "chargen-udp",
                       "cups-lpd",
                       "finger",
                       "rlogin",
                       "rsh",
                       "talk",
                       "telnet",
                       "tftp"
                       };
methods:

    #
    # for each $(services) in @(services) do disable_xinetd($(services))
    #

   "any"  usebundle => disable_xinetd("$(services)");
}
</pre>

   <p>In the library of generic templates, we may keep one or more methods for implementing
service disablement. For example, this simple interface to Linux's <code>chkconfig</code>
is one approach, which need not be hard-coded in Ruby using Cfeninge.

<pre class="verbatim">#
# For the standard library
#

bundle agent disable_xinetd(name)
{
vars:
   "status"

     string => execresult("/sbin/chkconfig --list $(name)", "useshell");

classes:
   "on"  expression => regcmp(".*on","$(status)");
   "off" expression => regcmp(".*off","$(status)");

commands:
   on::
      "/sbin/chkconfig $(name) off",
          comment => "disable $(name) service";

reports:
   on::
      "disable $(name) service.";
   off::
      "$(name) has been already disabled. Don't need to perform the action.";

}
</pre>

<div class="node">
<p><hr>
<a name="Ordering-operations-in-cfengine"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bundle-ordering">Bundle ordering</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Ordering operations in cfengine</h3>

<p>Ordering of operations is less important than you probably
think. We are taught to think of computing as an linear sequence of
steps, but this ignores a crucial fact about distributed systems: that
many parts are independent of each other and exist in parallel.

   <p>Nevertheless there are sometimes cases of strong inter-dependency
(that we strive to avoid, as they lead to most of the difficulties of
system management) where order <i>is</i> important. In re-designing
cfengine, we have taken a pragmatic approach to ordering. Essentially,
cfengine takes care of ordering for you for most cases &ndash; and you can
override the order in three ways:

     <ul>
<li>CFEngine checks promises of the same type in the order in which they are defined, unless overridden
<li>Bulk ordering of composite promises (called bundles) is handled using an overall list using the bundlesequence (replaces the actionsequence in previous cfengines)
<li>Dependency coupling through dynamic classes, may be used to guarantee ordering in the few cases
where this is required,  as in the example below:
</ul>

<div class="node">
<p><hr>
<a name="Bundle-ordering"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Overriding-order">Overriding order</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ordering-operations-in-cfengine">Ordering operations in cfengine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Bundle ordering</h3>

<p>There are two methods, working at different levels.
At the top-most level there is the master <code>bundlesequence</code>

   <pre class="sp">

</pre>
<pre class="verbatim">body common control
{
bundlesequence => { "bundle_one", "bundle_two", "bundle_three" };
}
</pre>
   <pre class="sp">

</pre>
For simple cases this is good enough, but the main
purpose of the bundlesequence is to easily be able to switch on
or off bundles by commenting them out.

   <p>A more flexible way of ordering bundles is to wrap the ordered process
in a master-bundle.  Then you can create new sequences of bundles
(parameterized in more sophisticated ways) using <code>methods</code>
promises. Methods promises are simply promises to re-use bundles,
possibly with different parameters.

   <p>The default behaviour is to retain the order of these promises; the effect
is to `execute' these bundles in the assumed order:
   <pre class="sp">

</pre>
<pre class="verbatim">bundle agent a_bundle_subsequence
{
methods:
  classes::
   "any" usebundle => bundle_one("something");
   "any" usebundle => bundle_two("something");
   "any" usebundle => bundle_three("something");

}
</pre>
   <pre class="sp">

</pre>
Alternatively, the same effect can be achieved as follows.
   <pre class="sp">

</pre>
<pre class="verbatim">bundle agent a_bundle_subsequence
{
methods:
  classes::
   "any" usebundle => generic_bundle("something","one");
   "any" usebundle => generic_bundle("something","two");
   "any" usebundle => generic_bundle("something","three");

}
</pre>
   <pre class="sp">

</pre>
Or ultimately:
   <pre class="sp">

</pre>
<pre class="verbatim">bundle agent a_bundle_subsequence
{
vars:
  "list" slist => { "one", "two", "three"};

methods:
  classes::
   "any" usebundle => generic_bundle("something","$(list)");

}
</pre>

<div class="node">
<p><hr>
<a name="Overriding-order"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Distributing-Ordering-between-hosts-with-cfengine-Nova">Distributing Ordering between hosts with cfengine Nova</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bundle-ordering">Bundle ordering</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Overriding order</h3>

<p>CFEngine is designed to handle non-deterministic events, such as
anomalies and unexpected changes to system state, so it needs to
adapt. For this, there is no deterministic solution and approximate
methods are required. Nevertheless, it is possible to make cfengine
sort out dependent orderings, even when confounded by humans, as in
this example:

<pre class="verbatim">bundle agent order

{
vars:

 "list" slist => { "three", "four" };

commands:

 ok_later::
   "/bin/echo five";

 any::

  "/bin/echo one"     classes => define("ok_later");
  "/bin/echo two";
  "/bin/echo $(list)";

}

</pre>

<p class="noindent">The output of which becomes:
<pre class="verbatim">Q: ".../bin/echo one": one
Q: ".../bin/echo two": two
Q: ".../bin/echo three": three
Q: ".../bin/echo four": four
Q: ".../bin/echo five": five
</pre>

<div class="node">
<p><hr>
<a name="Distributing-Ordering-between-hosts-with-cfengine-Nova"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overriding-order">Overriding order</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Distributing Ordering between hosts with cfengine Nova</h3>

<p>CFEngine Nova adds many powerful features to CFEngine, including
a decentralized approach to coordinating activities across multiple
hosts. Some tools try to approach this by centralizing data from the
network in a single location, but this has two problems:

     <ul>
<li>It leads to a bottleneck by design that throttles performance seriously.
<li>It relies on the network being available.
</ul>

   <p>With CFEngine Nova there are are both decentralized network approaches
to this problem, and probabilistic methods that do not require the network
at all.

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Orchestration</a>
<ul>
<li><a href="#What-is-modularity_003f">What is modularity?</a>
<li><a href="#What-is-orchestration_003f">What is orchestration?</a>
<li><a href="#How-does-cfengine-deal-with-modularity-and-orchestration_003f">How does cfengine deal with modularity and orchestration?</a>
<li><a href="#High-level-services-in-cfengine">High level services in cfengine</a>
<li><a href="#Hiding-details">Hiding details</a>
<li><a href="#Black">Black, grey and white box encapsulation in cfengine</a>
<li><a href="#Bulk-operations-are-handled-by-repeating-patterns-over-lists">Bulk operations are handled by repeating patterns over lists</a>
<li><a href="#Ordering-operations-in-cfengine">Ordering operations in cfengine</a>
<li><a href="#Bundle-ordering">Bundle ordering</a>
<li><a href="#Overriding-order">Overriding order</a>
<li><a href="#Distributing-Ordering-between-hosts-with-cfengine-Nova">Distributing Ordering between hosts with cfengine Nova</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

</body></html>

