<html lang="en">
<head>
<title>Distributed Scheduling</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Distributed Scheduling">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; }
  span.sansserif { font-family:sans-serif; font-weight:normal; }
body {
	font-family: Verdana, DejaVu, Vera, Geneva, sans-serif;
	padding: 10px;
}
.node
{
	text-align: right;
	padding: 2px;
	font-size: smaller;
}
.node hr {
	border: 0;
	width: 100%;
	color: #CCC;
	background-color: #CCC;
	height: 5px;
}
.section {
	padding-right: 0px;
	padding-bottom: 0px;
	padding-left: 0px;
}
h1 {
	font-weight: bold;
	color: #666;
}
h2 {
	font-weight: bold;
	color: #666;
}
h3 {
	margin-top: 3px;
	margin-right: 0px;
	margin-bottom: 10px;
	margin-left: 0px;
}

.menu
{
}

.contents
{
	background-color: #CCC;
	padding-top: 2px;
	padding-right: 2px;
	padding-bottom: 2px;
	padding-left: 10px;
}

.index-cp
{
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 70%; }

.tynn {
        font-family: Arial, Helvetica, sans-serif;
        font-size: smaller;
        font-style: normal;
        font-weight: lighter;
        margin-bottom: 0em;
     font-size: 11pt;
        }

.verbatim {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}

.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }

.example {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	width: 100%;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.smallexample {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	width: 100%;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.cartouche {
	background-color: #CCC;
	border-top-style: none;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
	padding: 5px;
	font-style: italic;
        width: 100%;
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }--></style>
</head>
<body>
<h1 class="settitle">Distributed Scheduling</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-distributed-scheduling_003f">What is distributed scheduling?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">CFEngine-Tutorial</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-distributed-scheduling_003f">What is distributed scheduling?</a>
<li><a accesskey="2" href="#Coordinating-dispatch">Coordinating dispatch</a>
<li><a accesskey="3" href="#Job-scheduling-and-periodic-maintenance">Job scheduling and periodic maintenance</a>
<li><a accesskey="4" href="#Fancy-distributed-encapsulation">Fancy distributed encapsulation</a>
<li><a accesskey="5" href="#More-links-in-the-chain">More links in the chain</a>
<li><a accesskey="6" href="#Self_002dhealing-workflows">Self-healing workflows</a>
<li><a accesskey="7" href="#Long-workflow-chains">Long workflow chains</a>
<li><a accesskey="8" href="#Summary-of-Distributed-Scheduling">Summary of Distributed Scheduling</a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<div class="node">
<a name="What-is-distributed-scheduling%3f"></a>
<a name="What-is-distributed-scheduling_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Coordinating-dispatch">Coordinating dispatch</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is distributed scheduling?</h3>

<pre class="sp">

</pre>
Scheduling refers to the execution of non-interactive processes or
tasks (usually called `jobs') at designated times and places around a
network of computers (see the Special Topics Guide on Scheduling).
Distributed Scheduling refers to the chaining of different jobs into a
coordinated workflow that spans several computers. For example, you
schedule a processing job on <code>machine1</code> and <code>machine2</code>, and
when these are finished you need to schedule a job on <code>machine3</code>.
This is distributed scheduling.

<div class="node">
<a name="Coordinating-dispatch"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Job-scheduling-and-periodic-maintenance">Job scheduling and periodic maintenance</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-distributed-scheduling_003f">What is distributed scheduling?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Coordinating dispatch</h3>

<p>Dispatch is the term used for starting actually the execution of a job
that has been scheduled.  There are two ways to achieve distributed
job scheduling:
     <ul>
<li>Centralized dispatch of jobs.
<li>Peer to peer signalling with local dispatch of jobs.
</ul>
   There are pros and cons to centralization. Centralization makes
consistency easy to determine, but it creates bottlenecks in
processing and allows one machine to see all
information. Decentralization provides an automatic and natural
load-balancing of job dispatch, and it allows machines to
reveal information on a `need to know' basis.

   <p>CFEngine is a naturally decentralized system, and only policy
definition is usually centralized, but you can set up practically any
architecture you like, in a secure fashion.

<div class="node">
<a name="Job-scheduling-and-periodic-maintenance"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Fancy-distributed-encapsulation">Fancy distributed encapsulation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Coordinating-dispatch">Coordinating dispatch</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Job scheduling and periodic maintenance</h3>

<p>You promise to execute tasks or keep promises at distributed
places and times:

     <ul>
<li>You tell cfengine <i>what</i> and <i>how</i> with the details of a promise.
<li>You tell cfengine <i>where</i> and <i>when</i> promises should be kept, using <i>classes</i>.
</ul>

   <p>CFEngine is designed principally to maintain desired state on a continuous
basis.
There are three cases for job scheduling:
     <ul>
<li>Unique jobs run once and only once.
<li>Standard jobs run sporadically on demand.
<li>Standard jobs run on a regular schedule.
</ul>
   This list transfers to workflow processes too. If one job needs to
follow after another (because it depends on it for something), we can
ask if this workflow is a standard and regular occurrence, or a one-off phenomenon.

<ul class="menu">
<li><a accesskey="1" href="#One_002doff-workflows">One-off workflows</a>
<li><a accesskey="2" href="#Regular-workflows">Regular workflows</a>
</ul>

<div class="node">
<a name="One-off-workflows"></a>
<a name="One_002doff-workflows"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Regular-workflows">Regular workflows</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Job-scheduling-and-periodic-maintenance">Job scheduling and periodic maintenance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Job-scheduling-and-periodic-maintenance">Job scheduling and periodic maintenance</a>

</div>

<h4 class="unnumberedsubsec">One-off workflows</h4>

<p>In CFEngine, you code a one-off workflow by specifying the space-time coordinates
of the event that starts it. For example, if you want a job to be run a 16:45 on Monday
24th January 2012, you would make a class corresponding to this time, and place the
promise of a job (or jobs) in this class. Let's look at some examples of this, in which
host1 executes a command called <samp><span class="file">my_job</span></samp>, and host2 follows up with a bundle of
promises afterwards.

   <p>The simplest case is to schedule the exact times.
<pre class="verbatim">bundle agent workflow_one
{
methods:

  Host2.Day24.January.Year2012.Hr16.Min50_55::

    "any" usebundle => do_my_job_bundle;

commands:

  Host1.Day24.January.Year2012.Hr16.Min45_50::

    "/usr/local/bin/my_job";

}
</pre>
Host1 runs its task at 16:45, and Host2 excutes its part in the
workflow five minutes later. The advantage of this approach is that no
direct communication is required between Host1 and Host2.  The
disadvantage is that you, as the orchestrator, have to guess how long
the jobs will take.  Moreover Host2 doesn't know for certain whether
host1 succeeded in carrying out its job, so it might be a fruitless
act.

   <p>We can change this by signalling between the processes. Whether not you consider
this an improvement or not depends on what you value highest: avoidance of
communication or certainty of outcome. In this version, we increase the certainty
of control by asking the predecessor or upstream host for confirmation of success
if the job was carried out.
<pre class="verbatim">bundle agent workflow_one
{
classes:

  Host2::

     "succeeded"     expression => remoteclassesmatching
                                           (
                                           "did.*",    # get classes matching
                                           "Host1",    # from this server
                                           "no",       # encrypt comms?
                                           "hostX"     # prefix
                                           );
methods:

  Host2.hostX_did_my_job

    "any" usebundle => do_my_job_bundle;

commands:

  Host1.Day24.January.Year2012.Hr16.Min45_50::

    "/usr/local/bin/my_job",
        classes => state_repaired("did_my_job");
}
</pre>
In this example, the methods promise runs on Host2 and the commands promise runs
one Host1 as before. Now, host 1 sets a signal class &lsquo;<samp><span class="samp">did_my_job</span></samp>&rsquo;
when it carries out the job, and Host2 collects it by contacting the <code>cf-serverd</code>
on Host1. Assuming that Host1 has agreed to let Host2 know this information, by granting
access to it, Host2 can inherit this class, with a prefix of its own choosing. Thus
is transforms the class &lsquo;<samp><span class="samp">did_my_job</span></samp>&rsquo; on Host1 into &lsquo;<samp><span class="samp">hostX_did_my_job</span></samp>&rsquo; on Host2.

   <p>The advantage of this method is that the second job will only be started if the first
completed, and we don't have to know how long the job took. The disadvantage of this is that
we have to exchange some network information, and this has a small network cost, and requires
some extra configuration on the server side to grant access to this context information:

<pre class="verbatim">bundle server access_rules
{
access:

  "did_my_job"

  resource_type => "context",
        admit   => { "Host2" };
}

</pre>

<div class="node">
<a name="Regular-workflows"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#One_002doff-workflows">One-off workflows</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Job-scheduling-and-periodic-maintenance">Job scheduling and periodic maintenance</a>

</div>

<h4 class="unnumberedsubsec">Regular workflows</h4>

<p>To make a job happen at a specific time, we used a very specific time
classifier &lsquo;<samp><span class="samp">Day24.January.Year2012.Hr16.Min45_50</span></samp>&rsquo;. If we now want
to make this workflow into a regular occurrence, repeating at some
interval we have two options:

     <ul>
<li>We repeat this at the same time each week, day, hour, etc.
<li>We don't care about the precise time, we only care about the interval between executions.
</ul>
   The checking of promises in cfengine is controlled by <i>classes</i> and
by <i>ifelapsed locks</i>, which may be used for these two cases
respectively. If nothing else is specified, cfengine runs every 5
minutes and reconsiders the state of all its active promises. To be
specific about the time, we just alter which promises are active at
different times.  Classes (as used already) allow us to anchor a
promise to a particular region of time and space. Locks, on the other
hand, allow us to say that a promise will only be rechecked if a certain
time has elapsed since the last time.

   <p>So, to make a promise repeat, we simply have to be less specific about the time.
Let us make the promise on Host1 apply every day between 16:00:00 (4 pm) and 16:59:59,
and add an ifelapsed lock saying that we do not want to consider rechecking more often
tha once every 100 minutes (more than 1 hour). Now we have a workflow process
that starts at 16:00 hours each day and runs only once each day.

<pre class="verbatim">bundle agent workflow_one
{
classes:

  Host2::

     "succeeded"     expression => remoteclassesmatching(
                                                        "did.*",
                                                        "Host1",
                                                        "no",
                                                        "hostX"
                                                        );
methods:

  Host2.hostX_did_my_job

    "any" usebundle => do_my_job_bundle;

commands:

  Host1.Hr16::

    "/usr/local/bin/my_job",
         action => if_elapsed("100"),
        classes => state_repaired("did_my_job");


</pre>

<div class="node">
<a name="Fancy-distributed-encapsulation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#More-links-in-the-chain">More links in the chain</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Job-scheduling-and-periodic-maintenance">Job scheduling and periodic maintenance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Fancy distributed encapsulation</h3>

<p>We could try to be fancy about distributed scheduling, packaging
it into a reusable structure. This may or may not be a good idea, depending
on your aesthetics. The following example, from the community unit tests,
shows how we might proceed.

<pre class="verbatim">
body common control

{
bundlesequence  => { job_chain("Hr16.Min10_15") };
}

########################################################

bundle common g
{
vars:

 # Define the name of the signal passed between hosts

 "signal"   string => "pack_a_name";
}

########################################################

bundle agent job_chain(time)
{
vars:

    # Define the names of the two parties

    "client"   string => "downstream.exampe.org";
    "server"   string => "upstream.example.org";

classes:

    # derive some classes from the names defined in variables

    "client_primed" expression => classmatch(canonify("$(client)")),
                    ifvarclass => "$(time)";

    "server_primed" expression => classmatch(canonify("$(server)")),
                    ifvarclass => "$(time)";

 client_primed::

     "succeeded"     expression => remoteclassesmatching(
                                                        "$(g.signal)",
                                                        "$(server)",
                                                        "yes",
                                                        "hostX"
                                                        );
methods:

 client_primed::

    "downstream" usebundle => do_job("Starting local follow-up job"),
                    action => if_elapsed("5"),
                ifvarclass => "hostX_$(g.signal)";

 server_primed::

    "upstream"   usebundle => do_job("Starting remote job"),
                    action => if_elapsed("5"),
                   classes => state_repaired("$(g.signal)");

reports:

  !succeeded::

    "Server communication failed",

                 ifvarclass => "$(time)";
}

#########################################################

bundle agent do_job(job)
{
commands:

   # do whatever...

   "/bin/echo $(job)";
}

#########################################################
# Server config
#########################################################

body server control
{
allowconnects         => { "127.0.0.1" , "::1" };
allowallconnects      => { "127.0.0.1" , "::1" };
trustkeysfrom         => { "127.0.0.1" , "::1" };
allowusers            => { "mark" };
}

#########################################################

bundle server access_rules()
{
access:

  "$(g.signal)"

  resource_type => "context",
        admit   => { "127.0.0.1" };
}

</pre>

<div class="node">
<a name="More-links-in-the-chain"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Self_002dhealing-workflows">Self-healing workflows</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Fancy-distributed-encapsulation">Fancy distributed encapsulation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">More links in the chain</h3>

<p>In the examples above, we only had two hosts cooperating about
jobs. In general, it is not a good idea to link together many
different hosts unless there is a good reason for doing so. In HPC or
Grid environments, where distributed jobs are more common and results
are combined from many sub-tasks, one typically uses some more
specialized middleware to accomplish this kind of cooperation. Such
software makes compromises of its own, but is generally better suited
to the specialized task for which it was written than a tool like
CFEngine (whose main design criteria are to be secure and generic).

   <p>Nevertheless, there are some tricks left in CFEngine for distributed
scheduling if we want to trigger a number of follow-ups from a single job, or
aggregate a number of jobs to drive a single follow-up (see figure).

   <pre class="sp">

</pre>
<div align="center"><img src="/img/outside/schedule_patterns.png" alt="Rollback"></div>
<pre class="sp">

</pre>

<ul class="menu">
<li><a accesskey="1" href="#Aggregation-of-multiple-jobs">Aggregation of multiple jobs</a>
<li><a accesskey="2" href="#Triggering-multiple-follow_002dups">Triggering multiple follow-ups</a>
</ul>

<div class="node">
<a name="Aggregation-of-multiple-jobs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Triggering-multiple-follow_002dups">Triggering multiple follow-ups</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#More-links-in-the-chain">More links in the chain</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-links-in-the-chain">More links in the chain</a>

</div>

<h4 class="unnumberedsubsec">Aggregation of multiple jobs</h4>

<p>When aggregating jobs, we must combine their exit status using AND or OR.
The most common case it that we require all the prerequisites in place in order to
generate the final result, i.e. trigger the followup only if all of the prerequisites
succeeded.
<pre class="verbatim">bundle agent workflow_one
{
vars:

  "n" slist => { "2", "3", "4" };

classes:

     "succeeded$(n)"     expression => remoteclassesmatching(
                                                        "did.*",
                                                        "Host$(n)",
                                                        "no",
                                                        "hostX"
                                                        ),
                         ifvarclass => "Host$(n)";
methods:

  Host2.Host3.Host4.hostX_did_my_job

    "any" usebundle => do_my_job_bundle;

commands:

  Host1.Hr16::

    "/usr/local/bin/my_job",
         action => if_elapsed("100"),
        classes => state_repaired("did_my_job");
</pre>
This example shows an all-or-nothing result. The follow-up job
will only be executed if all three jobs finish within the same 5
minute time-frame. There is no error handling or recovery except to schedule the whole
thing again.

   <p>Triggering from one or more predecessors, i.e. combining with OR, looks similar,
we just have to change the class expression:
<pre class="verbatim">...

methods:

  (Host2|Host3|Host4).hostX_did_my_job

    "any" usebundle => do_my_job_bundle;

...
</pre>

<div class="node">
<a name="Triggering-multiple-follow-ups"></a>
<a name="Triggering-multiple-follow_002dups"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Aggregation-of-multiple-jobs">Aggregation of multiple jobs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-links-in-the-chain">More links in the chain</a>

</div>

<h4 class="unnumberedsubsec">Triggering multiple follow-ups</h4>

<p>The converse scenario is to trigger a number of jobs from a single pre-requisite.
This is simply a case of listing the jobs under the trigger classes.
<pre class="verbatim">bundle agent workflow_one
{
classes:

  Host2::

     "succeeded"     expression => remoteclassesmatching(
                                                        "did.*",
                                                        "Host1",
                                                        "no",
                                                        "hostX"
                                                        );
methods:

  Host2.hostX_did_my_job

    "any" usebundle => do_my_job_bundle1;
    "any" usebundle => do_my_job_bundle2;
    "any" usebundle => do_my_job_bundle3;

commands:

  Host1.Hr16::

    "/usr/local/bin/my_job",
         action => if_elapsed("100"),
        classes => state_repaired("did_my_job");

</pre>

<div class="node">
<a name="Self-healing-workflows"></a>
<a name="Self_002dhealing-workflows"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Long-workflow-chains">Long workflow chains</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#More-links-in-the-chain">More links in the chain</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Self-healing workflows</h3>

<p>To apply CFEngine's self-healing concepts to workflow scheduling, we
can imagine the concept of a convergent workflow, i.e. one that, if we
repeat everything a sufficient number of times, will eventually lead
to the result. The outcome of the chained sequence of jobs must have
an outcome that is repeatably achievable and which will eventually be
achieved if we try a sufficient number of times. Using cfengine this
is a natural outcome &ndash; however, most system designers do not think in
terms of repeatable sustainable outcomes and fault-tolerance.

   <p>Beware however, one-off jobs <i>cannot</i> be made convergent, because
they only have a single chance to succeed. It is a question of
business process design whether you design workflows to be sustainable
and repeatable, or whether you trust the outcome of a single shot
process. Using the persistent classes in cfengine together with the
if-elapsed locks to send signals between hosts, it is simple and
automatic to make convergent self-healing workflows.

<div class="node">
<a name="Long-workflow-chains"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Summary-of-Distributed-Scheduling">Summary of Distributed Scheduling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Self_002dhealing-workflows">Self-healing workflows</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Long workflow chains</h3>

<p>Long workflow chains are those which involve more than one trigger.
These can be created by repeating the pattern above several times.
Note however, that each link in the chain introduces a new level of
uncertainty and potential failure. In general, we would not recommend
creating workflows with long chains.

<div class="node">
<a name="Summary-of-Distributed-Scheduling"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Long-workflow-chains">Long workflow chains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Summary of Distributed Scheduling</h3>

<p>Distributed scheduling is about tying together jobs to create a
workflow across multiple machines. It introduces a level of fragility
into system automation. Using cfengine promises, we can create self-healing
workflows, but we recommend minimizing dependencies. This document shows how
to build workflows using CFEngine primitives.

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">CFEngine-Tutorial</a>
<ul>
<li><a href="#What-is-distributed-scheduling_003f">What is distributed scheduling?</a>
<li><a href="#Coordinating-dispatch">Coordinating dispatch</a>
<li><a href="#Job-scheduling-and-periodic-maintenance">Job scheduling and periodic maintenance</a>
<ul>
<li><a href="#One_002doff-workflows">One-off workflows</a>
<li><a href="#Regular-workflows">Regular workflows</a>
</li></ul>
<li><a href="#Fancy-distributed-encapsulation">Fancy distributed encapsulation</a>
<li><a href="#More-links-in-the-chain">More links in the chain</a>
<ul>
<li><a href="#Aggregation-of-multiple-jobs">Aggregation of multiple jobs</a>
<li><a href="#Triggering-multiple-follow_002dups">Triggering multiple follow-ups</a>
</li></ul>
<li><a href="#Self_002dhealing-workflows">Self-healing workflows</a>
<li><a href="#Long-workflow-chains">Long workflow chains</a>
<li><a href="#Summary-of-Distributed-Scheduling">Summary of Distributed Scheduling</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

</body></html>

