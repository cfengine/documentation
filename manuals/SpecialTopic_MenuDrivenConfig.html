<html lang="en">
<head>
<title>Menu Driven Configuration</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Menu Driven Configuration">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background: none !important;
    border: none !important;
    padding: 5px; 

/*    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;*/
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Menu Driven Configuration</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-menu_002ddriven-configuration">What is menu-driven configuration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Menu Driven Configuration</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-menu_002ddriven-configuration">What is menu-driven configuration</a>
<li><a accesskey="2" href="#How-do-you-create-menus-with-CFEngine">How do you create menus with CFEngine</a>
<li><a accesskey="3" href="#How-do-I-select-from-menus">How do I select from menus</a>
<li><a accesskey="4" href="#How-do-I-nest-menus-and-make-dependencies">How do I nest menus and make dependencies</a>
<li><a accesskey="5" href="#Strong-and-weak-dependency">Strong and weak dependency</a>
<li><a accesskey="6" href="#How-do-I-see-what-machines-keep-which-promises">How do I see what machines keep which promises</a>
<li><a accesskey="7" href="#Can-I-see-a-score_002dcard-of-compliance">Can I see a score-card of compliance</a>
<li><a accesskey="8" href="#Should-I-use-menu-driven-configuration">Should I use menu driven configuration</a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<div class="node">
<a name="What-is-menu-driven-configuration"></a>
<a name="What-is-menu_002ddriven-configuration"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-you-create-menus-with-CFEngine">How do you create menus with CFEngine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is menu-driven configuration?</h3>

<pre class="sp">

</pre>
A menu is a list of simple choices. The purpose of a menu is to hide
the detailed breakdown of how those choices are implemented. A menu
item uses a single name to represent all the processes needed to bring
about the result. Naming things is an important aspect of knowledge
management.

   <p>Menus work well as long as the choices you are presented with are
sufficient to cover your needs.  If a menu is too short, it will force
you to choose sub-optimally, leading to an oversimplification of
your issues. This can lead to frustration and compromise.

   <p>CFEngine does not force pre-determined menus onto you, rather it
allows you to make your own from building block operations.  This
document explains how to simplify your interface to complex
configuration decisions by organizing it according to what amounts to
a number of context dependent menus &ndash; i.e. menus that automatically
adapt to the environments in which they are run.

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
Once menus have been defined, they can be presented simply in any kind of
interface, including custom graphical user interfaces. 
</td></tr></table>

   <pre class="sp">

</pre>

<div class="node">
<a name="How-do-you-create-menus-with-CFEngine"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-I-select-from-menus">How do I select from menus</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-menu_002ddriven-configuration">What is menu-driven configuration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">How do you create menus with CFEngine?</h3>

<pre class="sp">

</pre>

A menu is a list of delegated methods.  To create a menu, you need to
be able to name complex methods. CFEngine does this by grouping
promises into <i>bundles</i>. You must then present these bundles in some
kind of list for different machines in your environement to select
from. CFEngine has two mechanisms for presenting a bundle of lists.

     <ul>
<li>The first approach is to use the <code>bundlesequence</code> as your menu. This is the master
execution list that CFEngine uses to process work. You `choose' promise bundles there by
commenting out the ones you don't want to use:

     <pre class="verbatim">     body common control
     {
     bundlesequence => {
                       "common_stuff",
     #                    "change_management",
     #                    "garbage_collection",
     #                    "harden_xinetd",
     #                    "my_firewall",
                         "php_apache",
     #                    "j_def", "jboss_account", "jboss_server",
     #                    "ruby_on_rails",
     #                    "tomcat_server",
     #                    "db_mysql",
     #                    "db_postgresql",
                        };
     }
</pre>

     <p class="noindent">The advantage of the bundlesequence is that it provides a <i>definite ordering</i> of
the bundles. In the example above, the order doesn't matter much. The
disadvantage of this bundlesequence is that it is hard to adapt it to
more than one environment &ndash; it is like a `set taster menu'. Every
machine using this configuration will get what it's given. That is too
heavy-handed for more sophisticated environments.

     <li>The second approach is to use <code>methods</code> promises to embed bundles in a master-bundle,
in the manner of subroutines.

     <pre class="verbatim">     body common control
     {
     bundlesequence => {
                       "common_stuff",
                       "main",
                       };
     
     }
     
     bundle agent main
     {
     methods:
     
        context1:: # Menu for context 1
          "course2" usebundle => php_apache;
     
        context2:: # Menu for context 2
          "course2" usebundle => j_def;
          "course2" usebundle => jboss_account;
          "course2" usebundle => jboss_server;
     
        any::  # Menu items for everyone
          "course1" usebundle => changemanagement;
     
     }
</pre>
     In this example, we've just pointed the master bundlesequence to a `main' subroutine
(like in a C program) and we list the bundles we want to combine into menus in order, in different
contexts. So in context 1, machines see a PHP menu; in context 2, they see a Java menu. Both of them
get a common `dessert' of change management.

     <p>This `method' approach makes light work of adaptation, but while the
order is preserved in most cases, you cannot guarantee that CFEngine
will execute the bundles in the written order, because other
`transaction constraints' (including CFEngine's convergent algorithms)
can interfere. In many cases ordering is less important than we have been taught to
think, but if you truly need strong ordering then there are mechanisms to ensure
the strict order of keeping promises. 
</ul>

<div class="node">
<a name="How-do-I-select-from-menus"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-I-nest-menus-and-make-dependencies">How do I nest menus and make dependencies</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-you-create-menus-with-CFEngine">How do you create menus with CFEngine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">How do I select from menus?</h3>

<p>Because CFEngine is a distributed system, every machine running
CFEngine can make its own choices. You can suggest a menu for
different classes of machines, that operate in different contexts.

   <p>A machine selects a menu choice by virtue of being in a context that
has been defined. For instance, you might make separate menu choices based
on operating system:

<pre class="verbatim">bundle agent main
{
methods:

   ubuntu:: # Menu for context 1
     "course2" usebundle => php_apache;

   solaris:: # Menu for context 2
     "course2" usebundle => j_def;
     "course2" usebundle => jboss_account;
     "course2" usebundle => jboss_server;

   any::  # Menu items for everyone
     "course1" usebundle => changemanagement;

}
</pre>

<p class="noindent">Alternatively, you might choose based on other context information, such
as the time of day, or membership in some abstract group:

<pre class="verbatim">bundle agent main
{
methods:

   Hr16.Min45:: # Menu for context 1
     "course2" usebundle => backup_system;

   mygroup:: # Menu for context 2
     "course2" usebundle => attach_storage_devices;

}
</pre>

   <p>The expressions like &lsquo;<samp><span class="samp">Hr16.Min45</span></samp>&rsquo; are called `class expressions'
because they classify different contexts or scenarios, and CFEngine
knows how to keep promises only in the correct context. This is how
you select from a menu &ndash; by correctly identifying the context a
system belongs to and describing the menu of promise-bundles that apply to it.

<div class="node">
<a name="How-do-I-nest-menus-and-make-dependencies"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Strong-and-weak-dependency">Strong and weak dependency</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-I-select-from-menus">How do I select from menus</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">How do I nest menus and make dependencies?</h3>

<pre class="sp">

</pre>
Recursion is the term used to express a hierarchy of levels of description. 
When a promise depends on something else, which in turn depends on a third
promise being kept, we say that there is nesting or recursion.

   <p>A dependency (something we depend on to keep a promise) is often used as
a strategy for hiding detail. You push details into `black boxes' on which
you depend, and in doing so simpify the view for yourself. This is the menu
idea once again. So when you pick a menu item in the restaurant, the kitchen
breaks down your choice into a sub-menu of promises required to deliver your
selection, and so on down the chain.

   <p>CFEngine allows bundles of promises to depend on other promises by
writing those promises inside the bundles.  A bundle can even rely on
bundles of promises by using the <code>methods</code> approach
recursively. So, for example you could make a general menu choice
`setup_server', which depends on bundles `setup_general'
and `setup_solaris' and `setup_linux'.

<pre class="verbatim">bundle agent main
{
methods:                            # bulk dependency by bundle
   linux::
     "linux machines" usebundle => setup_linux;
   solaris:: 
     "sun machines" usebundle => setup_solaris;
   any::     
     "all" usebundle => setup_general;

files:
   # other promises
}

#

bundle agent setup_general
{
commands:                        # Dependenc on individual promise
   Hr06::
      "/usr/local/bin/do_backup"
         comment => "Command dependence";
}

bundle agent setup_linux
{
packages:
  ubuntu::                        # Dependence on software
    "apache2"
       package_policy => "add",
       package_method => "yum";

}

# other bundles ...
</pre>

   <p>Notice how each `menu level' simplifies the appearance of the problem by
hiding details in the lower levels. This is the way you make components
in systems and delegate responsibility for different tasks to different
bundle maintainers.

<div class="node">
<a name="Strong-and-weak-dependency"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-I-see-what-machines-keep-which-promises">How do I see what machines keep which promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-I-nest-menus-and-make-dependencies">How do I nest menus and make dependencies</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Strong and weak dependency</h3>

<pre class="sp">

</pre>

Weak dependency means that you `outsource' tasks that you will
eventually make use of, i.e. you depend on the outcomes but you don't
have to wait for the result. This kind of dependence brings
flexibility and allows delegation.

   <p>Strong dependency means that you are completely dependent on getting the
result from somewhere else before you can continue. This kind of
dependence creates fragile or `brittle' systems. If part of the system
breaks, then everything breaks. It leads to `single points of failure'.

   <p>We recommend avoiding strong dependency when designing systems. Whenever
possible, a system should survive the temporary loss of a part, and
should continue in a sensible and predictable manner.

<div class="node">
<a name="How-do-I-see-what-machines-keep-which-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Can-I-see-a-score_002dcard-of-compliance">Can I see a score-card of compliance</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Strong-and-weak-dependency">Strong and weak dependency</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">How do I see what machines keep which promises?</h3>

<pre class="sp">

</pre>
Once you have arranged your system promises in nested bundles to handle all of the
dependences, you no longer have a complete overview of the system. This is the challenge
of menu hierarchies &ndash; hierarchy simplifies for individuals by offloading
responsibility, but it makes it harder for anyone to get a total overview.

   <p>To get back to the total overview, you can use CFEngine's Knowledge Map.

   <div class="block-image"><img src="knowledge_bundle.png" alt="knowledge_bundle.png"></div>

   <p>The knowledge map renders all of the relationships between promises as
a lexicon and visual map. It allows you to see the total set of
promises and bundles either as a generic flat network, or as a
hierarchy. It also allows you to search for issues within the
total network. The knowledge map puts back what the hierarchy
takes away, by allowing you to construct your own view of the system.

   <p>If there are dependences they may be seen as a graphical representation
of issues. The lower image in this figure shows the direct dependences
of the `grant_reports' promises, i.e. all those that might be affected
by a change, and all those on which this promise depends.

   <div class="block-image"><img src="impact.png" alt="impact.png"></div>

<div class="node">
<a name="Can-I-see-a-score-card-of-compliance"></a>
<a name="Can-I-see-a-score_002dcard-of-compliance"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Should-I-use-menu-driven-configuration">Should I use menu driven configuration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-I-see-what-machines-keep-which-promises">How do I see what machines keep which promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Can I see a score-card of compliance?</h3>

<pre class="sp">

</pre>
One reason people make lists is to be able to tick off the
menu items to know when a job is complete. CFEngine allows
you to measure whether all of the menu-promises have been
kept, by viewing reports tied into the knowledge map.

   <p>There is one crucial difference between system configuration
and menus at a restaurant though: the order of the items in
the menu does not always have to be preserved, and in fact it is very
inefficient to use the menu as a strictly ordered list. 
Computer configuration can benefit greatly from parallel execution,
and CFEngine is designed to parallelize tasks for greater efficiency.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
We advise against designing systems that base their outcome on a
strict ordering of promises. Although traditional programming methods
teach us to think in terms of imperative ordering, you will succeed
more effectively if you avoid it. 
</td></tr></table>

<div class="node">
<a name="Should-I-use-menu-driven-configuration"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Can-I-see-a-score_002dcard-of-compliance">Can I see a score-card of compliance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Should I use menu driven configuration?</h3>

<pre class="sp">

</pre>
A menu driven approach is a good way of modelling a complex
environment, with delegation. It is a form of knowledge management. 
It allows you to view your system through a kind of compliance
scorecard.

   <p>The idea of nesting layers of menus is similar to what has been
advocated by Object Oriented programming languages for several
years. However, OO also shows how you can go too far in creating deep
and complex hierarchies that become impossible to understand. If you
create too many levels, you invite inefficiency and complexity.

   <p>We recommend keeping system organization simple, and avoiding
dependence whenever it does not provide a compelling and tangible
benefit.

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Menu Driven Configuration</a>
<ul>
<li><a href="#What-is-menu_002ddriven-configuration">What is menu-driven configuration?</a>
<li><a href="#How-do-you-create-menus-with-CFEngine">How do you create menus with CFEngine?</a>
<li><a href="#How-do-I-select-from-menus">How do I select from menus?</a>
<li><a href="#How-do-I-nest-menus-and-make-dependencies">How do I nest menus and make dependencies?</a>
<li><a href="#Strong-and-weak-dependency">Strong and weak dependency</a>
<li><a href="#How-do-I-see-what-machines-keep-which-promises">How do I see what machines keep which promises?</a>
<li><a href="#Can-I-see-a-score_002dcard-of-compliance">Can I see a score-card of compliance?</a>
<li><a href="#Should-I-use-menu-driven-configuration">Should I use menu driven configuration?</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

</body></html>

