<html lang="en">
<head>
<title>Iteration in CFEngine</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Iteration in CFEngine">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background: none !important;
    border: none !important;
    padding: 5px; 

/*    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;*/
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Iteration in CFEngine</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-Iteration_003f">What is Iteration?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Iteration</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-Iteration_003f">What is Iteration?</a>
<li><a accesskey="2" href="#Iterated-promises">Iterated promises</a>
<li><a accesskey="3" href="#Iterating-across-multiple-lists">Iterating across multiple lists</a>
<li><a accesskey="4" href="#Iterating-over-nested-lists">Iterating over nested lists</a>
<li><a accesskey="5" href="#Fixing-Iterating-across-nested-lists">Fixing Iterating across nested lists</a>
<li><a accesskey="6" href="#Iterating-revisted">Iterating revisted</a>
<li><a accesskey="7" href="#Nesting-promises-workaround">Nesting promises workaround</a>
<li><a accesskey="8" href="#Power">Power</a>
<li><a accesskey="9" href="#Summary-of-iteration">Summary of iteration</a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<div class="node">
<a name="What-is-Iteration%3f"></a>
<a name="What-is-Iteration_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Iterated-promises">Iterated promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What is iteration?</h3>

<pre class="sp">

</pre>

Iteration is about repeating operations in a list.  In CFEngine,
iteration is used to make a number of related promises, that fall into
a pattern based on elements of a list. This is what would correspond
to something like this pseudo-code in an imperative language:

   <blockquote>
<i> foreach item in list</i><br>
      <i>make promise</i><br>
<i>end</i>
</blockquote>

<p class="noindent">In CFEngine, we do not write loops; rather, they are implicit. 
Suppose &lsquo;<samp><span class="samp">@(list)</span></samp>&rsquo; is a list variable (the &lsquo;<samp><span class="samp">@</span></samp>&rsquo; means list). If we
refer to this identifier using a scalar reference &lsquo;<samp><span class="samp">$(list)</span></samp>&rsquo;, then
CFEngine understands this to mean, take each scalar item in the list and
repeat the current promise, replacing the instance with elements of the list
in turn.

<div class="node">
<a name="Iterated-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Iterating-across-multiple-lists">Iterating across multiple lists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-Iteration_003f">What is Iteration?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Iterated promises</h3>

<p>Consider the following set of promises to report on the values of four
separate monitor values:

<pre class="verbatim">bundle agent no_iteration
{
reports:
  cfengine_3::
    "mon.value_rootprocs is $(mon.value_rootprocs)";
    "mon.value_otherprocs is $(mon.value_otherprocs)";
    "mon.value_diskfree is $(mon.value_diskfree)";
    "mon.value_loadavg is $(mon.value_loadavg)";
}
</pre>

   <p>What we did was create four distinct reports, where each report announces
which monitor variable it will be reporting, and the follows with the actual
value of that monitor variable.  For simple reports, this is perfectly
adequate and straightforward, but it lacks abstraction and repeatability. 
Suppose we wanted to add a variable to report, we'd need a new report
promise.  If we wanted to change the wording of the reports, we'd possibly
have to edit four promises, and this can be time consuming and error-prone.

   <p>Consider instead the following example, which generates exactly the same reports:

<pre class="verbatim">bundle agent iteration1
{
vars:
    "monvars" slist => {
		       "rootprocs",
                       "otherprocs",
                       "diskfree",
                       "loadavg"
                       };

reports:

  cfengine_3::

    "mon.value_$(monvars) is $(mon.value_$(monvars))";
}
</pre>

   <p>What we have done is to first specify a list variable <code>monvars</code>, and then
iterate over the values contained in that list by referencing the list
variable <i>as a scalar</i>.  In CFEngine, simply referring to a list variable
as a scalar automatically iterates over that variable.

   <p>Note that in terms of raw "lines of code", neither example shows an advantage
(and in fact, the reports that are created by the iteration in this second
example are <i>identical</i> to the reports in the first example).

   <p>However, we already have a gain in maintainer efficiency.  By changing the
single report format, we automatically change all the reports.  And we have
separated the semantics of the reports from the list of monitoring variables.

   <p>Admittedly, this is a simple example, but if you understand this one, we can
continue with more compelling examples.

<div class="node">
<a name="Iterating-across-multiple-lists"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Iterating-over-nested-lists">Iterating over nested lists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Iterated-promises">Iterated promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Iterating across multiple lists</h3>

<pre class="sp">

</pre>
Although iteration is a powerful concept in and of itself, CFEngine can
iterate across multiple lists simultaneously.  In the previous example, we
looked at the current values of four monitor variables, but since CFEngine
also gives us access to the averaged values and the standard deviation, how
would we create a series of reports that listed all three statistical
components of each variable?  The answer is simply to do another iteration:

<pre class="verbatim">bundle agent iteration2
{
vars:
    "stats"   slist => { "value", "av", "dev" };

    "monvars" slist => {
                       "rootprocs",
                       "otherprocs",
                       "diskfree",
                       "loadavg"
                       };
reports:

  cfengine_3::
    "mon.$(stats)_$(monvars) is $(mon.$(stats)_$(monvars))";
}
</pre>

   <p>Through the addition of a new list called <code>stats</code>, we can now iterate
over both it and the <code>monvars</code> list in the same promise.  The reports
that we thus generate will report on <code>value_rootprocs</code>,
<code>av_rootprocs</code>, and <code>dev_rootprocs</code>, followed next by
<code>value_otherprocs</code>, <code>av_otherprocs</code>, etc, ending finally with
<code>dev_loadavg</code>.  The leftward lists are iterated over completely before
going to the next value in the rightward lists.

<div class="node">
<a name="Iterating-over-nested-lists"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Fixing-Iterating-across-nested-lists">Fixing Iterating across nested lists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Iterating-across-multiple-lists">Iterating across multiple lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Iterating over nested lists</h3>

<p>Recall that CFEngine iterates over complete promise units, not small parts of
a promise. Let's look at an example that could show a common misunderstanding.

   <p>If you look at the monitor variables that are described in the CFEngine
Reference Guide, you'll notice that some variables reference the number of
packets <i>in</i> and <i>out</i> of a host.  So you might be
tempted to do the following, which might not do what you expect.

<pre class="verbatim">bundle agent iteration3a
{
vars:
    "stats" slist => { "value", "av", "dev" };
    "inout" slist => { "in", "out" };

    "monvars" slist => {
		"rootprocs",	"otherprocs",
		"diskfree",
		"loadavg",
		"smtp_$(inout)",  #
		"www_$(inout)",   # look here
		"wwws_$(inout)"   #
		};

reports:
  cfengine_3::
    "mon.$(stats)_$(monvars) is $(mon.$(stats)_$(monvars))";
}
</pre>
What this says is, for each value in &lsquo;<samp><span class="samp">$(inout)</span></samp>&rsquo;, define &lsquo;<samp><span class="samp">monvars</span></samp>&rsquo;
to be a variable. There are thus two attempts to defined the single name &lsquo;<samp><span class="samp">monvars</span></samp>&rsquo;
as a list with two different right-hand-sides (one for `in' and one for `out'). 
This will result in the error:

<pre class="smallexample">      !! Redefinition of variable "monvars" (embedded list in RHS) in context "iteration3a"
      !! Redefinition of variable "monvars" (embedded list in RHS) in context "iteration3a"
</pre>
   <p>Whenever a promise contains an iteration (that is, when the promise string or
any of its attributes contain a scalar reference to a list variable), that
promise is automatically re-stated with successive values from the list.  So
the example above is exactly the same as if we had said the following:

<pre class="verbatim">bundle agent iteration3b
{
vars:
    "stats" slist => { "value", "av", "dev" };

    "monvars" slist => {
		"rootprocs",	"otherprocs",
		"diskfree",
		"loadavg",
		"smtp_in",
		"www_in",	"wwws_in"
		};

    "monvars" slist => {
		"rootprocs",	"otherprocs",
		"diskfree",
		"loadavg",
		"smtp_out",
		"www_out",	"wwws_out"
		};

reports:
  cfengine_3::
    "mon.$(stats)_$(monvars) is $(mon.$(stats)_$(monvars))";
}
</pre>

   <p>Notice that the promise is repeated twice, but the only thing that is
different is the <i>right hand side</i> of the promise &ndash; the contents of the
list, expanded using iteration over the <code>inout</code> list variable.  Not only
will this not do what we want, it will generate an error, because the second
promise on the variable <code>monvars</code> will overwrite the value promised in
the first promise!  All that we will see in the reports are the <i>second</i>
definition of the <code>monvars</code> list.

<div class="node">
<a name="Fixing-Iterating-across-nested-lists"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Iterating-revisted">Iterating revisted</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Iterating-over-nested-lists">Iterating over nested lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Fixing Iterating across nested lists</h3>

<pre class="verbatim">bundle agent iteration3c
{
vars:
    "stats" slist => { "value", "av", "dev" };
    "inout" slist => { "in", "out" };

    "monvars_$(inout)" slist => {
                                "smtp_$(inout)",  #
                                "www_$(inout)",   # look here
                                "wwws_$(inout)"   #
                                };

reports:
  cfengine_3::
    "mon.$(stats)_$(monvars_in)  is $(mon.$(stats)_$(monvars_in))";
    "mon.$(stats)_$(monvars_out) is $(mon.$(stats)_$(monvars_out))";
}

</pre>
CFEngine does not allow an unlimited level of nesting, for reasons of
efficiency and readability, and adding further levels of nesting
will start to work against you.  Note that we had to explicitly refer to the
two variables that we created: <code>$(monvars_in)</code> and
<code>$(monvars_out)</code>, and specifying more will get very messy very quickly. 
However, the next sections show an easier-to-read workaround.

<div class="node">
<a name="Iterating-revisted"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Nesting-promises-workaround">Nesting promises workaround</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Fixing-Iterating-across-nested-lists">Fixing Iterating across nested lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Iterating across multiple lists, revisted</h3>

<p>When a list variable is referenced as a scalar variable (that is, when
the list variable is referenced as <code>$(list)</code>) instead of as a
list (using <code>@(list)</code>), CFEngine assumes that it should
substitute each scalar from the list in turn, and thus iterate over
the list elements using a loop.

   <p>If more than one list variable is referenced in this manner in a
single promise, each list variable is iterated over, so that every
possible combination of scalar components is represented.  Consider
the following example.

   <p>In this example, note that the <code>letters</code> list is
referenced in both the left-hand and right-hand side of the promise,
the <code>digits</code> list is referenced only in the left-hand side, and
the <code>symbols</code> list is only referenced in the left-hand side:

<pre class="verbatim">bundle agent iteration4a
{
vars:
    "letters" slist => { "a", "b" };
    "digits"  slist => { "1", "2" };
    "symbols" slist => { "@", "#" };

commands:
    "/bin/echo ${letters}, ${digits}+${digits}, "
	args => "${letters} and ${symbols}'";
}
</pre>

   <p>Like a backwards-reading odometer, the left-most variable cycles the fastest
and the right-most list cycles the slowest.  Most importantly, no matter how
many times or places a list variable is referenced as a scalar in a single
promise, each combination of values is visited <i>only once</i>, regardless of
whether the iteration variable is in the lefthand side or the righthand side
of a promise or both.

   <p>The example above is exactly equivalent to this (much more) verbose set of
promises.  As you can see, there are <code>2*2*2 = 8</code> promises generated,
which contains every possible comination of elements from the lists
<code>letters</code>, <code>digits</code>, and <code>symbols</code>:

<pre class="verbatim">bundle agent iteration4b
{
commands:
    "/bin/echo a, 1+1, "
	args => "a and @";
    "/bin/echo b, 1+1, "
	args => "b and @";
    "/bin/echo a, 2+2, "
	args => "a and @";
    "/bin/echo b, 2+2, "
	args => "b and @";
    "/bin/echo a, 1+1, "
	args => "a and #";
    "/bin/echo b, 1+1, "
	args => "b and #";
    "/bin/echo a, 2+2, "
	args => "a and #";
    "/bin/echo b, 2+2, "
	args => "b and #";
}
</pre>

<div class="node">
<a name="Nesting-promises-workaround"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Power">Power</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Iterating-revisted">Iterating revisted</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Nesting promises workaround</h3>

<p>Recall the problem of nesting iterations, we can now see how to repair
our error.  The key is to ensure that there is a distinct and unique
promise created for every combination of iterated variables that we
want to use.  Here is how to solve the problem of listing the input
and output packet counts:

<pre class="verbatim">bundle agent iteration5a
{
vars:
    "stats" slist => { "value", "av", "dev" };
    "inout" slist => { "in", "out" };
    "io_names" slist => { "smtp", "www", "wwws" };
    "io_vars[$(io_names)_$(inout)]" int => "0";
    "monvars" slist => {
		"rootprocs",	"otherprocs",
		"diskfree",
		"loadavg",
		getindices("io_vars")
		};

reports:
  cfengine_3::
    "mon.$(stats)_$(monvars) is $(mon.$(stats)_$(monvars))";
}
</pre>

<p class="noindent">The output of this is
<pre class="smallexample">     R: mon.value_rootprocs is $(mon.value_rootprocs)
     R: mon.av_rootprocs is $(mon.av_rootprocs)
     R: mon.dev_rootprocs is $(mon.dev_rootprocs)
     R: mon.value_otherprocs is $(mon.value_otherprocs)
     R: mon.av_otherprocs is $(mon.av_otherprocs)
     R: mon.dev_otherprocs is $(mon.dev_otherprocs)
     R: mon.value_diskfree is $(mon.value_diskfree)
     R: mon.av_diskfree is $(mon.av_diskfree)
     R: mon.dev_diskfree is $(mon.dev_diskfree)
     R: mon.value_loadavg is $(mon.value_loadavg)
     R: mon.av_loadavg is $(mon.av_loadavg)
     R: mon.dev_loadavg is $(mon.dev_loadavg)
     R: mon.value_wwws_in is $(mon.value_wwws_in)
     R: mon.av_wwws_in is $(mon.av_wwws_in)
     R: mon.dev_wwws_in is $(mon.dev_wwws_in)
     R: mon.value_www_out is $(mon.value_www_out)
     R: mon.av_www_out is $(mon.av_www_out)
     R: mon.dev_www_out is $(mon.dev_www_out)
     R: mon.value_www_in is $(mon.value_www_in)
     R: mon.av_www_in is $(mon.av_www_in)
     R: mon.dev_www_in is $(mon.dev_www_in)
     R: mon.value_smtp_in is $(mon.value_smtp_in)
     R: mon.av_smtp_in is $(mon.av_smtp_in)
     R: mon.dev_smtp_in is $(mon.dev_smtp_in)
     R: mon.value_wwws_out is $(mon.value_wwws_out)
     R: mon.av_wwws_out is $(mon.av_wwws_out)
     R: mon.dev_wwws_out is $(mon.dev_wwws_out)
     R: mon.value_smtp_out is $(mon.value_smtp_out)
     R: mon.av_smtp_out is $(mon.av_smtp_out)
     R: mon.dev_smtp_out is $(mon.dev_smtp_out)
</pre>
   <p>In this case, all we are doing is creating an array called <code>io_vars</code>. 
Note that the indices of the elements of the array are iterated from <i>two</i>
lists, so in this case we'll have <code>2*3 = 6</code> elements in the array,
covering all the combinations of the two lists <code>inout</code> and
<code>inout-names</code>.

   <p>The values of the array elements can be whatever we like.  In this case, we're
making all the values <code>0</code>, because we don't care what the actual values
are &ndash; we only care about the <i>keys</i> of the array.  We add the list of the
keys to the <code>monvars</code> list by using the return value from
<code>getindices("io_vars")</code>.

   <p>Looking at the example above, you might just as easily be tempted to do the
following:

<pre class="verbatim">bundle agent iteration5b
{
vars:
    "stats" slist => { "value", "av", "dev" };
    "inout" slist => { "in", "out" };
    "io_names" slist => { "smtp", "www", "wwws" };
    "io_vars[$(io_names)_$(inout)]" string => "$(io_names)_$(inout)";
    "monvars" slist => {
		"rootprocs",	"otherprocs",
		"diskfree",
		"loadavg",
		@(io_vars)
		};

reports:
  cfengine_3::
    "mon.$(stats)_$(monvars) is $(mon.$(stats)_$(monvars))";
}
</pre>
However, this is wrong. 
We cannot use <code>@(io_vars)</code>, because <code>io_vars</code> is not a
<i>list</i>, it is an <i>array</i>!  You can only use the <code>@</code> dereferencing
sigil on lists.

<div class="node">
<a name="Power"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Summary-of-iteration">Summary of iteration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Nesting-promises-workaround">Nesting promises workaround</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">The power of iteration in CFEngine</h3>

<p>Iteration and abstraction are power tools in CFEngine.  In closing, consider
the following simple and straightforward example, where we report on all of
the monitoring variables available to us in CFEngine:

<pre class="verbatim">bundle agent iteration6
{
vars:
    "stats" slist => {"value", "av", "dev"};

    "inout" slist => {"in", "out"};
    "io_names" slist => {
     		"netbiosns", "netbiosdgm", "netbiosssn",
		"irc",
		"cfengine",
		"nfsd",
		"smtp",
		"www",		"wwws",
		"ftp",
		"ssh",
		"dns",
		"icmp", 	"udp",
		"tcpsyn",	"tcpack",	"tcpfin",	"tcpmisc"
		};
    "io_vars[$(io_names)_$(inout)]" string => "$(io_names)_$(inout)";

    "n" slist => {"0", "1", "2", "3"};
    "n_names" slist => {
		"temp",
		"cpu"
		};
    "n_vars[$(n_names)$(n)]" string => "$(n_names)$(n)";

    "monvars" slist => {
		"rootprocs",	"otherprocs",
		"diskfree",
		"loadavg",
		"webaccess",	"weberrors",
		"syslog",
		"messages",
		getindices("io_vars"),
		getindices("n_vars")
		};

reports:
  cfengine_3::
    "mon.$(stats)_$(monvars) is $(mon.$(stats)_$(monvars))";
}
</pre>

   <p>In this example, we create a two arrays (<code>io_vars</code> and <code>n_vars</code>),
and a number of lists (but the most important ones are <code>stats</code> and
<code>monvars</code>).  We have but a single report promise, but it iterates over
these latter two lists.  With only a single reports promise and intelligent
use of lists and arrays, we are able to report on every one of the
<code>3*(8+2*18+4*2)==156</code> monitor variables.  And to change the format of
every report, we will only have a single statement to change.

<div class="node">
<a name="Summary-of-iteration"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Power">Power</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Summary of iteration</h3>

<p>Used judiciously and intelligently, iterators are a powerful way of
expressing patterns.  They enable you to abstract out the concepts
from the nitty-gritty details, and to specify, in very few lines,
complex combinations of elements. Perhaps more importantly, they ease
the burden of maintainability, by making short work of
repetitive problems.

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Iteration</a>
<ul>
<li><a href="#What-is-Iteration_003f">What is iteration?</a>
<li><a href="#Iterated-promises">Iterated promises</a>
<li><a href="#Iterating-across-multiple-lists">Iterating across multiple lists</a>
<li><a href="#Iterating-over-nested-lists">Iterating over nested lists</a>
<li><a href="#Fixing-Iterating-across-nested-lists">Fixing Iterating across nested lists</a>
<li><a href="#Iterating-revisted">Iterating across multiple lists, revisted</a>
<li><a href="#Nesting-promises-workaround">Nesting promises workaround</a>
<li><a href="#Power">The power of iteration in CFEngine</a>
<li><a href="#Summary-of-iteration">Summary of iteration</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

</body></html>

