<html lang="en">
<head>
<title>Reporting</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Reporting">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background: none !important;
    border: none !important;
    padding: 5px; 

/*    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;*/
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Reporting</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-are-monitoring-and-reporting_003f">What are monitoring and reporting?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Reporting</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-are-monitoring-and-reporting_003f">What are monitoring and reporting?</a>
<li><a accesskey="2" href="#Should-monitoring-and-configuration-be-separate_003f">Should monitoring and configuration be separate?</a>
<li><a accesskey="3" href="#Reporting-in-CFEngine">Reporting in CFEngine</a>
<li><a accesskey="4" href="#Standard-reports-in-CFEngine">Standard reports in CFEngine</a>
<li><a accesskey="5" href="#CFEngine-output-levels">CFEngine output levels</a>
<li><a accesskey="6" href="#Creating-custom-reports-_002d_002d-all-versions">Creating custom reports -- all versions</a>
<li><a accesskey="7" href="#Including-data-in-reports">Including data in reports</a>
<li><a accesskey="8" href="#Creating-custom-logs">Creating custom logs</a>
<li><a accesskey="9" href="#Redirecting-output-to-logs">Redirecting output to logs</a>
<li><a href="#Change-auditing-_002d-the-all-seeing-eye">Change auditing - the all seeing eye</a>
<li><a href="#Cheaper-options-_002d-tripwires">Cheaper options - tripwires</a>
<li><a href="#Commerical-edition-measurements-promises">Commerical edition measurements promises</a>
<li><a href="#Hub-reporting">Hub reporting</a>
<li><a href="#Mission-Portal-access-to-the-hub">Mission Portal access to the hub</a>
<li><a href="#Command-line-access-to-the-hub">Command line access to the hub</a>
<li><a href="#Example-command-hub-searches">Example command hub searches </a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<div class="node">
<a name="What-are-monitoring-and-reporting%3f"></a>
<a name="What-are-monitoring-and-reporting_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Should-monitoring-and-configuration-be-separate_003f">Should monitoring and configuration be separate?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What are monitoring and reporting?</h3>

<pre class="sp">

</pre>
Monitoring is the sampling of system variables at regular intervals in
order to present an overview of actual changes taking place over time. 
Monitoring data are often presented as extensive views of moving-line
time series. Monitoring has the ability to detect anomalous behaviour
by comparing past and present.

   <p>The term <i>reporting</i> is usually taken to mean the creation of short
summaries of specific system properties suitable for
management. System reports describe both promises about the system,
such as compliance, discovered changes and faults.

   <p>The challenge of both these activities is to compare <i>intended</i> or
<i>promised</i>, behaviour with the <i>actual</i> observed behaviour of the
system.

<div class="node">
<a name="Should-monitoring-and-configuration-be-separate%3f"></a>
<a name="Should-monitoring-and-configuration-be-separate_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reporting-in-CFEngine">Reporting in CFEngine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-are-monitoring-and-reporting_003f">What are monitoring and reporting?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Should monitoring and configuration be separate?</h3>

<pre class="sp">

</pre>
The traditional view of IT operations is that configuration,
monitoring and reporting are three different things that should not be
joined. Traditionally, all three have been independent centralized
processes. This view has emerged historically, but it has a major
problem. Humans are needed to glue these parts back together.

   <p>Monitoring as an independent activity is inherently non-scalable. 
When numbers of hosts grow beyond a few thousands, centralized
monitoring schemes fail to manage the information. Tying configuration
(and therefore repair) to monitoring at the host level is essential
for the effective management of large and distributed data facilities. 
CFEngine foresaw this need in 1998, with its Computer Immunology
initiative, and continues to develop this strategy.

   <p>CFEngine's approach is to focus on scalability. The commercial editions
of CFEngine provide what meaningful information they can in a manner that
can be scaled to tens of thousands of machines.

<div class="node">
<a name="Reporting-in-CFEngine"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Standard-reports-in-CFEngine">Standard reports in CFEngine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Should-monitoring-and-configuration-be-separate_003f">Should monitoring and configuration be separate?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Reporting in CFEngine</h3>

<pre class="sp">

</pre>

<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
If you have regular reporting needs, we recommend using our commercially supported
version of CFEngine (CFEngine Nova or above), as you will save considerable time
and resources in programming, and you will have access to the latest developments
through the software subscription. 
</td></tr></table>

   <p>No promises made in CFEngine imply automatic aggregation of data to a central
location. In commercial CFEngine versions, e.g. CFEngine Nova, an optimized
aggregation of standardized reports is provided, but the ultimate decision to
aggregate must be yours.

   <p>Monitoring and reporting capabilities in CFEngine depend on the
software version include:

     <ul>
<li><b>Community Edition:</b> Basic output to file or logs may be customized on a per-promise basis. Users can design their own log and report formats, but data processing and extraction from CFEngine's embedded databases must be scripted by the user.

     <li><b>Nova:</b> In addition to community features, Nova/Enterprise provides automated extraction of
data from CFEngine's self-learning agents, and the generation of a
standard set of reports in text, HTML or XML formats. Nova summarizes
distributed data and provides simple compression and aggregation of
these summaries. Finally summaries are tied into a knowledge map or
semantic index for browsing by IT operations. Command line tools in
<code>cf-report</code> are also available for Nova users to browse network-wide data.

   </ul>

<div class="node">
<a name="Standard-reports-in-CFEngine"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#CFEngine-output-levels">CFEngine output levels</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reporting-in-CFEngine">Reporting in CFEngine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Standard reports in CFEngine</h3>

<p>The following list of reports are only available in full in commercial editions of
CFEngine. Some sample reports are provided in the Community Edition.
     <dl>
<dt><em>Available patches report</em><dd>Patches already installed on system if available. 
<br><dt><em>Classes report</em><dd>User defined classes observed on the system &ndash; inventory data. 
<br><dt><em>Compliance report</em><dd>Total summary of host compliance, all promises aggregated over time. 
<br><dt><em>File_changes report</em><dd>Latest observed changes to system files with time discovered. 
<br><dt><em>File_diffs report</em><dd>Latest observed differences to system files, in a simple diff format. 
<br><dt><em>Hashes report</em><dd>File hash values measured (change detection). 
<br><dt><em>Installed patches report</em><dd>Patches not yet installed, but published by vendor if available. 
<br><dt><em>Installed software report</em><dd>Software already installed on system if available. 
<br><dt><em>Lastseen report</em><dd>Time and frequency of communications with peers, host reliability. 
<br><dt><em>Micro-audit report</em><dd>Generated by CFEngine self-auditing. This report is not aggregated. 
<br><dt><em>Monitor summary report</em><dd>Pseudo-real-time measurement of time series data. 
<br><dt><em>Performance report</em><dd>Time cost of verifying system promises. 
<br><dt><em>Promise report</em><dd>Per-promise average compliance report over time. 
<br><dt><em>Promises not kept report</em><dd>Promises that were recently un-kept. 
<br><dt><em>Promises repaired report</em><dd>Promises that were recently kept by repairing system state. 
<br><dt><em>Setuid report</em><dd>Known setuid programs found on system. 
<br><dt><em>Variables report</em><dd>Current variable values expanded on different hosts. 
</dl>

<div class="node">
<a name="CFEngine-output-levels"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Creating-custom-reports-_002d_002d-all-versions">Creating custom reports -- all versions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Standard-reports-in-CFEngine">Standard reports in CFEngine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">CFEngine output levels</h3>

<pre class="sp">

</pre>

CFEngine's default behaviour is to report to the console (known as
standard output). It's default behaviour is to report nothing except
errors that are judged to be of a critical nature.

   <p>By using CFEngine with the inform flag:
<pre class="verbatim"># cf-agent -I
# cf-agent --inform
</pre>
you can alter the default to report on action items (actual changes)
and warnings.

   <p>By using CFEngine with the verbose flag:
<pre class="verbatim"># cf-agent -v
# cf-agent --verbose
</pre>
you can alter the default to report all of its thought-processes. 
You should not interpret a message that only appears in CFEngine's
verbose mode as an actual error, only as information that might be relevant
to decisions being made by the agent.

<div class="node">
<a name="Creating-custom-reports----all-versions"></a>
<a name="Creating-custom-reports-_002d_002d-all-versions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Including-data-in-reports">Including data in reports</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CFEngine-output-levels">CFEngine output levels</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Creating custom reports &ndash; all versions</h3>

<pre class="sp">

</pre>

CFEngine allows you to use <code>reports</code> promises to
make reports of your own. A simple example of this is shown below.

<pre class="verbatim">body common control
{
bundlesequence => { "test" };
}

#

bundle agent test
{
reports:

  cfengine_3::

   "$(sys.date),This is a report"
     report_to_file => "/tmp/test_log";
}

</pre>

<p class="noindent">We can apply this idea to make more useful custom
reports.  In this example, the agent tests for certain software
package and creates a simple HTML file of existing software.

<pre class="verbatim">body common control
{
bundlesequence => { "test" };
}

#

bundle agent test
{
vars:

 "software" slist => { "gpg", "zip", "rsync" };

classes:

 "no_report"        expression => fileexists("/tmp/report.html");
 "have_$(software)" expression => fileexists("/usr/bin/$(software)");

reports:

  no_report::

      "
      &lt;html>
      Name of this host is: $(sys.host)&lt;br>
      Type of this host is: $(sys.os)&lt;br>
      "

         report_to_file => "/tmp/report.html";

      #

      "
      Host has software $(software)&lt;br>
      "

        ifvarclass     => "have_$(software)",
        report_to_file => "/tmp/report.html";

      #

      "
      &lt;/html>
      "
         report_to_file => "/tmp/report.html";

}
</pre>

<p class="noindent">The outcome of this promise is a file called <samp><span class="file">/tmp/report.html</span></samp>
containing output like this:

<pre class="verbatim">      &lt;html>
      Name of this host is: atlas&lt;br>
      Type of this host is: linux&lt;br>

      Host has software gpg&lt;br>

      Host has software zip&lt;br>

      Host has software rsync&lt;br>

      &lt;/html>
</pre>

   <p>The mechanism shown above, can clearly be used to create a wide
variety of report formats, but it requires a lot of coding and
maintenance by the user.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
CFEngine Nova simplifies this kind of report generation by enabling
and updating many out-of-the-box reports directly from the
<code>cf-report</code> agent. 
</td></tr></table>

<div class="node">
<a name="Including-data-in-reports"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Creating-custom-logs">Creating custom logs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Creating-custom-reports-_002d_002d-all-versions">Creating custom reports -- all versions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Including data in reports</h3>

<p>CFEngine generates information internally that you might want to use
in reports. For example, the agent <code>cf-agent</code>
interfaces with the local light-weight monitoring
agent <code>cf-monitord</code> so that system state can be reported simply:

<pre class="verbatim">
body common control

{
bundlesequence  => { "report" };
}

###########################################################

bundle agent report

{
reports:

  linux::

   "/etc/passwd except $(const.n)"

     showstate => { "otherprocs", "rootprocs" };

}

</pre>

<p class="noindent">A corollary to this is that you can get CFEngine to report
system anomalies.

<pre class="verbatim">reports:

 rootprocs_high_dev2::

   "RootProc anomaly high 2 dev on $(mon.host) at approx $(mon.env_time) 
    measured value $(mon.value_rootprocs) 
    average $(mon.average_rootprocs) pm $(mon.stddev_rootprocs)"

      showstate => { "rootprocs" };

 entropy_www_in_high&amp;anomaly_hosts.www_in_high_anomaly::

   "High entropy incoming www anomaly on $(mon.host) at $(mon.env_time) 
    measured value $(mon.value_www_in) 
    average $(mon.average_www_in) pm $(mon.stddev_www_in)"
   
      showstate => { "incoming.www" };

</pre>

<p class="noindent">This produces standard output of the form:

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">R: State of otherprocs peaked at Tue Dec  1 12:12:21 2009

R: The peak measured state was q = 98:
R: Frequency: [kjournald]      |**      (2/98)
R: Frequency: [pdflush]        |**      (2/98)
R: Frequency: /var/cfengine/bin/cf-execd|**     (2/98)
R: Frequency: COMMAND          |*       (1/98)
R: Frequency: init [5]         |*       (1/98)
R: Frequency: [kthreadd]       |*       (1/98)
R: Frequency: [migration/0]    |*       (1/98)
R: Frequency: [ksoftirqd/0]    |*       (1/98)
R: Frequency: [events/0]       |*       (1/98)
R: Frequency: [khelper]        |*       (1/98)
R: Frequency: [kintegrityd/0]  |*       (1/98)
</pre>
</td></tr></table>

<p class="noindent">Finally, you can quote lines from files in your data
for convenience.

<pre class="verbatim">
body common control

{
bundlesequence  => { "report" };
}

###########################################################

bundle agent report

{
reports:

  linux::

   "/etc/passwd except $(const.n)"

     printfile => pr("/etc/passwd","5");

}

######################################################################

body printfile pr(file,lines)

{
file_to_print => "$(file)";
number_of_lines => "$(lines)";
}

</pre>

<p class="noindent">This produces output of the form

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">R: /etc/passwd except
R: at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash
R: avahi:x:103:105:User for Avahi:/var/run/avahi-daemon:/bin/false
R: beagleindex:x:104:106:User for Beagle indexing:/var/cache/beagle:/bin/bash
R: bin:x:1:1:bin:/bin:/bin/bash
R: daemon:x:2:2:Daemon:/sbin:/bin/bash
</pre>
</td></tr></table>

<div class="node">
<a name="Creating-custom-logs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Redirecting-output-to-logs">Redirecting output to logs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Including-data-in-reports">Including data in reports</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Creating custom logs</h3>

<pre class="sp">

</pre>

Logs can be attached to any promise. In this example, an executed shell command
logs a message to the standard output. CFEngine recognizes the <code>stdout</code>
filename for Standard Output, in the Unix/C standard manner.

<pre class="verbatim">bundle agent test
{
commands:

  "/tmp/myjob",

     action => logme("executor");

}

############################################

body action logme(x)
{
log_repaired => "stdout";
logstring => " -> Started the $(x) (success)";
}
</pre>

<p class="noindent">In this next example, a file creation promise
logs different outcomes (success or failure) to different
log files.

<pre class="verbatim">body common control
{
bundlesequence => { "test" };
}

bundle agent test
{
vars:

  "software" slist => { "/root/xyz", "/tmp/xyz" };

files:

  "$(software)"

    create => "true",
     action => logme("$(software)");

}

#

body action logme(x)
{
log_kept => "/tmp/private_keptlog.log";
log_failed => "/tmp/private_faillog.log";
log_repaired => "/tmp/private_replog.log";
log_string => "$(sys.date) $(x) promise status";
}

</pre>

<p class="noindent">This generates three different logs with outputs in of the form:

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">atlas$ more /tmp/private_keptlog.log
Sun Dec  6 11:58:16 2009 /tmp/xyz promise status
Sun Dec  6 11:58:43 2009 /tmp/xyz promise status
</pre>
</td></tr></table>

<div class="node">
<a name="Redirecting-output-to-logs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Change-auditing-_002d-the-all-seeing-eye">Change auditing - the all seeing eye</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Creating-custom-logs">Creating custom logs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Redirecting output to logs</h3>

<pre class="sp">

</pre>

CFEngine interfaces with the system logging tools in different ways. 
Syslog is the default log for Unix-like systems, while the event
logger is the default on Windows. You may choose to copy a fixed
level of CFEngine's standard screen messaging to the system logger
on a per-promise basis.

<pre class="verbatim">body common control
{
bundlesequence => { "one" };
}


bundle agent one
{
files:

  "/tmp/xyz"

       create => "true",
       action => log;
}

body action log
{
log_level => "inform";
}
</pre>

<div class="node">
<a name="Change-auditing---the-all-seeing-eye"></a>
<a name="Change-auditing-_002d-the-all-seeing-eye"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cheaper-options-_002d-tripwires">Cheaper options - tripwires</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Redirecting-output-to-logs">Redirecting output to logs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Change auditing - the all seeing eye</h3>

<pre class="sp">

</pre>

Total auditing of a system is a surprisingly difficult thing to do,
and it is extremely resource intensive. The followers of an audit
trail are often paranoid by nature and are seldom satisfied with the
level of detail they find. However, the times we really need an audit
are rare, but the cost is ever present. The price of certainty is high.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
Spend a moment considering this: if you want to describe every change
of state that happens on a computer, then you need to remember old
state and compare it to new state. Then you have to record the
differences. So you need more than the entire size of your computer's
normal resources to do this. Your storage efficiency will always be
less than 50% and your processing efficiency will be less than 50% on
every audited item. Is this worth the effort? Perhaps your resources
would be better spent keeping targeted backups and simply rebuilding
contaminated systems. 
</td></tr></table>

   <p>Switch on auditing like this:

<pre class="verbatim">body agent control
{
auditing  => "true";
}

</pre>

   <p>If you decide to go for full auditing, CFEngine will not collect and
centralize the reports as they will be too large for this to be a
scalable operation. Still, you can view them in a web browser on the
local host, or copy them manually to a suitable location.

<div class="node">
<a name="Cheaper-options---tripwires"></a>
<a name="Cheaper-options-_002d-tripwires"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Commerical-edition-measurements-promises">Commerical edition measurements promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Change-auditing-_002d-the-all-seeing-eye">Change auditing - the all seeing eye</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Cheaper options - tripwires</h3>

<p>Doing a change detection scan is a convergent process, but it can
still detect changes and present the data in a compressed format
that is often more convenient than auditing. The result is less precise,
but there is a trade-off between precision and cost.

   <p>To make a change tripwire, you use a <samp><span class="file">files</span></samp> promise, something like this:

<pre class="verbatim">body common control
{
bundlesequence  => { "testbundle"  };
}
#

bundle agent testbundle

{
files:

  "/home/mark/tmp" -> "me"
       changes      => scan_files,
       depth_search => recurse("inf");
}

# library code ...

body changes scan_files
{
report_changes => "all";
update_hashes  => "true";
}

body depth_search recurse(d)
{
depth        => "$(d)";
}
</pre>

   <p>In CFEngine Nova, reports of the following form are generated when these promises
are kept by the agent:

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">Change detected 	 File change
Sat Dec 5 18:27:44 2009  group for /tmp/testfile changed 100 -> 0
Sat Dec 5 18:27:44 2009  /tmp/testfile
Sat Dec 5 18:20:45 2009  /tmp/testfile 
</pre>
</td></tr></table>

<p class="noindent">These reports are generated automatically in CFEngine Nova,
and are integrated into the web browsable knowledge map. Community
edition users have to extract the data and create these themselves.

<div class="node">
<a name="Commerical-edition-measurements-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Hub-reporting">Hub reporting</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Cheaper-options-_002d-tripwires">Cheaper options - tripwires</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Commercial edition measurements promises</h3>

<pre class="sp">

</pre>

In commercial versions of CFEngine, you can extract data from the
system in more sophisticated ways from files or pipes, using Perl
Compatible Regular Expressions to match text. The <code>cf-monitord</code>
agent is responsible for processing measurement promises.

   <p>In this example, we count lines matching a pattern in a file. 
You might want to scan a log for instances of a particular
message and trace this number over time.

<pre class="verbatim">bundle monitor watch
{
measurements:

   "/tmp/file"

         handle => "line_counter",
    stream_type => "file",
      data_type => "counter",
    match_value => scanlines("MYLINE.*"),
   history_type => "log";

}

#

body match_value scanlines(x)
{
select_line_matching => "^$(x)$";
}

</pre>

   <p>See the CFEngine Nova documentation for more possibilities of measurement
promises.

<div class="node">
<a name="Hub-reporting"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mission-Portal-access-to-the-hub">Mission Portal access to the hub</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Commerical-edition-measurements-promises">Commerical edition measurements promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Hub Reporting</h3>

<p>In the commercial editions of CFEngine much more extensive and searchable
reporting is available.

<div class="node">
<a name="Mission-Portal-access-to-the-hub"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Command-line-access-to-the-hub">Command line access to the hub</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Hub-reporting">Hub reporting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Mission Portal access to the hub</h3>

<p>The preferred approach to querying information on a hub
is to use the web interface in the Mission Portal. 
This gives the greatest flexibility in both search
and presentation of data. Given the extensiveness of
the Mission Portal user interface, the details are
covered in a separate document.

<div class="node">
<a name="Command-line-access-to-the-hub"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example-command-hub-searches">Example command hub searches</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mission-Portal-access-to-the-hub">Mission Portal access to the hub</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Command line access to the hub</h3>

<p>Users with login access to the hub can also use the command line tool
<code>cf-report</code> to extract a limited view of the data. 
Currently supported reports include:

     <dl>
<dt><code>compliance</code><dd>The percentage total compliance log for all hosts. 
<br><dt><code>dead-clients</code><dd>Shows a list of client hosts that have not made incoming requests within the standard
time horizon (default 15 minutes). 
<br><dt><code>file_changes</code><dd>The change log
<br><dt><code>file_diffs</code><dd>The change details for text files. 
<br><dt><code>last-seen</code><dd>Show the last time hosts connnected to the hub
<br><dt><code>promises</code><dd>Compliance by promise, labelled by promise-handle. 
<br><dt><code>setuid</code><dd>The list of setuid/setgid root files detected on the system. 
<br><dt><code>software</code><dd>The installed software base of the system. 
<br><dt><code>summary</code><dd>A summary of how many hosts are compliant within a given set of search parameters. 
<br><dt><code>vars</code><dd>The values of variables set on hosts. 
</dl>

<p class="noindent">Some special command line options are supported in the commercial versions.

     <dl>
<dt>&lsquo;<samp><span class="samp">--query-hub</span></samp>&rsquo;<dd>or &lsquo;<samp><span class="samp">-q</span></samp>&rsquo; Query hub database interactively. This option is the entry point
for querying the hub data with <code>cf-report</code>, and must always be specified.

     <br><dt>&lsquo;<samp><span class="samp">--show name</span></samp>&rsquo;<dd>Select the name of the report from the above list.

     <br><dt>&lsquo;<samp><span class="samp">--promise-handle</span></samp>&rsquo;<dd>or &lsquo;<samp><span class="samp">-p regex</span></samp>&rsquo;. For promise compliance report, this defines a
regular expression to search for promises of a specific name. Specify a promise-handle to look up

     <br><dt>&lsquo;<samp><span class="samp">--hostkey</span></samp>&rsquo;<dd>or &lsquo;<samp><span class="samp">-k hashkey</span></samp>&rsquo;. 
Specify a particular host to query for data, using the unique host-key.

     <br><dt>&lsquo;<samp><span class="samp">--class-regex</span></samp>&rsquo;<dd>or &lsquo;<samp><span class="samp">-c regex</span></samp>&rsquo; - Specify a class regular expression to search for

     <br><dt>&lsquo;<samp><span class="samp">--filter</span></samp>&rsquo;<dd>or &lsquo;<samp><span class="samp">-F regex</span></samp>&rsquo; - Specify a name regular expression for filtering results
</dl>

<div class="node">
<a name="Example-command-hub-searches"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Command-line-access-to-the-hub">Command line access to the hub</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Example command hub searches</h3>

<p>If only a host-key is specified, CFEngine returns with the last known location and identity
of the host. (Note that, in the following examples, the SHA keys are reduced for readability).
<pre class="verbatim">
host# cf-report -q --hostkey  SHA=bd6dfcc2... 
 -> Hostname: hub.test.cfengine.com
 -> Recent IP Addresses: 10.0.0.29

</pre>
To dump all values from all hosts:
<pre class="verbatim">
cf-report -q --show promises
cf-report --query-hub --show promises

</pre>
You can select a single host for a particular report:
<pre class="verbatim">cf-report -q --hostkey SHA=c40fb732c6e5... --show vars
</pre>
Or you can select a CFEngine class of hosts that will be selected to report
<pre class="verbatim">cf-report -q --show summary --class-regex linux
cf-report -q --show summary --class-regex SuSE
cf-report -q --show summary --class-regex NewYork
</pre>
Here are some examples using filters to 'grep' out certain items:
<pre class="verbatim">
cf-report -q --hostkey SHA=c40fb732c6...  --show vars --filter date

cf-report -q --filter "mail.*" --hostkey  SHA=bd6dfccb1a... --show setuid

cf-report -q  --show promises -p knowledge_files_db_stamp

</pre>

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Reporting</a>
<ul>
<li><a href="#What-are-monitoring-and-reporting_003f">What are monitoring and reporting?</a>
<li><a href="#Should-monitoring-and-configuration-be-separate_003f">Should monitoring and configuration be separate?</a>
<li><a href="#Reporting-in-CFEngine">Reporting in CFEngine</a>
<li><a href="#Standard-reports-in-CFEngine">Standard reports in CFEngine</a>
<li><a href="#CFEngine-output-levels">CFEngine output levels</a>
<li><a href="#Creating-custom-reports-_002d_002d-all-versions">Creating custom reports &ndash; all versions</a>
<li><a href="#Including-data-in-reports">Including data in reports</a>
<li><a href="#Creating-custom-logs">Creating custom logs</a>
<li><a href="#Redirecting-output-to-logs">Redirecting output to logs</a>
<li><a href="#Change-auditing-_002d-the-all-seeing-eye">Change auditing - the all seeing eye</a>
<li><a href="#Cheaper-options-_002d-tripwires">Cheaper options - tripwires</a>
<li><a href="#Commerical-edition-measurements-promises">Commercial edition measurements promises</a>
<li><a href="#Hub-reporting">Hub Reporting</a>
<li><a href="#Mission-Portal-access-to-the-hub">Mission Portal access to the hub</a>
<li><a href="#Command-line-access-to-the-hub">Command line access to the hub</a>
<li><a href="#Example-command-hub-searches">Example command hub searches</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

</body></html>

